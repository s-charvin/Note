---
title: "C++ 笔记"
author: "石昌文"
tags: [""]
description: ""
categories: [""]
keywords:  [""]
type: ""
draft: true
layout: 
data: 2022-08-07 10:29:09
lastmod: 2022-09-05 16:48:37
---

# C++开发环境及IDE安装

[MinGW安装（Windows）_w3cschool](https://www.w3cschool.cn/c/install-mingw.html)

[配置CLion用于STM32开发【优雅の嵌入式开发】 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/145801160)

[CLion 中 的 MinGW 配置（及中文坑解决） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/43680621)

[Clion 配置C/C++环境 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/40776005)

[(33条消息) Clion的安装和配置（C/C++开发神器）_王菜鸟的博客-CSDN博客_clion](https://blog.csdn.net/qq_44723773/article/details/104698675)

[(33条消息) STM32HAL库学习（二）利用Visual Studio 2017 + Visual GDB建立STM32工程并移植TFT_凡人就行的博客-CSDN博客](https://blog.csdn.net/u011619535/article/details/82355239)

[VS下STM32开发环境搭建 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/28813251)

[(33条消息) 在Visual Studio上开发ARM嵌入式软件_season_lzw的博客-CSDN博客_vs开发嵌入式](https://blog.csdn.net/season_lzw/article/details/50492667)

[手把手教你用CLion玩转STM32 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/444893180)

[(33条消息) ubuntu 使用clion 搭建stm32开环境使用stlink下载调试_音柯路德的博客-CSDN博客_clion stm32调试](https://blog.csdn.net/weixin_41115751/article/details/121439534)

[Docs (feishu.cn)](https://uk0mjrsnkf.feishu.cn/docx/doxcnUbs3RJby8CxKHYOh3nSi3f)

# 基础知识

## 代码语句

- 在 C++ 中，大多数 C++ 语句以分号表示结束。

### 数据结构

#### 基本数据类型

字面值类型

##### 算数 数据类型

- 内置算数数据类型：布尔值、字符、整型、浮点数、空类型、字面值常量、转义序列
- 数据尺寸
	- ![](C++.assets/image-20220813092029.png)
	- 可寻址的最小内存块称为 “字节（byte）”
	- 存储的基本单元称为 “字（word）”，它通常由几个字节组成。
	- 大多数机器的字节由 8 比特构成，字则由 32 或 64 比特构成，也就是4 或 8 字节。![](C++.assets/image-20220813092704.png)
	- 一个 `char` 的大小和一个机器字节一样，因为需要确保可以存放机器基本字符集。
	- 通常 `float` 以 1 个字（ 32 比特）来表示，`double` 以 2 个字（ 64 比特）来表示，`long double` 以 3 或 4 个字（ 96 或 128 比特）来表示。
- 数据符号类型
	- 带符号类型可以表示正数、负数或0，无符号类型则仅能表示大于等于0的值。
	- 整数类型 `int` 、`short` 、`long` 和 `long long` 都是带符号的。且可以通过在这些类型名前添加 `unsigned` 得到对应的无符号类型。
	- 字符型可以被分为三种类型：`char`、`signed char` 和 `unsigned char`。其中 `char` 类型表现形式由编译器决定，可能是无符号类型，也可能是有符号类型。
- 字面值常量的形式和值决定了它的数据类型。
	- 整数进制 --> 十进制： `20` ，八进制： `024` ，十六进制： `0x14`  
		- 十进制字面值的类型是 `int` 、 `long` 和 `long long` 中尺寸最小的那个 
		- 八进制和十六进制字面值的类型是能容纳其数值的 `int` 、 `unsigned int` 、 `long` 、 `unsigned long` 、 `long long` 和 `unsigned long long` 中的尺寸最小者。 
	- 小数表现形式 -->  `3.14159`，`3.14159E0`，`0.`，`0e0`，`.001` 
	- 字符表现形式 --> 单字符： `'a'` ，字符串： `"Hello world!"`  
		- 编译器会在每个字符串的结尾处添加一个空字符（`′\0′`），因此，字符串字面值的实际长度要比它的内容多 1。 
		- 转义字符
			- C++ 语言规定的转义字符 ![](C++.assets/image-20220813094723.png)
			- 泛化的转义字符，其形式是 `\x` 后紧跟 1 个或多个十六进制数字，或者 `\` 后紧跟 1 个、2 个或 3 个八进制数字 ![](C++.assets/image-20220813094924.png)

	- 添加前缀和后缀，可以改变整型、浮点型和字符型字面值的默认类型。 ![](C++.assets/image-20220813095018.png)
	- `true` 和 `false` 是布尔类型的字面值。 
	- `nullptr` 是空指针字面值。

##### 引用和指针

###### “左值引用”

（lvalue reference） 

```c++
int i1 = 1024, i2 = 2048;
int &r1 = i1, &r2 = i2;

```

- 特点
	- 功能：为已创建的变量，起另外一个名字
	- 定义引用时，程序把引用和它的初始值绑定（bind）在一起，而不是将初始值拷贝给引用。 
	- 引用必须初始化，且无法令引用重新绑定到另外一个对象。
	- 引用本身不是一个对象，所以不能定义引用或字面值的引用。

###### 指针

```c++
int i1 = 1024, i2 = 2048;
int *r1 = &i1, *r2 = &i2;

```

- 特点
	- 功能：建立一个指向已有对象的对象，允许通过指针实现对其他对象的间接访问。
	- 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。
	- 指针无须在定义时赋初值，但建议初始化所有指针。
	- 因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。
	- 如果实在不清楚指针应该指向何处，就把它初始化为 nullptr 或者 0 
	- 指针是内存中的对象，像其他对象一样也有自己的地址
- 利用指针访问对象
	- 解引用符 `*` 可以用来取出指针指向的对象 
		- 如果给解引用的结果赋值，实际上也就是给指针所指的对象赋值：
	- `nullptr`（建议） 、`0`、`NULL` 可以用来初始化空指针后，空指针可以被转换成任意其他的指针类型。 
- 指针赋值
	- 给指针赋值就是令它存放一个新的地址，从而指向一个新的对象。
	- `void＊` 是一种特殊的指针类型，可用于存放任意对象的地址。 
		- 以 `void＊` 的视角来看内存空间也就仅仅是内存空间，没办法访问内存空间中所存的对象 

###### “右值引用”

（rvalue reference）

##### 数组

- 特点
	- 数组的使用与 Vector 类似，但是性能更优，灵活性低。
	- 在定义数组时，必须指定一个大于零的常量表达式作为维度，或者提供一个初始值；
	- 在定义数组时，必须声明数组的类型，不允许通过 `auto` 关键字自动推断。
	- 原生不允许将数组内容拷贝给其他数组作为其初始值，或者赋值。
	- 在一些情况下，数组可以看做是一个指针，指向第一个元素。

- 数组定义
	```c++
	const unsigned sz= 3;
	int arr[10]; // 含有十个整数的数组
	int *parr[10];		// 含有10个整型指针的数组
	string strs[get_size()];  //get_size是constexpr时正确；否则错误
	int ial[sz] = {0,1,2}; // 给定初始值的，三维数组
	int a2[] = {0,1,2}; // 给定初始值的，三维数组
	string a3[sz] = {"a","b"}; // 部分初始化的三维数组，相当于a3[3] = {"a","b",""} 
	```
	- 定义 `char` 类型的字符数组 ( C 语言风格的字符串) 
		- 可以通过字符串字面值进行初始化，注意：字符串字面值结尾的附加空字符也会被拷贝到字符数组中。
			```c++
			char a1[] = {'C', '+', '+'};		// 没有空字符的自定义初始化
			char a2[] = {'C', '+', '+', '\0'};	//手动添加空字符的初始化
			char a3[] = "C++";					// 这里在初始化时，会自动添加字符串字面值中的空字符
			const char a4[3] = "C++";			// 错误，没有空间可存放字符串字面值中的空字符
			```
- 数组元素访问
	- 数组下标可以是无符号类型，如用 `cstddef` 里面的 `size_t` 类型。 也可以通过不指向首位置的数组指针，进行负值下标访问。
	- 遍历数组所有元素时，最好的方法就是使用范围 for 语句。
- 数组的迭代
	- 在大多数表达式中，使用的数组类型的对象就是指向该数组首元素的指针。也就是说数组类型的对象支持迭代器操作，并且对于 `vector` 和 `string` 支持的迭代器运算，数组的指针也支持。
	- 数组的指针和引用
		```c++
		int (*Parray)[10] = &arr;	//Parray是一个指向 int[10] 类型的指针 
		int (&arrRef)[10] = arr;	//arrRef是一个 int[10]类型的引用
		int *(&arry)[10] = ptrs;	//arry是一个引用，指向的是 含有10个int类型指针的数组
		```
		- 类型修饰符的理解，简单的可以通过从左向右依次绑定的方式。对于含有括号的复杂形势，可以通过由内向外的理解方式。
		- 在定义指向数组的指针时，编译器会自动将其设置为指向数组首元素的指针。即 `int *p1 = arr;` = `int *p2 = &arr[0];` 
		- 数组指针进行相减运算得到的是两者之间的距离数值，其类型为 `cstddef` 头文件中的一种 `ptrdiff_t` 类型。 
	- 起始指针和尾后指针的获取方式
		- 起始指针可以简单的由数组对象或数组首元素的地址获得。也可以通过 `iterator.h` 头文件中的函数 `begin`  获得。
		- 尾后指针可以通过指向尾元素下一个位置的指针表示。即 `int *e = &arr[end+1];` ，也可以通过 `iterator` 头文件中的函数 `end`  获得。
		```c++
		int ia[] = {0, 1, 2, 3, 4, 5, 6, 7};
		for(int *beg = begin(ia); beg != end(ia);++beg){
			statements;
		};
		```
- 多维数组
	- 多维数组其实是数组的数组，即靠外侧的数组的指针就是一个指向数组的指针。

##### 类

- 类结构初步定义

```c++
struct Example {
	statement;
};
Example example;
example.state;
```

- 特点：
	- 类内部定义的名字必须唯一，但是可以与类外部定义的名字重复。
	- 类体右侧的表示结束的花括号后必须写一个分号
- 类别名![](C++.assets/image-20220813175031.png)![](C++.assets/image-20220813175044.png)
	- 分割复合类型定义顺序![](C++.assets/image-20220813180414.png)![](C++.assets/image-20220813180425.png)
		- 上图，前者是指向 char 类型对象的常量指针，后者是指向 const char 类型对象的指针。

###### 类数据成员

###### 类行为

- 重载运算符，如（加法、赋值、复合）
	- 使用重载运算符时，其包括运算对象的类型和返回值的类型，都是由该运算符定义的；但是运算对象的个数、运算符的优先级和结合律都是无法改变的。

###### 类成员函数

#### Const 限定符

#### `auto` 类型说明符

- `auto` ？
	- `auto` 可以让编译器通过初始值来推算变量的类型。![](C++.assets/image-20220814125651.png)
	- 当引用被用作初始值时，真正参与初始化的其实是引用对象的值。此时编译器以引用对象的类型作为auto的类型。
	- 当 const 类型作为初始值时，auto 一般会忽略掉顶层const，同时底层 const 则会保留下来。

#### `decltype` 类型说明符

- `decltype` 可以从表达式（函数）的返回类型推断出要定义的变量的类型。![](C++.assets/image-20220814131746.png)
	- 编译器并不实际调用函数，而是使用当调用发生时函数的返回值类型作为sum的类型。
	- 如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）
	- 如果变量名加上了一层或多层括号，编译器就会把它当成是一个表达式，并最终得到一个引用类型。![](C++.assets/image-20220814134536.png)
	- 如果表达式的内容是解引用操作（`decltype(*p)`），则 decltype 将得到引用类型。![](C++.assets/image-20220814134602.png)
- 特点
	- 功能：定义一种变量，它的值不能被改变。
		- 因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化。
	- Const 限定状态，仅仅在执行改变此向量的操作时才会发挥作用。
	- 默认状态下，const 对象仅在文件内有效。
		- 想要只在一个文件中定义 const，而在其他多个文件中声明并使用它。可以添加`extern`关键字
- const 的引用
	- 对常量的引用（ 对 const 的引用）![](C++.assets/image-20220813115116.png)
		- 功能：常量引用，不能被用作修改它所绑定的对象。
		- C++ 允许用字面值初始化常量引用。
	- 对非常量的常量引用![](C++.assets/image-20220813115634.png)
		- 功能：因为对象是个非常量，所以允许通过其他途径改变它的值。即引用的对象本身是不是一个常量未作限定。
- const 的指针
	- 指向常量或非常量的常量指针![](C++.assets/image-20220813141401.png)![](C++.assets/image-20220813141147.png)
		- 功能：要想存放常量对象的地址，只能使用指向常量的指针。
		- 如果对象是个非常量，则允许通过其他途径改变它的值。
	- const 指针（常量指针）![](C++.assets/image-20220813142108.png)
			- 功能：定义一个指向常量对象的常量指针。此定义更加严格些。
			- 常量指针（const pointer）必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能再改变了。
	- 顶（底）层const![](C++.assets/image-20220813165823.png)
		- 顶层 const（top-level const）表示指针本身是个常量
		- 底层 const（low-level const）表示指针所指的对象是一个常量。
			- 底层const进行一些操作时，如拷贝，需要拷入和拷出的对象必须具有相同的底层 const 类型，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之则不行。![](C++.assets/image-20220813170346.png)

#### 数据初始化

- 赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数 `256/65536/4294967296/... - |X|`。
- 赋给带符号类型一个超出它表示范围的值时，结果是未定义的（undefined）。

- 列表初始化![](C++.assets/image-20220813100104.png)
	- 如果赋值语句的左侧运算对象是内置类型，那么右侧初始值列表最多只能包含一个值。
	- 如果赋值语句的右侧初始值需要转换为左侧运算对象类型，则其所占空间不应该大于目标类型的空间。
	- `vector` 模板重载了赋值运算符并且可以接收初始值列表，当赋值发生时用右侧运算对象的元素替换左侧运算对象的元素。
- 如果定义变量时没有指定初值，则变量被默认初始化。
- 定义在函数体内部的内置类型变量将不被初始化
- 变量命名规范
	- 变量名一般用小写字母，如 index，不要使用 Index 或 INDEX 。
	- 用户自定义的类名一般以大写字母开头，如Sales_item。
	- 果标识符由多个单词组成，则单词间应有明显区分，如student_loan或studentLoan，不要使用studentloan。
	- 不使用C++内部关键字![](C++.assets/image-20220813100822.png)![](C++.assets/image-20220813100849.png)
- constexpr 和常量表达式![](C++.assets/image-20220813173930.png)![](C++.assets/image-20220813174039.png)
	- 特点：在编译过程就能得到计算结果的表达式
	- C++11新标准规定，允许将变量或函数声明为constexpr类型以便由编译器来验证变量值或返回值是否是一个常量表达式。
		- constexpr类型的指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。且 constexpr 指针只能指向地址固定不变的变量。

### 常见数据运算符

#### 运算符类型

一个符号到底是一元运算符还是二元运算符由它的上下文，即前后作用对象决定。

- 一元运算符（unary operator）
	- 作用于一个运算对象的运算符是一元运算符，如取地址符（`&`）和解引用符（`*`）；
- 二元运算符（binary operator）。
	- 作用于两个运算对象的运算符是二元运算符，如相等运算符（`==`）和乘法运算符（`*`）。
- 三元运算符（ternary operator）
	- 还有一个作用于三个运算对象的三元运算符。
- 特殊运算符
	- 函数调用是一种特殊的运算符，它对运算对象的数量没有限制。

#### 常用运算符介绍

- `<<` 运算符接受两个运算对象：左侧的运算对象必须是一个ostream对象，右侧的运算对象是要打印的值。计算结果返回左侧运算对象。
- `>>` 运算符接受两个运算对象：左侧的运算对象必须是一个istream对象，右侧的为读入数据存储对象。它从给定的istream读入数据，并存入给定对象中。
- 操纵符 `std::endl` 效果是结束当前行，并将与设备关联的缓冲区（buffer）中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入输出流中，而不是仅停留在内存中等待写入流。
- 代码注释符号：`/＊ ... ＊/`; `// ...`
- 算术运算符：`+`、`-`、`*`、`/`、`++`、`%`、`--`
	- 算术运算符能作用于任意算术类型以及任意能转换为算术类型的类型。
	- 整数相除的结果还是整数，也就是说，如果商含有小数部分，直接弃除。
	- 参与取余运算的运算对象必须是整数类型。
	- 取余运算 `m%n` 不等于 0，则它的符号和 `m` 相同。
	- 递增和递减运算符有两种形式：前置版本和后置版本。
		- 前置版本`++i`，首先将运算对象加 1（或减 1），然后将改变后的对象作为求值结果，类型为左值。
		- 后置版本 `i++`，首先将运算对象加 1（或减 1），然后将运算对象改变之前那个值的副本作为求值结果，类型为右值。
			- 适合先输出，再 +1 的情况
	- 普通算数运算符的运算对象和求值结果都是右值。
- 关系运算符：`==`、`!=`、`>`、`<`、`>=`、`<=`
	- 关系运算符能作用于任意算术类型或指针类型。
	- 运算对象和求值结果都是右值。
- 逻辑运算符：`&&`、`||`、`!`
	- 逻辑运算符能作用于任意能转换成布尔值的类型。
	- `&&` 短路求值：仅当左侧运算对象为假时才对右侧运算对象求值。
	- `||` 短路求值：当且仅当左侧运算对象为真时才对右侧运算对象求值。
	- 运算对象和求值结果都是右值。
- 位运算符：`&`、`|`、`^`、`~`、`<<`、`>>`
	- "与"、"或"、"异或"、左移（左边的二进制位丢弃，右边补 0）、右移（正数左补 0，负数左补 1，右边丢弃）
	- 位运算符进行运算之前，会先判断运算对象是否需要提升类型
	- 左移运算符（<<）在右侧插入值为 0 的二进制位，左侧超出边界的位被移除。
	- 右移运算符（>>）的行为则依赖于其左侧运算对象的类型：如果该运算对象是无符号类型，在左侧插入值为0的二进制位；如果该运算对象是带符号类型，在左侧插入符号位的副本或值为0的二进制位，如何选择要视具体环境而定。之后右侧超出边界的位被移除。
	- 可以作用于整数类型的运算对象或者标准库 `bitset` 类型对象。
	- 应用：
		- 想将数据某一位（如第 k 位）强行设置为 1，可以通过与 `1UL<<k` 进行或运算实现（`UL==unsigned long`）
		- 想将数据某一位（如第 k 位）强行设置为 0，可以通过与 `~(1UL<<k)` 进行与运算实现（`UL==unsigned long`）
		- 想要判断某一位（如第 k 位）是否为 1，可以通过与 `1UL<<k` 进行与运算实现（`UL==unsigned long`）
			- 是 1，则计算的结果非 0（真）（有一位为 1）。否则计算结果为 0（假）（所有位均为 0）
		- 想要判断某一位（如第 k 位）是否为 0，可以通过与 `~(1UL<<k)` 进行或运算实现（`UL==unsigned long`）
			- 是 0，则计算的结果为不全是 1（真）（只有一位为 0）。否则计算结果所有位为 1.
- 赋值运算符
	- `=`、`+=`、`-=`、`*=`、`/=`、`%=`、`<<=`、`>>=`、`&=`、`^=`、`|=`
	- 如果赋值运算符的左右两个运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型。
	- 左侧运算对象为可修改的左值，右侧运算对象看情况。求值结果为左侧运算对象类型。
- 杂项运算符
	- 计算变量所占的字节数大小的运算符：`sizeof`
		- 所得的值是一个 size_t 类型的常量表达式
		- 对 char 或者类型为 char 的表达式执行 sizeof 运算，结果得 1。
		- 对引用类型执行 sizeof 运算得到被引用对象所占空间的大小。
		- 对指针执行 sizeof 运算得到指针本身所占空间的大小。
		- 对解引用指针执行 sizeof 运算得到指针指向的对象所占空间的大小，指针不需有效。
		- 对数组执行 sizeof 运算得到整个数组所占空间的大小。此外还可以用数组的大小除以其单个元素的大小（如 `*array`）得到数组中元素的个数。
		- 对 string 对象或 vector 对象执行 sizeof 运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。
	- 条件运算符：`Condition ? X : Y`
		- 条件为真，则执行 X 表达式。反之，则执行 Y 表达式
		- 条件运算符可以嵌套。
		- 当条件运算符的两个表达式都是左值或者能转换成同一种左值类型时，运算的结果是左值；否则运算的结果是右值。
	- 逗号运算符：`,`
		- 首先对左侧的表达式求值，然后将求值结果丢弃掉。逗号运算符真正的结果是右侧表达式的值。如果右侧运算对象是左值，那么最终的求值结果也是左值。
	- 成员访问运算符：`.` 和 `->`
		- 类对象直接访问：`s.size()`
		- 指针访问：`p->size()` 或 `(*p).size()`
		- 箭头运算符作用于一个指针类型的运算对象，结果是一个左值。点运算符分成两种情况：如果成员所属的对象是左值，那么结果是左值；反之，如果成员所属的对象是右值，那么结果是右值。
	- 指针运算符：`&`、`*`

#### 运算对象

C++ 的表达式要不然是右值（rvalue，读作“are-value”），要不然就是左值（lvalue，读作“ell-value”）。

当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。

不同的运算符对运算对象的要求各不相同，有的需要左值运算对象、有的需要右值运算对象；返回值也有差异，有的得到左值结果、有的得到右值结果。

当一个左值被当成右值使用时，实际使用的是它的内容（值）。反之则不可以。

- 赋值运算符需要一个（不是常量）左值作为其左侧运算对象，得到的结果也仍然是一个左值。
- 取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值。
- 内置解引用运算符、下标运算符、迭代器解引用运算符、string 和 vector 的下标运算符的求值结果都是左值。
- 内置类型和迭代器的递增递减运算符作用于左值运算对象，本书之前章节所用的形式，所得的结果也是左值。
- 使用关键字decltype的时候，如果表达式的求值结果是左值，decltype作用于该表达式得到一个引用类型。举个例子，假定p的类型是int＊，因为解引用运算符生成左值，所以decltype（＊p）的结果是int&。另一方面，因为取地址运算符生成右值，所以decltype（&p）的结果是int＊＊，也就是说，结果是一个指向整型指针的指针。

#### 运算符的优先级、结合律和求值顺序

优先级与结合律决定了运算对象复杂组合的方式，其中优先级控制不同对象的紧密结合程度，结合律控制同优先级对象的组合规则。

![](C++.assets/image-20220902153749.png)

![](C++.assets/image-20220902153847.png)

- 运算结合律
	- 左结合律，意味着当优先级相同时按照从左向右的顺序进行组合。
- 括号无视优先级与结合律，使其内对象得到优先运算。
- 优先级规定了运算符中运算对象的组合方式，但是大部分运算符并没有规定其中表达式对象的求值顺序。
	```c++
		int i = f1()*f2(); // 两个函数哪个先调用是未知的
		cout << i << " " << ++i << endl; // i 和 ++i 哪个先调用也是未定义的
	```
- 求值顺序
	- 逻辑与 `&&` 运算符规定先求左侧运算对象的值，只有当左侧运算对象的值为真时才继续求右侧运算对象的值。 
	- 逻辑或 `||` 运算符
	- 条件（`?:`）运算符
	- 逗号（`,`）运算符

#### 运算对象转换

C++语言不会对两种不同类型的值进行运算，而是先根据类型转换规则，设法将被运算对象的类型统一后再求值。

##### 隐式类型转换规则

- 整型提升
	- 在大多数表达式中，比 `int` 类型小的整型值（如 `bool`、`char`、`signed char`、`unsigned char`、`short` 和 `unsigned short` 等类型），只要它们所有可能的值都能存在 `int` 里，它们就会提升成 `int` 类型；否则，提升成 `unsigned int` 类型。
	- 对于较大的 char 类型（如 `wchar_t`、`char16_t`、`char32_t`），提升成 `int`、`unsigned int`、`long`、`unsigned long`、`long long` 和 `unsigned long long` 中，能容纳原类型最小的一种类型。
- 整形转换成浮点
	- 整数类型和浮点数类型同时进行运算时，整型会转换成相应的浮点型。但如果该整数所占的空间超过了浮点类型的容量，精度可能有损失。 
- 符号提升
	- 如果两个（整型提升后的）运算对象的类型要么都是带符号的、要么都是无符号的，则小类型的运算对象转换成较大的类型。
	- 如果一个运算对象是无符号类型、另外一个运算对象是带符号类型，而且其中的无符号类型不小于带符号类型，那么带符号的运算对象转换成无符号的。例如，假设两个类型分别是 unsigned int 和 int，则 int 类型的运算对象转换成 unsigned int 类型。需要注意的是，如果 int 型的值恰好为负值，其结果将以 2.1.2 节（第 32 页）介绍的方法转换，并带来该节描述的所有副作用。首先把负数转换成无符号数。把负数转换成无符号数类似于直接给无符号数赋一个负值，结果等于这个负数加上无符号数的模。然后再进行对象运算。
	- 如果一个运算对象是无符号类型、另外一个运算对象是带符号类型，而且带符号类型大于无符号类型，此时转换的结果依赖于机器。如果无符号类型的所有值都能存在该带符号类型中，则无符号类型的运算对象转换成带符号类型。如果不能，那么带符号类型的运算对象转换成无符号类型。例如，如果两个运算对象的类型分别是long和unsigned int，并且int和long的大小相同，则long类型的运算对象转换成unsigned int类型；如果long类型占用的空间比int更多，则unsigned int类型的运算对象转换成long类型。
- 在赋值语句中，右侧运算对象将转换成左侧运算对象的类型。
	- 把一个浮点数赋给整数类型时，进行了近似处理。结果值将仅保留浮点数中小数点之前的部分。
- 数组转换成指针
	- 在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针。
		- 当数组被用作 decltype 关键字的参数，或者作为取地址符（&）、sizeof 及 typeid 等运算符的运算对象时，上述转换不会发生。
		- 如果用一个引用来初始化数组，上述转换也不会发生。
- 指针的转换
	- 常量整数值 0 或者字面值 nullptr 能转换成任意指针类型
	- 指向任意非常量的指针能转换成 `void＊`
	- 指向任意对象的指针能转换成 `const void＊`
- 布尔类型转换
	- 把一个非布尔类型的算术值赋给布尔类型时，初始值为 0 则结果为 false ，否则结果为 true 。
	- 把一个布尔值赋给非布尔类型时，初始值为 false 则结果为 0 ，初始值为 true 则结果为 1 。
- 转换成常量
	- 允许将指向不是常量类型数据的指针或引用，转换成指向相应的常量类型的指针。
		- 即可以给不是常量类型数据，定义常量类型指针或引用。反过来就不行。
- 类类型定义的转换
	- 即标准库或自定义的类类型，有的可以自动进行转换。（如：C风格字符串自动转换为String；istream类型自动转换为布尔值）

##### 显式强制类型转换

###### 命名的强制类型转换

形式：`cast-name<type>(expression);`

cast-name ：`static_cast`、`dynamic_cast`、`const_cast` 和 `reinterpret_cast`

- static_cast
	- 任何具有明确定义的类型转换，只要不包含底层 const，都可以使用 static_cast 。
		- `double slope = static_cast<double>(j)/ i;`
	- 功能：告诉程序的读者和编译器，不在乎类型转换蕴含的潜在精度损失（正常会出现警告）。
	- 当需要把一个较大的算术类型赋值给较小的类型时，static_cast 非常有用，不使用。
	- 对于编译器无法自动执行的类型转换也非常有用，如将 `void` 类型数据转换成指定类型的数据。
- const_cast
	- 可以将常量对象转换成非常量对象，去掉其 `const` 性质。反过来也可以将非常量对象转换成常量对象。
	- 如果对象本身不是一个常量，使用强制类型转换获得写权限是合法的行为。然而如果对象是一个常量，再使用 const_cast 执行写操作就会产生未定义的后果。
	- 只有 const_cast 能改变表达式的常量属性，使用其他形式的命名强制类型转换改变表达式的常量属性都将引发编译器错误。同样的，也不能用 const_cast 改变表达式的类型。
- reinterpret_cast
	- 为运算对象的位模式提供较低层次上的重新解释。
	- P146 / P556

### 作用域

块作用域：C++语言中大多数块作用域都以花括号分隔。

嵌套的作用域：允许在内层块作用域中重新定义外层块作用域已有的名字。

#### 局部变量

函数形参和语句块内部定义的变量统称为局部变量。其仅能在所处作用域内可见，同时局部变量还会隐藏在外层作用域中同名的其他所有声明中。

自动对象

对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它。我们把只存在于块执行期间的对象称为自动对象（automatic object）。当块的执行结束后，块中创建的自动对象的值就变成未定义的了。

局部静态对象

某些时候，有必要令局部变量的生命周期贯穿函数调用及之后的时间，此时可以将局部变量定义成 `static` 类型从而获得这样的局部静态对象。在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。

### 控制流语句

#### 空语句

#### while 语句

- 定义在 while 条件部分或者 while 循环体内的变量每次迭代都经历从创建到销毁的过程。

#### do while 语句

- do while 语句先执行循环体后，再检查条件。即不管条件的值如何，我们都至少执行一次循环。
- 因为对于do while来说先执行语句或者块，后判断条件，所以不允许在条件部分定义变量

#### for 语句

- `init` 也可以定义多个对象。但是 `init` 只能有一条声明语句，因此，所有变量的基础类型必须相同。
- 省略 `condition` 的效果等价于在条件部分写了一个 `true`。因为条件的值永远是 `true`，所以在循环体内必须有语句负责退出循环，否则循环就会无休止地执行下去。
- 省略掉 `for` 语句头中的 `expression`，就要求条件部分或者循环体必须改变迭代变量的值。

#### 范围 for 语句

- 可以遍历容器或其他序列的所有元素。
- 如果需要对序列中的元素执行写操作，循环变量必须声明成引用类型。
- 序列中的每个元素都需要能转换成被定义变量的类型（最方便的就是用 `auto` ）。
- 等价的 for 语句
	- ![](C++.assets/image-20220903211315.png)

#### if 语句

#### switch 语句

- 如果某个 case 标签匹配成功，将从该标签开始往后顺序执行所有 case 分支，除非程序显式地中断了这一过程，否则直到 switch 的结尾处才会停下来。
- 可以把几个 case 标签写在一行里，强调这些 case 代表的是某个范围内的值：
	- `case 'a' : case 'e' : case 'i' : case 'o' : case 'u' : statement;`
- case 分支不可以含有与其他分支共用的隐式或显式变量初始化。

#### 跳转语句

- break
	- break 语句负责终止离它最近的 while、do while、for 或 switch 语句，并从这些语句之后的第一条语句开始继续执行。
	- break语句的作用范围仅限于最近的循环或者switch。
- continue
	- continue 语句终止最近的 for、while 和 do while 循环中的当前迭代并立即开始下一次迭代。
	- continue 语句的作用范围仅限于最近的循环语句。因此也只有当 switch 语句嵌套在迭代语句内部时，才能在 switch 里使用 continue。
- goto
	- goto 语句的作用是从 goto 语句无条件跳转到同一函数内的另一条语句处，跳转位置由预设的标示符控制。（不建议使用）
	- 被跳过的语句，不可以含有后续语句所使用的变量的隐式或显式初始化语句。
	- 样句：`goto label; ...; label:statement;`
- return

#### 主动异常处理语句

- 抛出异常：`throw Error(..)`
- 处理异常：`try {statement;} catch(Error1 arr1){statement;} catch(Error2 arr2){statement;}`
- 异常数据
- 异常处理流程：
	- 在代码执行过程种，如果异常被抛出，首先搜索抛出该异常的函数，寻找匹配的 catch 子句。
	- 没找到匹配的 catch 子句，终止该函数，并在调用该函数的函数中继续寻找。
	- 以此类推，沿着程序的执行路径逐层回退，直到找到适当类型的 catch 子句为止。
	- 如果最终还是没能找到任何匹配的 catch 子句，程序转到名为 terminate 的标准库函数，程序非正常退出。
	- 特殊情况：一段程序没有 try 语句块且发生了异常，相当于肯定找不到任何匹配的 catch 子句，系统会调用 terminate 函数并终止当前程序的执行。
- 异常类
	- exception 库
		- 定义了最通用的异常类exception。
	- stdexcept 库
		- ![](C++.assets/image-20220904124456.png)
		- 定义了几种常用的异常类
	- new
		- 定义了bad_alloc异常类型
	- type_info
		- 定义了 bad_cast 异常类型
	- 只能以默认初始化的方式初始化 exception、bad_alloc 和 bad_cast 对象，不允许为这些对象提供初始值。
	- 其他的异常对象类型应该使用 string 对象或者 C 风格字符串初始化，但是不允许使用默认初始化的方式。
	- 可以通过通用的 what 函数，获取异常对象中初始化后的或内置的字符串信息。

```c++
//代码示例
	// while 循环语句
	while (condition){
		statement;
		
	}
	// do while 循环语句
	do{
		statement;
	} while (condition);
	// for 循环语句
	for (init; condition; expression){
		statement;
	}
	// 基于范围的for循环语句
	// seq 是一个序列对象
	// i 被用于迭代访问 seq 序列中的基础元素
	for (auto &declaration : expression){
	statement;
	}
	// if 条件语句
	if (condition){
		statement;
	}
	else if(condition){
		statement;
	}
	else {
		statement;
	}
	// switch 条件语句
	// 标签 ch 必须是整型常量表达式
	// 不主动断开 switch ，就会判断所有分支
	switch (ch) {
		case 'a':
			statement; 
			break;
		default:
			statement;
			break;
	}

```

### 函数

#### 函数定义

- 每个 C++程序都包含一个或多个函数（function），其中一个必须命名为 main。
- 函数声明（函数原型）
	- 函数的名字也必须在使用之前声明，并且如果一个函数永远也不会被我们用到，可以只有声明没有定义。
	- 函数的声明由：返回类型、函数名和一个括号包围的形参列表组成。
	- 声明的函数需要传入数组作为形参时，形参声明可以用对应指针类型，或数组类型。因为最终数组也会转换成指针。
- 一个函数的定义包含四部分：返回类型、函数名、一个括号包围的形参列表（允许为空）以及函数体（语句块）。
	- 函数返回类型
		- 无返回类型：`void` ，返回方式：`return;`
		- 函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针或引用。
			- 返回值定义：
				- 通过自定义类型别名 `arrT` ： `typedef int  arrT[10]` 或 `using arrT = int [10]` 
				- 直接定义一个指向数组或函数的指针： `int (*p)[10]= &arr;`
			- 函数定义
				- 直接定义：`int (*func(int i)) [10];`
					- `func(int i)`表示调用 func 函数时需要一个 int 类型的实参。
					- `(＊func(int i))`意味着我们可以对函数调用的结果执行解引用操作。
					- `(＊func(int i))[10]`表示解引用 func 的调用将得到一个大小是 10 的数组。
					- `int (＊func(int i))[10]` 表示数组中的元素是 int 类型。
				- 使用尾置返回类型：`auto func(paratype) -> paratype (*)[10];`
				- 使用 `decltype` 关键字声明返回类型：`decltype(para) *func(para)`
		- 函数返回值是对象副本、未命名的临时对象或引用别名。
		- 函数完成后，它所占用的存储空间也随之被释放掉，因此不要返回局部对象的引用或指针（如可以被自动转换的非同类型值，局部对象的引用，局部对象的指针）。
			- 特别的，C++11新标准规定，函数可以返回花括号包围的值的列表，作为要返回的类型初始化值。
				- 如果函数返回的是内置类型，则花括号包围的列表最多包含一个值，而且该值所占空间不应该大于目标类型的空间。
				- 如果函数返回的是类类型，由类本身定义初始值如何使用。最常见的为 `vector` 对象
		- 返回类型也可以使用返回类类型的函数和调用运算符。
		- 函数的返回类型决定函数调用是否是左值（返回引用类型为左值，其他类型为右值）。
		- main 函数，可以没有 return 语句直接结束。其默认返回值为 0。返回 0 表示执行成功，返回其他值表示执行失败。
			- cstdlib 头文件定义了两个预处理变量，可以使用这两个变量分别表示成功 `EXIT_SUCCESS` 与失败 `EXIT_FAILURE` 
	- 函数名
	- 函数参数
		- 实参
			- 送入实参的求值顺序并无明确规定。
			- 默认实参
				- 一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。
				- 在进行多次函数声明时，在给定的作用域中，一个形参只能被赋予一次默认实参。但是后续声明可以为之前那些没有默认值的形参继续添加默认实参。
				- 可以通过表达式作为默认实参，但是无法通过同名局部变量覆盖的方式，修改默认实参。
		- 形参
			- 形参列表可以为空，但是不能省略，隐式定义：`func(){}`，显示定义：`func(void){}`。
			- 形参列表中的形参通常用逗号隔开，其中每个形参都是含有一个声明符的声明，例：`func(int v1,int v2,...){}`。
			- 任意两个形参都不能同名，函数块中的局部变量也不能使用与函数形参一样的名字。
			- 数组作为函数传递参数时，实际上传递的是指向数组首元素的指针，也因此无法得到数组大小（管理数组的常用方法有：末尾添加标记、传递首元素和尾后元素的指针，传递大小形参）。
			- 可变数量形参实现
				- 标准库：`initializer_list`
					- 如果函数的实参数量未知但是全部实参的类型都相同，我们可以使用initializer_list类型的形参。
				- 省略符形参
					- 省略符形参是为了便于C++程序访问某些特殊的C代码而设置的，这些代码使用了名为varargs的C标准库功能。
					- 省略符形参应该仅仅用于C和C++通用的类型。
					- `int func(arr, ...){};`
					- 模板函数
		- 参数传递过程
			- 实参的类型必须与对应的形参类型相同或能转换。
			- 如果形参是引用类型，它将绑定到对应的实参上（引用传递）；否则，将实参的值拷贝后赋给形参（值传递，独立）。
			- 指针也是一个对象，作为形参时也是构建一个独立对象，但是需要注意的是，通过指针去访问的对象不变。在 C++语言中，建议使用引用类型的形参替代指针（避免了拷贝操作，也更方便）。
			- 当用实参初始化形参时会忽略掉顶层 const，因此当形参有顶层 const 时，传给它常量对象或者非常量对象都是可以的。P6.2.3
			- 函数不会改变的形参尽量使用常量引用。
				- 告诉函数的调用者，此函数不会修改传入的实参的值。
				- 普通的引用形参不能接受 const 对象、字面值或者需要类型转换的对象。
				- 数组的引用需要加括号：`func(int (&arr)[len]){}`

#### 函数调用

调用方式：函数或者指向函数的指针+调用运算符（一对圆括号）+括号内的实参列表 `function(arg1,arg2,...)`

- 首先用实参初始化函数对应的形参。
- 然后将控制权转移给被调用函数。
	- 主调函数的执行被暂时中断，被调函数开始执行。
- 当遇到一条 return 语句时函数结束执行过程。
	- 首先返回 return 语句中的值（如果有的话）
	- 然后将控制权从被调函数转移回主调函数。

#### 函数重载

如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为重载函数。当调用这些函数时，编译器会根据传递的实参类型推断想要的是哪个函数。

- 不允许两个函数除了返回类型外其他所有的要素都相同。
- 因为形参的名字仅仅起到帮助记忆的作用（有没有它并不影响形参列表的内容），以及类别名的存在，所以有时候两个形参列表看起来不一样，但实际上是相同的
- 一个拥有顶层 const 的形参无法和另一个没有顶层 const 的形参区分开来
- 如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的 const 是底层的。
- const 对象（或指向 const 的指针）只能传递给 const 形参。并且，因为非常量（或指向非常量对象的指针）可以转换成 const，因此也可以传递给 const 形参。但是当我们传递一个非常量对象或者指向非常量对象的指针时，编译器会优先选用非常量版本的函数。
- 重载对作用域的一般性质并没有什么改变：如果我们在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。在不同的作用域中无法重载函数名：

#### 内联函数

通过函数，可以统一相关表达式的操作行为，容易针对性修改表达式以及被重复利用。但是在大多数机器上，一次函数调用其实包含着一系列工作：调用前要先保存寄存器，并在返回时恢复；可能需要拷贝实参；程序转向一个新的位置继续执行。比求等价表达式的值要慢一些。

将函数指定为内联函数，通常就是将它在每个调用点上“内联地”展开。定义方式为在函数定义的时候添加关键词 `inline`

#### constexpr 函数

一种能用于常量表达式的函数, 其函数的返回类型及所有形参的类型都需要是字面值类型，而且函数体中必须有且只有一条 return 语句。

#### 调式程序

##### 预处理宏 `assert`

头文件： `cassert`

`assert(expr)`，如果表达式为假（即 0），`assert` 输出信息并终止程序的执行。如果表达式为真（即非 0），`assert` 什么也不做。常用于检查“不能发生”的条件。

##### 预处理变量 `NDEBUG`

## 程序编译

- 预处理器
	- `#include` 
		- 当预处理器看到`#include`标记时就会用指定的头文件的内容代替`#include`。
	- `#define`
		- 把一个名字设定为预处理变量。
		- 为了避免与程序中的其他实体发生名字冲突，一般把预处理变量的名字全部大写。
	- `#ifdef`/`#ifndef`->`#endif`
		- `#ifdef`和`#ifndef`检查某个指定的预处理变量是否已经定义
		- `#ifdef`当且仅当变量已定义时为真，`#ifndef`当且仅当变量未定义时为真。
		- 一旦检查结果为真，则执行后续操作直至遇到`#endif`指令

- 常见编译器支持的文件后缀有 .cc、.cxx、.cpp、.cp及 .C。
- 文件编译指令: GNU编译器：`g++ -o -Wall output ./prog1.cc`、微软编译器： `cl /W4 prog1.cpp
- 文件重定向
	- `program <infile >outfile`

### 分离式编译

分离式编译允许我们把程序分割到几个文件中去，每个文件独立编译。

## 标准库（STL）

标准库定义了另外一组具有更高级性质的类型，它们尚未直接实现到计算机硬件中。C++ 标准对库类型所提供的操作和性能上的需，因此对于一般应用场合来说有足够的效率。

- 包含库头文件
	- 包含来自标准库的头文件时，应该用尖括号`<>`）包围头文件名。
	- 对于不属于标准库的头文件，则用双引号（`" "`）包围。
	- 为了兼容C语言的标准库，如头文件形如`name.h`的库文件，C++将这些文件命名为`cname`。也就是去掉了`.h`后缀，而在文件名`name`之前添加了字母`c`，这里的`c`表示这是一个属于C语言标准库的头文件。
	- `cname`从命名规范上来讲更符合C++语言的要求，但是其实与包含`name.h`的内容相同。
	- 特别的，在名为`cname`的头文件中定义的名字从属于命名空间`std`，而定义在名为`.h`的头文件中的则不然。

- 命名空间
	- `namespace::name`为作用域操作符，应从操作符左侧名字所示的作用域中寻找右侧那个名字。
	- `using namespace: :name;` 
		- 一旦声明了上述语句，就可以直接访问命名空间中的名字。
		- 每个名字都需要独立的 `using` 声明。
		- 头文件不应包含 `using` 声明。

### iostream库

- istream
	- cin
	- 当遇到文件结束符（end-of-file），或遇到一个无效输入时，istream 对象的状态会变为无效。处于无效状态的istream 对象会使条件变为 False。

- ostream
	- cout
	- cerr
	- clog

```c++
//代码示例
#include <iostream>
int main ()
{
	std::cout<< "Enter two numbers : " << std::endl;
	int v1 = 0, v2= 0;
	std::cin >> v1 >> v2;
	std::cout << "The sum of " << vl << " and " << v2 << " is " << v1 + v2<< std::endl;
	return 0;
}

```

### string 库

string 类型是字符的序列，它的操作有`>>`、`<<`和`==`等，功能分别是读入字符串、写出字符串和比较字符串。

- 初始化方式![](C++.assets/image-20220814200619.png)![](C++.assets/image-20220814202453.png)
- 类操作![](C++.assets/image-20220814203226.png)
		- 在执行`>>`读取操作时，string对象会自动忽略开头的空白（即空格符、换行符、制表符等）并从第一个真正的字符开始读起，直到遇见下一处**空白**为止。之后返回运算符左侧的运算对象作为其结果。
			- 示例：读取未知数量的string对象![](C++.assets/image-20220814204157.png)
		- 执行`getline`函数可以读取一整行，直到遇到换行符为止（注意换行符也被读进来了，但是不被保存），这样能够保留输入时的空白符。之后返回流参数。
			- 示例：读取未知行数的string行![](C++.assets/image-20220814204623.png)
		- 执行`empty`函数，可以判断string对象是否为空，返回布尔值。
			- 示例：读取未知行数的string行，并且只输出非空行![](C++.assets/image-20220814204838.png)
		- 执行`size`函数，可以获取string对象中的字符个数，返回值为`string::size_type`类型值（一个**无符号类型**的值，能足够存放下任何string对象的大小。）。
			- 示例：读取未知行数的string行，并且只输出其中超过80字符的行![](C++.assets/image-20220814204952.png)
		- 执行`<=`、`>=`、`>`、`<`、`==`、`!=`比较运算，会逐一比较string对象中的字符，并且对大小写敏感。
			- 如果两个string对象的长度不同，而且较短string对象的每个字符都与较长string对象对应位置上的字符相同，就说较短string对象小于较长string对象。
			- 如果两个string对象在某些对应的位置上不一致，则string对象比较的结果其实是string对象中第一对相异字符比较的结果。
		- 执行`=`赋值操作，为副本替换操作
			- ![](C++.assets/image-20220814205951.png)
		- 执行`+`加法操作
			- 两个string对象相加得到一个新的string对象，其内容是把左侧的运算对象与右侧的运算对象串接而成。
			- 当把string对象和字符字面值及字符串字面值混在一条语句中使用时，可以自动转换成所需的string类型。但是必须确保每个加法运算符（+）的两侧的运算对象至少有一个是string。
				- ![](C++.assets/image-20220814210345.png)
- 一个string对象表示一个字符的序列，因此string对象可以作为范围for语句中的seq部分。
	- 使用范围for语句处理string字符串中的每个字符![](C++.assets/image-20220814212002.png)
	- 使用范围for语句改变string字符串中的字符![](C++.assets/image-20220814212035.png)
		- 想要改变string对象中字符的值，必须把循环变量定义成引用类型。
	- 使用下标处理指定位置字符，其返回指定位置字符的引用![](C++.assets/image-20220814214604.png)
		- string对象的下标从0计起，直至`s.size()`。
		- 下标（索引）值需要是`string::size_type`类型值，即无符号类型值，如果不是将自动转换为无符号类型的`string::size_type`类型值。
		- 只要对string对象使用了下标，都要确认在那个位置上确实有值。
	- 使用下标迭代处理string字符串的值![](C++.assets/image-20220814215114.png)
		- 逻辑与运算符：`&&`，只有当左侧运算对象为真时才会检查右侧运算对象的情况。
- 字符串风格
	- 字符串字面值是 C++ 由 C 继承来的 C 风格字符串。字符串的最后一个字符后面会默认追加一个空字符 `\0` ，共同构成一个字符数组。
	- String 类型是 C++ 风格的字符串类型，其重载了 C 风格字符串的一系列运算符，因此两者可以自动转换。
	- C 风格标准库函数 `cstring` 头文件。
		- 图片：P109 页
		- 传入此类函数的字符串数组（或字符串字面值）必须以空字符 `\0` 作为结束。
		- 直接使用不同的 C 风格字符串时，得到的是不同的数组指针，其无法直接使用内置的普通关系运算符和比较运算符进行运算。
		- 在进行以上函数时，需要严格确认结果数组存储大小足够大，不然会引发严重错误。因此使用 String 更高效和安全。
		- 为了兼容早期使用的 C 风格字符串， String 专门提供了一个 `c_str` 的成员函数，其返回值是一个 C 风格字符串，即当前对象对应的一个以空字符结束的字符数组。

### cctype 库

定义了一组标准库函数，处理string对象中的每一个字符、特定字符等操作。

- 库函数![](C++.assets/image-20220814210713.png)

### Vector 库

Vector 表示对象的集合，并且其中的所有对象都是相同类型。在集合中的每个对象都有一个与之对应的索引。

```c++
#include <vector>
using std::vector;
```

- vector 是一个类模板
    - 模板本身不是类或函数，类似于编译器生成类或函数的一份说明格式。给定模板参数（具体参数由模板决定），使得编译器创建对应类或函数的过程被称为实例化。
        ```c++
        vector<int> ivec;		//ivec 是保存 int 类型的对象集合
        vector<Sales_item> Sales_vec;	//Sales_vec 是 Sales_item 类型的对象集合
        vector<vector<string> > file;	//file 是 vector 类型的对象集合
        // 在 C11之前 vector<vector<string>> file; 要写成 vector<vector<string> > file;
        ```
    
- 定义和初始化 vector 对象的常用方法
	- ![](C++.assets/image-20220901150805.png)
    - vector 初始化时，其中使用对象类型必须相同。
        - 拷贝初始化，为使用`=`赋值，只能提供一个初始值
        - 直接初始化，为使用`()`赋值，可以提供参数，自定义初始化值
        - 列表初始化，为使用`{}`赋值，要注意`()`和`{}`的区别
        - 初始化类内初始值时不能使用直接初始化`()`
        - 当使用花括号`{}`初始化，但是其中提供的值并不能进行列表初始化时，会通过提供的值来构造 vector 对象。
        - 初始化使用值可以使用内置的数组格式，如 `vector<int> ivec(begin(arr), end(arr));`。
- vector 操作
    - ![](C++.assets/image-20220901150836.png)
    - 添加元素
        - `push_back` 可以将值添加到 vector 对象的尾端
        - 不可以使用下标添加元素
        - 不要在for循环里面执行改变当前 vector 大小的操作（比如增加元素）。
    - 遍历元素
        ```c++
        vector<int> v{1, 2, 3, 4, 5, 6, 7, 8, 9};
        for (auto &i : v)		//使用引用可以改变v中的值， 
        {
            i *= i;				//计算平方
        }
        for (auto i : v)		//普通
        {
            cout << i << " ";	
        }
        ```

### iterator 库

迭代器是一种类似于指针的对象类型（指针属于迭代器），他有指针类似的操作，除此之外还有自己独特的一些操作。

- 支持迭代器的容器，如 string 等类型，都会拥有名为 `begin` `cbegin` 和 `end` `cend` 的成员函数，其中 `begin` `cbegin` 返回指向第一个元素的迭代器， `end` `cend`  返回指向最后一个元素的下一个位置的迭代器（不存在的元素），也叫做**尾后迭代器。**
- 迭代器常用运算符
- ![](C++.assets/image-20220901151807.png)
	- 和指针类似，可以通过解引用运算符获取迭代器指向的元素值或对象，如 `(*it).empty()` 或 `it->empty()`。
	- 通过 `++` 和 `—` 运算符可以移动迭代器指向下一个元素或上一个元素。
		```c++
		string s("some string");
		for (auto it = s.begin(); it != s.end() && !isspace(*it); ++it)
		{
			*it = toupper(*it);		//将当前字符改成大写形式
		}
		```
- `string` 和 `vector`  提供的额外运算符
	- ![](C++.assets/image-20220901151938.png)
	- 可以通过运算符获得移动指定整数位置后的迭代器，如 `auto test = vi.begin() + vi.size() / 2`
	- 这里的比较和计算运算符，需要参与的两个迭代器必须合法且指向的是同一个容器的元素。
- 迭代器类型
    - `iterator` 能读能写
    - `const_iterator` 只能读
        - 对于常量对象（用 const 修饰的对象）需要使用 `const_iterator` 。
        
        ```c++
        vector<int>::iterator it1;	
        string::iterator ii2;
        
        vector<int>::const_iterator it3;
        string::const_iterator it4;
        ```
        - 任何一个改变当前 vector 大小的操作（比如增加元素），都会使得迭代器失效。

### 异常 库

exception 库

定义了最通用的异常类exception。

stdexcept 库

![](C++.assets/image-20220904124456.png)

定义了几种常用的异常类

new

定义了bad_alloc异常类型

type_info

定义了bad_cast异常类型

### initializer_list 库
