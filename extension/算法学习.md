---
title: ""
author: "石昌文"
tags: [""]
description: ""
categories: [""]
keywords:  [""]
type: ""
draft: true
layout: 
data: 2022-09-26 16:41:27
lastmod: 2022-09-26 18:38:56
---

# 算法性能分析

## 时间复杂度 O(f(n)) 分析

时间复杂度用来方便开发者估算出程序运行时间。

- `O(...)` 表示算法的最坏情况运行时间的上界（业界表示一般情况）。

## 空间复杂度分析

空间复杂度是一个程序在运行过程中占用内存空间大小的量度。

## 内存消耗分析

### 不同语言内存管理方式

- C/C++这种内存堆空间的申请和释放完全靠自己管理

内存布局（Code Segment、Data Segment、Block started by symbol、Heap、Stack）![](算法学习.assets/Pasted%20image%2020220926171052.png)

- Java 依赖JVM来做内存管理，不了解jvm内存管理的机制，很可能会因一些错误的代码写法而导致内存泄漏或内存溢出
- Python 内存管理是由私有堆空间管理的，所有的 python 对象和数据结构都存储在私有堆空间中。程序员没有访问堆的权限，只有解释器才能操作。


- 函数栈
	- 当调用函数时，一块连续内存 (堆栈帧）压入栈；函数返回时，堆栈帧弹出。
	- 堆栈帧包含如下数据:
		- 函数返回地址
		- 局部变量/CPU 寄存器数据备份
- 当全局/静态变量（如下代码中的 x 和 y 变量）未初始化的时候，它们记录在 BSS 段。
	- 系统载入可执行程序后，将 BSS 段的数据载入数据段 (Data Segment） ，并将内存初始化为 0，再调用程序入口（main 函数）。
	- 而对于已经初始化了的全局/静态变量而言，则一直存储于数据段 (Data Segment)。
- 内存对齐
	- 基础类型，如 float, double, int, char 等，它们的大小和内存占用是一致的。
	- 结构体的大小是其内部成员经过内存对齐后的大小
		- 内存对齐使数据读取更高效（内存如果bu'jin）

### 数据类型内存占用情况

![](算法学习.assets/Pasted%20image%2020220926171151.png)

1个字节占8个比特，那么4个字节就是32个比特，可存放数据的大小为2^32，也就是 4G 空间的大小，即：可以寻找 4G 空间大小的内存地址。

安装 64 位的操作系统的计算机内存都已经超过了 4G，也就是指针大小如果还是 4 个字节的话，就已经不能寻址全部的内存地址，所以 64 位编译器使用 8 个字节的指针才能寻找所有的内存地址。

## 常用算法分析

`O(1)` 常数阶 < `O(logn)` 对数阶 < `O(n)` 线性阶 < `O(n^2)` 平方阶 < ` O(n^3)` 立方阶 < `O(2^n)` 指数阶

![](算法学习.assets/image-20220926164737.png)
