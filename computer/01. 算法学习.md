---
title: ""
author: "石昌文"
tags: [""]
description: ""
categories: [""]
keywords:  [""]
type: ""
draft: true
layout: 
data: 2022-09-26 16:41:27
lastmod: 2022-09-26 19:00:43
---

# 算法性能分析

## 时间复杂度 O(f(n)) 分析

时间复杂度用来方便开发者估算出程序运行时间。

- `O(...)` 表示算法的最坏情况运行时间的上界（业界表示一般情况）。

## 空间复杂度分析

空间复杂度是一个程序在运行过程中占用内存空间大小的量度。

## 常用算法分析

`O(1)` 常数阶 < `O(logn)` 对数阶 < `O(n)` 线性阶 < `O(n^2)` 平方阶 < ` O(n^3)` 立方阶 < `O(2^n)` 指数阶

![](01.%20算法学习.assets/image-20220926164737.png)

# 计算机系统

## 不同语言内存管理方式

- C/C++这种内存堆空间的申请和释放完全靠自己管理

### 内存布局

（Code Segment、Data Segment、Block started by symbol、Heap、Stack）![](01.%20算法学习.assets/Pasted%20image%2020220926171052.png)

- Java 依赖JVM来做内存管理，不了解jvm内存管理的机制，很可能会因一些错误的代码写法而导致内存泄漏或内存溢出
- Python 内存管理是由私有堆空间管理的，所有的 python 对象和数据结构都存储在私有堆空间中。程序员没有访问堆的权限，只有解释器才能操作。


- 函数栈
	- 当调用函数时，一块连续内存 (堆栈帧）压入栈；函数返回时，堆栈帧弹出。
	- 堆栈帧包含如下数据:
		- 函数返回地址
		- 局部变量/CPU 寄存器数据备份
- 当全局/静态变量（如下代码中的 x 和 y 变量）未初始化的时候，它们记录在 BSS 段。
	- 系统载入可执行程序后，将 BSS 段的数据载入数据段 (Data Segment） ，并将内存初始化为 0，再调用程序入口（main 函数）。
	- 而对于已经初始化了的全局/静态变量而言，则一直存储于数据段 (Data Segment)。

### 内存对齐

- 基础类型，如 float, double, int, char 等，它们的大小和内存占用是一致的。
- 结构体的大小是其内部成员经过内存对齐后的大小
	- 内存对齐使数据读取更高效
		- 在硬件设计上，数据读取的处理器只能从地址为 k 的倍数的内存处开始读取数据。这种读取方式相当于将内存分为了多个"块“，假设内存可以从任意位置开始存放的话，数据很可能会被分散到多个“块”中，处理分散在多个块中的数据需要移除首尾不需要的字节，再进行合并，非常耗时。

内存对齐的规则

每个成员要进行对齐，并且整个结构体也需要进行对齐。

- 结构体起始地址为有效对齐值的整数倍
- 结构体总大小为有效对齐值的整数倍
- 结构体第一个成员偏移值为0，之后成员的偏移值为 min(有效对齐值, 自身大小) 的整数倍

### 数据类型内存占用情况

![](01.%20算法学习.assets/Pasted%20image%2020220926171151.png)

1个字节占8个比特，那么4个字节就是32个比特，可存放数据的大小为2^32，也就是 4G 空间的大小，即：可以寻找 4G 空间大小的内存地址。

安装 64 位的操作系统的计算机内存都已经超过了 4G，也就是指针大小如果还是 4 个字节的话，就已经不能寻址全部的内存地址，所以 64 位编译器使用 8 个字节的指针才能寻找所有的内存地址。
