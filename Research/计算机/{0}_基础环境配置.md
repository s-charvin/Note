---
title: ""
author: "石昌文"
tags: [""]
description: ""
categories: [""]
keywords:  [""]
type: ""
draft: true
layout: 
data: 2022-06-09 13:51:53
lastmod: 2023-04-15 23:48:31
date: 2022-06-09 13:51:53
---

## 编译环境配置

C++

[Install gcc compiler on Windows with MSYS2 for C/C++ | DevDungeon](https://www.devdungeon.com/content/install-gcc-compiler-windows-msys2-cc)

[MSYS2使用教程（整理）——win10系统64位安装msys2最新版（msys2-x86_64-20190524.exe） - wdliming - 博客园 (cnblogs.com)](https://www.cnblogs.com/CodeWorkerLiMing/p/12274583.html)


[MSYS2](https://www.msys2.org/)

## 项目环境配置

### KEIL5

> 1）安装路径名中不能带中文，必须是英文路径名。
> 2）安装目录不能与51单片机的KEIL或者KEIL4冲突，三者目录必须分开。
> 3）KEIL5的安装比KEIL4多一个步骤，必须添加MCU库，不然没法使用。

1. [下载安装连接](https://www.keil.com/download/product/)
	![](00. 基础环境配置.assets/image-20220609135442.png)![](00. 基础环境配置.assets/image-20220609135602.png)![](00. 基础环境配置.assets/image-20220609135645.png)

2. [安装STM32芯片包](http://www.keil.com/dd2/pack/)
	![](00. 基础环境配置.assets/image-20220609135835.png)![](00. 基础环境配置.assets/image-20220609140209.png)

#### 项目环境配置

#### 仿真器配置

配置Debug设备
配置Utilities
配置Debug Settings
选择目标板
下载程序

### 深度学习环境配置

#### 安装 Python 编译环境

#### 配置 conda

#### 配置第三方包

`conda create -n SCW3.9 python=3.9`

`pip install torch==1.8.1+cu101 torchvision==0.9.1+cu101 torchaudio==0.8.1 -f https://download.pytorch.org/whl/torch_stable.html`

`pip install audioread keras pandas redis redis opencv-python matplotlib scikit-learn  selenium==3.141.0 tqdm nvitop nlpaug librosa==0.9.2 decord g-mlp-pytorch opensmile==2.4.1 sklearn torchinfo pretrainedmodels transformers tensorboard area_attention pytorchvideo fairscale apex ava`

`conda install ffmpeg==4.0`

`pip install detectron2 -f https://dl.fbaipublicfiles.com/detectron2/wheels/cu101/torch1.8/index.html`

## C++ 环境配置(Windows+VSCode)

### 0. 先决条件

1. 安装 [Visual Studio Code](https://code.visualstudio.com/download)。
2. 安装 VS Code 的 C/C++ 扩展
![]({0}_基础环境配置.assets/image-20230415193924.png)

### 1. 根据官网教程安装 [MSYS64](https://www.msys2.org/) 

- 下载[安装包](https://github.com/msys2/msys2-installer/releases))
- 运行安装程序, 需要注意的是 MSYS2 需要 64 位 Windows 8.1 或更高版本系统。
- 输入所需存放的安装文件夹
![]({0}_基础环境配置.assets/image-20230415194329.png)

- 安装就绪后, 单机完成即可, 默认情况下会打开 linux 类型的终端窗口, 方便通过 `pacman` 指令安装所需要的工具. 未打开窗口, 可通过在开始菜单中查询以下程序打开.

![]({0}_基础环境配置.assets/image-20230415194651.png)

- 更改软件管理工具 pacman 的下载镜像

```bash
sed -i "s#https\?://mirror.msys2.org/#https://mirrors.tuna.tsinghua.edu.cn/msys2/#g" /etc/pacman.d/mirrorlist*
```

### 2. 通过安装 MSYS2 环境必备工具

- 从服务器下载新的软件包数据库

```bash
pacman -Sy
```

- 升级系统及所有已经安装的软件

```bash
pacman -Syu
```

- 安装 Mingw-w64 中必备的工具链
```bash
# 安装  ucrt 版本的 GCC 工具包(包含, git, gcc, gdb, make等工具)
pacman -S mingw-w64-ucrt-x86_64-toolchain
```
- 将 Mingw-w64 文件夹的路径添加到 Windows 环境变量

```bash
SETX /M "Path" "%Path%;C:\msys64\ucrt64\bin"
```

- 检查 MinGW 安装状态

```bash
gcc --version
g++ --version
gdb --version
```

>[!cite]
> [使用msys2打造优雅的开发环境 - 飞鸿影 - 博客园 (cnblogs.com)](https://www.cnblogs.com/52fhy/p/15158765.html)

### 3. 自定义工作区配置

- 新建或打开一个工作区文件夹, 并接受工作区信任的弹出消息框.
```bash
mkdir projects
cd projects
mkdir helloworld
cd helloworld
code .
```
- 添加, 保存, 和打开一个源代码文件, 使其在屏幕展示, 成为活动文件

```c++
// 示例: `helloworld.cpp`
#include <iostream>
#include <vector>
#include <string>

using namespace std;

int main()
{
    vector<string> msg {"Hello", "C++", "World", "from", "VS Code", "and the C++ extension!"};

    for (const string& word : msg)
    {
        cout << word << " ";
    }
    cout << endl;
}

```
- 单击菜单栏的 `终端` , 通过 `配置默认生成任务` 自动生成一个 `tasks.json` 文件, 编译器选择安装好的 msys64 的 g++ 程序

![]({0}_基础环境配置.assets/image-20230415222726.png)


- 单机活动文件右上角的齿轮按钮, 自动生成一个 `launch.json` 文件, 调试配置选择安装好的 msys64 的 g++ 程序

![]({0}_基础环境配置.assets/image-20230415222017.png)

- 使用快捷键 `Ctrl+Shift+P` 打开 VSCode 的命令面板, 运行命令 `C/C++: Edit Configurations (JSON)` 自动生成一个 `c_cpp_properties.json` 文件

![]({0}_基础环境配置.assets/image-20230415223049.png)

#### 通过 `launch.json` 配置 C/C++ 调试行为

```json
{
    "configurations": [
        {
            "name": "C/C++: g++.exe 生成和调试活动文件",
			// 额外的调试选项
			// "processId": , // 通过指定 processId 选项，调试器可以附加到一个正在运行的进程进行调试。
			"request": "launch", // `launch`: 启动一个新的调试会话，通常是通过运行程序来启动。`attach`: 附加到一个正在运行的进程进行调试。`disconnect`: 断开调试器和被调试进程之间的连接。`terminate`: 终止调试会话。`setBreakpoints`: 设置断点。`configurationDone`: 告诉调试器已完成配置。
			"type": "cppdbg", // cppvsdbg(Visual Studio 调试器) 或 cppdbg ( GDB或LLDB调试器 )
			// "sourceFileMap": ,
			
			// VSCode 行为控制
            "program": "${fileDirname}\\build\\${fileBasenameNoExtension}.exe", // 指定需要调试的程序的可执行文件路径
            // "symbolSearchPath": "C:\\Symbols;..." , // 可选参数, 指定 windows 调试器要搜索的符号文件(.pdb)所在的路径, 多个路径用分号隔开.
            // "requireExactSource": false, // 可选参数, 要求当前源代码与 pdb 匹配
            // "additionalSOLibSearchPath": "/Users/user/dir1;..." // 可选参数, 指定需要搜索的动态链接库文件(.so)所在的路径, 多个路径用分号隔开.
            // "avoidWindowsConsoleRedirection": false, // 默认会将控制台重定向命令添加到调试程序的参数中, 以使 Windows 上的 gdb 支持 VSCode 的集成终端, 将控制台输入和输出显示在集成终端中. 一般不需要更改设置.
            // "logging": { // 用于确定应将哪些类型的消息记录到调试控制台。
			    // "exceptions": true , // 用于确定是否应将异常消息记录到调试控制台。
			    // "moduleLoad": true, // 用于确定是否应将模块加载事件记录到调试控制台。
			    // "programOutput": true, // 用于确定是否应将程序输出记录到调试控制台。
			    // "engineLogging": false // 用于确定是否应将诊断引擎日志记录到调试控制台。
			    // "trace": false, // 用于确定是否应将诊断适配器命令跟踪记录到调试控制台。
			    // "traceResponse": false, // 用于确定是否应将诊断适配器命令和响应跟踪记录到调试控制台。
			// }
			// "visualizerFile": "*.natvis", // 指定调试时要使用的 `.natvis` 文件, 控制可视化类对象的定义视图, 一般不用设置.
			// "showDisplayString": , // 当 `visualizerFile` 参数指定后, 是否启用字符串显示, 启用会导致调试性能降低.
           "externalConsole": false, // 控制是否打开外部终端来启动调试, macOS 中似乎对集成终端有限制, 需要注意.
           
			// 程序运行设置
            "args": [], // 设置启动调试程序时, 要传递给程序的命令行参数, 其中转义字符需要双重转义.
            "cwd": "${fileDirname}", // 设置调试器启动的应用程序的工作目录, "${workspaceFolder}": 项目地址, "${fileDirname}": 文件地址
            "environment": [], // 要临时添加到程序环境中的环境变量.
           
            // 调试设置
            "MIMode": "gdb", // 指定要使用的调试器类型, `gdb`或`lldb`.
            "miDebuggerPath": "C:\\msys64\\mingw64\\bin\\gdb.exe", // 调试器的可执行文件路径
            // "miDebuggerArgs": [], // 控制调试器在启动时所使用的附加参数
			"stopAtEntry": false, // 控制调试器是否在程序入口处停止
			// "stopAtConnect": false, 控制调试器是否应在连接到目标程序后停止
            "setupCommands": [ // 控制调试器启动后, 连接到程序之前的调试环境命令
                {
                    "description": "为 gdb 启用整齐打印",
                    "text": "-enable-pretty-printing",
                    "ignoreFailures": true
                },
                {
                    "description": "将反汇编风格设置为 Intel",
                    "text": "-gdb-set disassembly-flavor intel",
                    "ignoreFailures": true
                }
            ],
            // "customLaunchSetupCommands":[], // 用于在使用自定义调试器时, 连接到程序之前的调试环境命令
            // "launchCompleteCommand": [], // 设置在调试器启动和初始化完成后要执行的命令
            // "symbolLoadInfo": {
	            // "loadAll": true, // 如果为真，将加载所有库的符号，否则将不加载任何 solib 符号。
	            // "exceptionList": "foo.so;bar.so" // 由分号分隔的文件名列表, 如果 LoadAll 为真，则不加载与列表中任何名称匹配的库的符号。否则只为匹配的库加载符号。
			// },


			// 设置调试系统上的转储文件(dump, 进程快照)
			// "dumpPath": , // 转储文件路径
			// "coreDumpPath": , // 核心转储文件
			
			// 使用本地或远程的调试服务
			// "miDebuggerServerAddress": "localhost:1234", // 要连接到以进行远程调试的调试器服务器的网络地址
			// "debugServerPath": , // 要启动的调试服务器的完整路径
			// "debugServerArgs": , // 调试器服务器的参数
			// "serverStarted": , // 要在调试服务器输出中查找的服务器启动模式。支持正则表达式
			// "filterStdout": true, // 如果设置为 true，则stdout在流中搜索服务器启动模式并将 stdout 记录到调试输出。
			// "filterStderr": true, // 如果设置为 true，则stderr在流中搜索服务器启动模式并记录 stderr 以调试输出。
			// "serverLaunchTimeout": 10000, // 调试器等待 debugServer 启动的时间（以毫秒为单位）。
			// "pipeTransport": , // 有关附加到远程进程的信息，例如调试 Docker 容器中的进程
			// "hardwareBreakpoints": , // 如果提供，这将显式控制远程目标的硬件断点行为。
			
            "preLaunchTask": "C/C++: g++.exe 生成活动文件"
        }
    ],
    "version": "2.0.0"
}
```

#### 通过 `tasks.json` 配置编译生成行为

```json
{

    "version": "2.0.0",

    "tasks": [

        {

            "type": "cppbuild",

            "label": "C/C++: g++.exe 生成活动文件",

            "command": "C:\\msys64\\mingw64\\bin\\g++.exe",

            "args": [

                "-fdiagnostics-color=always",

                "-g",

                "${file}",

                "-o",

                "${fileDirname}\\${fileBasenameNoExtension}.exe",

                "-static-libgcc",

                "-std=c++23"

            ],

            "options": {

                "cwd": "${fileDirname}"

            },

            "problemMatcher": [

                "$gcc"

            ],

            "group": {

                "kind": "build",

                "isDefault": true

            },

            "detail": "编译器: C:\\msys64\\mingw64\\bin\\g++.exe"

        },

        {

            "type": "cppbuild",

            "label": "C/C++: cpp.exe 生成活动文件",

            "command": "C:\\msys64\\mingw64\\bin\\cpp.exe",

            "args": [

                "-fdiagnostics-color=always",

                "-g",

                "${file}",

                "-o",

                "${fileDirname}\\${fileBasenameNoExtension}.exe"

            ],

            "options": {

                "cwd": "${fileDirname}"

            },

            "problemMatcher": [

                "$gcc"

            ],

            "group": "build",

            "detail": "调试器生成的任务。"

        }

    ]

}
```

#### 通过 `c_cpp_properties.json` 配置当前项目环境 

```json
{

    "configurations": [

        {

            "name": "Win32",

            "includePath": [

                "${workspaceFolder}/**"

            ],

            "defines": [

                "_DEBUG",

                "UNICODE",

                "_UNICODE"

            ],

            "cStandard": "c23",

            "cppStandard": "c++23",

            "compilerPath": "C:\\msys64\\mingw64\\bin\\g++.exe",

            "windowsSdkVersion": "10.0.19041.0",

            "intelliSenseMode": "gcc-x64"

        }

    ],

    "version": 4

}


```
