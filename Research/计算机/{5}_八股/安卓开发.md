---
title: 安卓开发面试笔记
description: ""
author: ""
tags: 
categories: ""
keywords:
  - ""
draft: true
layout: ""
date: 2025-04-06 10:32:41
lastmod: 2025-04-06 17:42:45
---

# 安卓开发面试笔记

学习计划:
1.计算机、通信、电子信息、通信工程、软件工程等相关专业;
2.熟悉C/C++/swift等语言, 有Android/linux/ios平台相关产品开发经验优先考虑;
3.熟悉数据结构和算法, 了解操作系统原理;

## 程序项目设计相关

### 软件架构

进一步学习了项目架构设计，从 MVC→MVP→MVVM→VIPER. 并实现了一个纯 swift 实现的 demo

- MVC(单向调用: Model->View->Controller->Model): 实际使用时, Activity 或 Fragment 同时作为 View 和 Controller, 承担了过多的职责，导致代码难以维护和测试或是产生逻辑耦合。
    - Model「模型」→ Java/Kotlin 数据类 + Repository. 负责数据处理（数据库、网络请求）, 回传数据给 View 来更新视图 UI 展示.
    - View「视图」 → XML布局 + 自定义 Activity/Fragment. 负责界面布局和渲染，同时将用户交互事件传递给 Controller
    - Controller「控制器」 → Activity/Fragment. 负责接收用户交互事件, 处理业务逻辑, 通知 Model 处理相应数据逻辑.
- MVP(双向调用: Model<->View<->Presenter): 实际使用时, Presenter 需要持有 View 的引用, 这样会导致 Presenter 和 View 之间的强耦合关系. 同时业务逻辑与 UI 逻辑混杂. 数据共享需要额外组件(如 EventBus)来实现.
    - Model「模型」→ Java/Kotlin 数据类 + Repository. 负责数据处理（数据库、网络请求）和回传数据.
    - View「视图」 → XML布局 + 自定义 Activity/Fragment. 负责界面布局和渲染，同时将用户交互事件传递给 Presenter.
    - Presenter「呈现器」 → 独立的 Java/Kotlin类. 负责接收用户交互事件, 处理业务逻辑, 通知 Model 处理相应数据逻辑, 同时处理 View 的 UI 逻辑.
- MVVM(单向绑定: View->ViewModel->Model + 单向数据流: Model->ViewModel->View):
    - Model「模型层」→ Java/Kotlin 数据类 + Repository. 负责数据处理（数据库、网络请求）和回传数据.
    - ViewModel「视图模型」→ 独立的 Java/Kotlin类. 负责接收用户交互事件, 处理业务逻辑, 通知 Model 处理相应数据逻辑, 同时将数据回传给 View.
    - View「视图层」 → Activity/Fragment + XML 布局. 负责界面布局和渲染, 基于数据驱动的 UI 逻辑, 同时将用户交互事件传递给 ViewModel。

### 设计模式和原则

#### 设计原则（开闭，里氏替换，依赖倒置，单一职责，接口隔离，迪米特，合成复用）

**开闭原则：** 当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。
- **实现方法:** 通过“抽象约束、封装变化” 来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。
- **作用:** 开闭原则是面向对象程序设计的终极目标，使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。
    1. 对软件测试的影响：软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。
    2. 可以提高代码的可复用性：粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。
    3. 可以提高软件的可维护性：遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。

**里氏替换原则:** 主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。

- **实现方法：** 子类可以扩展父类的功能，但不能改变父类原有的功能
    - 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法
    - 子类中可以增加自己特有的方法
    - 当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松
    - 当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的的输出/返回值）要比父类的方法更严格或相等
- **作用:**
    1. 里氏替换原则是实现开闭原则的重要方式之一。
    2. 它克服了继承中重写父类造成的可复用性变差的缺点。
    3. 它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。
    4. 加强程序的健壮性，同时变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险。

**依赖倒置原则:** 高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象. 由于在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。这里的抽象指的是接口或者抽象类，而细节是指具体的实现类。
- **实现方法:** 依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性
    1. 每个类尽量提供接口或抽象类，或者两者都具备。
    2. 变量的声明类型尽量是接口或者是抽象类。
    3. 任何类都不应该从具体类派生。
    4. 使用继承时尽量遵循里氏替换原则。
- **作用:**
    - 依赖倒置原则可以降低类间的耦合性。
    - 依赖倒置原则可以提高系统的稳定性。
    - 依赖倒置原则可以减少并行开发引起的风险。
    - 依赖倒置原则可以提高代码的可读性和可维护性。
    
- **单一职责原则:** 规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分. 该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责, 一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。
    - **作用: 控制类的粒度大小、将对象解耦、提高其内聚性。**
        - 降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。
        - 提高类的可读性。复杂性降低，自然其可读性会提高。
        - 提高系统的可维护性。可读性提高，那自然更容易维护了。
        - 变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。
    
**接口隔离原则:** 尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。

- **实现方法:** 
    - 接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。
    - 为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。
    - 了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。
    - 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。
- **作用:**
    1. 将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。
    2. 接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。
    3. 如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。
    4. 使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。
    5. 能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。
    
**迪米特法则:** 如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。

- **实现方法:** 
    1. 在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。
    2. 在类的结构设计上，尽量降低类成员的访问权限。
    3. 在类的设计上，优先考虑将一个类设置成不变类。
    4. 在对其他类的引用上，将引用其他对象的次数降到最低。
    5. 不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。
    6. 谨慎使用序列化（Serializable）功能。
- **作用: 限制软件实体之间通信的宽度和深度**
    1. 降低了类之间的耦合度，提高了模块的相对独立性。
    2. 由于亲合度降低，从而提高了类的可复用率和系统的扩展性。
    
- **合成复用原则:** 要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。

通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点。
1. 继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。
2. 子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。
3. 它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。

- **作用:** 采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点。
    1. 它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。
    2. 新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。
    3. 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。
    - **实现方法：**  通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。

#### 设计模式类型（创建型模式，结构型模式，行为型模式）

1. 创建型模式：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF 中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。
2. 结构型模式：用于描述如何将类或对象按某种布局组成更大的结构，GoF 中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。
3. 行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。GoF 中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。
    

#### 设计模式作用范围（**类模式，对象模式**）

1. 类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。GoF中的工厂方法、（类）适配器、模板方法、解释器属于该模式。
2. 对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。GoF 中除了以上 4 种，其他的都是对象模式。

#### 23种设计模式 (单例模式, 工厂方法模式, 抽象工厂模式, 建造者模式, 原型模式, 单例模式, 适配器模式, 装饰者模式, 代理模式, 外观模式, 桥接模式, 组合模式, 享元模式, 策略模式, 模板方法模式, 观察者模式, 迭代器模式, 责任链模式, 命令模式, 备忘录模式, 状态模式, 访问者模式, 中介者模式, 解释器模式)

##### 单例（Singleton）模式

某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。例如日志记录器、数据库连接池等。

1. **懒汉单例模式（Lazy Initialization）**

懒汉模式是指在首次使用时才创建单例实例。以下是懒汉模式的实现原理、C++代码以及优缺点：

**原理：** 在懒汉模式中，单例对象在第一次被访问时才会被创建。在多线程环境下，需要考虑线程安全性，以防止多个线程同时创建对象。

**特点：**
- 懒加载：只有在需要时才创建实例，节省内存。
- 简单实现：实现相对简单，适用于大多数情况。
- 线程不安全：在多线程环境下，可能会导致多个线程同时创建实例。需要额外的线程安全措施。
- 性能问题：每次获取实例时都需要检查是否已经创建，可能会导致性能下降。

```cpp
class Singleton {
private:
static Singleton* instance;
Singleton() {}

public:
static Singleton* getInstance() {
if (instance == nullptr) {
instance = new Singleton();
}
return instance;
}
};

Singleton* Singleton::instance = nullptr;

```

2. **饿汉单例模式（Eager Initialization）**

饿汉模式是指在类加载时就创建单例实例。以下是饿汉模式的实现原理、C++代码以及优缺点：

**原理：** 在饿汉模式中，单例对象在类加载时就会创建，因此保证了线程安全。

**特点：**

- 线程安全：由于实例在类加载时就创建，因此不存在多线程并发问题。
- 简单高效：实现简单，不需要额外的线程安全措施。
- 预先分配内存：如果单例对象较大，可能会浪费内存。
- 不支持延迟加载：无法实现懒加载，即使不需要也会创建实例。

```cpp
class Singleton {
private:
static Singleton* instance;
Singleton() {}

public:
static Singleton* getInstance() {
return instance;
}
};

Singleton* Singleton::instance = new Singleton();

```

3. **双重检查锁单例模式（Double-Checked Locking）**

双重检查锁模式是一种既实现懒加载又保证线程安全的单例模式。以下是双重检查锁模式的实现原理、C++代码以及优缺点：

**原理：** 双重检查锁模式使用双重检查来确保只在第一次访问时创建实例，并且在多线程环境下保持线程安全。

**特点：**

- 懒加载：只有在需要时才创建实例，节省内存。
- 线程安全：使用双重检查锁机制保证了多线程环境下的线程安全。
- 实现复杂：相对于懒汉和饿汉模式，实现较为复杂，需要使用互斥锁。
- C++11及以上：在C++11及以上版本中，可以使用更简洁的线程安全单例模式实现。

```cpp
#include <mutex>

class Singleton {
private:
static Singleton* instance;
static std::mutex mtx;
Singleton() {}

public:
static Singleton* getInstance() {
if (instance == nullptr) {
std::unique_lock<std::mutex> lock(mtx);
if (instance == nullptr) {
instance = new Singleton();
}
}
return instance;
}
};

Singleton* Singleton::instance = nullptr;
std::mutex Singleton::mtx;

```

**4. 静态内部类模式（Static Inner Class）**

静态内部类模式是一种结合了懒加载和线程安全的单例模式。以下是静态内部类模式的实现原理、C++代码以及优缺点：

**原理：** 在静态内部类模式中，单例对象的创建被放置在静态内部类中，保证了懒加载和线程安全。

**特点：**

- 懒加载：只有在需要时才创建实例，节省内存。
- 线程安全：静态内部类的初始化在第一次使用时发生，保证了线程安全。
- 简单高效：实现简单，不需要额外的线程安全措施。
- C++11及以上：需要C++11及以上的标准支持静态局部变量。
- 不支持销毁：无法显式销毁单例对象，只能在程序结束时自动销毁。

```cpp
class Singleton {
private:
Singleton() {}

public:
static Singleton& getInstance() {
static Singleton instance;
return instance;
}
};

```

##### 原型（Prototype）模式

将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。例如，复杂的对象初始化或者获取数据的操作开销较大。

通过复制一个已经存在的对象来创建新的对象，而不是通过实例化类来创建新的对象。原型模式在对象的创建过程中避免了类的直接实例化，通过克隆现有对象来创建新对象，从而降低了对象创建的开销。

**实现原理：**

1. 创建一个原型接口（Prototype），通常包含一个克隆方法（Clone），该方法用于复制对象。
2. 创建一个具体原型类（ConcretePrototype），实现原型接口并实现克隆方法，该类的实例可以被克隆。
3. 在客户端代码中，通过复制一个现有的具体原型对象来创建新对象，而不是使用`new`操作符实例化一个新对象。

**特点：**

1. 降低了对象创建的开销：通过克隆而不是实例化，避免了耗时的对象初始化过程，特别是在对象的创建成本较高时，可以提高性能。
2. 简化对象创建：客户端代码不需要关心对象的具体实现细节，只需要克隆一个现有的对象即可。
3. 支持动态添加和删除原型：可以在运行时动态地添加或删除具体原型类，扩展性好。
4. 需要为每个具体原型类实现克隆方法：如果有多个具体原型类，需要为每个类实现克隆方法，可能会增加代码量。
5. 需要注意深拷贝与浅拷贝：克隆方法的实现需要注意对象的深拷贝和浅拷贝，以确保复制的对象是独立的。
6. 需要动态类型识别：在C++中，需要使用`dynamic_cast`来进行类型识别，以确保正确的克隆。

```cpp
#include <iostream>
#include <string>

// 原型接口
class Prototype {
public:
virtual Prototype* Clone() const = 0;
virtual void ShowInfo() const = 0;
};

// 具体原型类
class ConcretePrototype : public Prototype {
private:
std::string data_;

public:
ConcretePrototype(const std::string& data) : data_(data) {}

Prototype* Clone() const override {
return new ConcretePrototype(data_);
}

void ShowInfo() const override {
std::cout << "Data: " << data_ << std::endl;
}
};

int main() {
ConcretePrototype* prototype = new ConcretePrototype("Original Data");
prototype->ShowInfo();

// 使用原型模式复制对象
ConcretePrototype* clonedPrototype = dynamic_cast<ConcretePrototype*>(prototype->Clone());
clonedPrototype->ShowInfo();

delete prototype;
delete clonedPrototype;

return 0;
}

```

##### 工厂方法（Factory Method）模式

定义一个用于创建产品的接口，由子类决定生产什么产品。具体来说就是将具体对象的创建延迟到子类中。这种模式有助于将对象的创建与其使用分离，提高了代码的可扩展性和可维护性。例如，不同数据库的数据访问对象根据配置文件来创建。

**实现原理：**

工厂方法模式的核心思想是将对象的创建委托给一个工厂接口，由具体的子类工厂来实现。这样，客户端代码只需要与工厂接口打交道，而不需要直接与具体对象的创建过程有关。

1. 定义一个工厂接口（抽象工厂），该接口声明了一个用于创建对象的抽象方法。
2. 创建具体的工厂类，实现工厂接口，并在工厂类中实现具体对象的创建逻辑。
3. 客户端代码通过工厂接口来请求对象的创建，而不需要直接实例化具体的对象。

**特点：**

1. 松耦合：工厂方法将对象的创建过程与客户端代码解耦，使得客户端不需要了解具体对象的创建细节。
2. 可扩展性：可以轻松地添加新的具体产品类和对应的工厂类，而不需要修改现有的代码。
3. 复用性：已有的工厂类可以被多个客户端使用，提高了代码的复用性。
4. 类的数量增加：每个具体产品类都需要一个对应的具体工厂类，可能导致类的数量增加。
5. 复杂性增加：如果产品族的结构复杂，可能需要引入抽象工厂模式，增加了系统的复杂性。
6. 不适合简单情况：对于简单的对象创建需求，引入工厂方法可能会显得繁琐。

**C++ 实现代码示例：**

假设我们有两种形状：圆形和矩形，通过工厂方法来创建这些形状对象。

```cpp
#include <iostream>

// 抽象产品类
class Shape {
public:
virtual void draw() = 0;
};

// 具体产品类：圆形
class Circle : public Shape {
public:
void draw() override {
std::cout << "Drawing a Circle" << std::endl;
}
};

// 具体产品类：矩形
class Rectangle : public Shape {
public:
void draw() override {
std::cout << "Drawing a Rectangle" << std::endl;
}
};

// 抽象工厂类
class ShapeFactory {
public:
virtual Shape* createShape() = 0;
};

// 具体工厂类：圆形工厂
class CircleFactory : public ShapeFactory {
public:
Shape* createShape() override {
return new Circle();
}
};

// 具体工厂类：矩形工厂
class RectangleFactory : public ShapeFactory {
public:
Shape* createShape() override {
return new Rectangle();
}
};

int main() {
// 使用工厂方法创建对象
ShapeFactory* circleFactory = new CircleFactory();
ShapeFactory* rectangleFactory = new RectangleFactory();

Shape* circle = circleFactory->createShape();
Shape* rectangle = rectangleFactory->createShape();

// 调用对象的方法
circle->draw();
rectangle->draw();

delete circle;
delete rectangle;
delete circleFactory;
delete rectangleFactory;

return 0;
}

```

上述示例中，我们定义了抽象的`Shape`类和具体的`Circle`和`Rectangle`子类，然后创建了抽象工厂类`ShapeFactory`以及具体的工厂类`CircleFactory`和`RectangleFactory`。客户端通过工厂方法来创建不同的形状对象，实现了对象的创建与使用的分离。

##### 抽象工厂（AbstractFactory）模式

提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。例如，创建不同操作系统下的界面组件。

抽象工厂（Abstract Factory）模式是一种创建型设计模式，用于创建一组相关或相互依赖的对象，而无需指定其具体类。它提供了一种将对象创建与其使用分离的方式，从而使系统更加灵活、可扩展和可维护。

**实现原理：**

抽象工厂模式包含以下主要组成部分：

1. **抽象工厂接口（Abstract Factory）**：定义了一组创建相关对象的抽象方法，通常每个方法对应一类对象。
2. **具体工厂类（Concrete Factory）**：实现了抽象工厂接口，负责创建具体产品对象。每个具体工厂类通常与一组具体产品类相关联。
3. **抽象产品接口（Abstract Product）**：定义了一组产品对象的抽象方法，通常每个方法对应产品的一种属性或功能。
4. **具体产品类（Concrete Product）**：实现了抽象产品接口，具体产品类代表了实际的产品对象，每个具体工厂类通常对应一组具体产品类。

抽象工厂模式的客户端代码通过与抽象工厂和抽象产品接口交互，而不直接与具体工厂和具体产品类交互，从而达到了解耦的目的。客户端可以通过切换不同的具体工厂来创建不同种类的产品，而不需要修改现有的代码。

**特点：**

1. 解耦性：客户端与具体工厂和产品类之间的耦合度降低，可以轻松切换不同的工厂，以创建不同种类的产品。
2. 易于扩展：增加新的具体工厂和产品类相对容易，不需要修改现有的代码，符合开放封闭原则。
3. 保持一致性：抽象工厂模式确保所创建的产品之间的一致性，因为它们都是由同一个工厂创建的。
4. 复杂性：抽象工厂模式引入了多个抽象类和接口，增加了系统的复杂性，不适合简单的应用场景。
5. 可扩展性受限：如果需要添加新的产品类别，需要修改抽象工厂接口和所有的具体工厂类，可能会影响现有代码。

```cpp
#include <iostream>

// 抽象产品A接口
class AbstractProductA {
public:
virtual void operationA() = 0;
};

// 具体产品A1
class ConcreteProductA1 : public AbstractProductA {
public:
void operationA() override {
std::cout << "ConcreteProductA1 operationA" << std::endl;
}
};

// 具体产品A2
class ConcreteProductA2 : public AbstractProductA {
public:
void operationA() override {
std::cout << "ConcreteProductA2 operationA" << std::endl;
}
};

// 抽象产品B接口
class AbstractProductB {
public:
virtual void operationB() = 0;
};

// 具体产品B1
class ConcreteProductB1 : public AbstractProductB {
public:
void operationB() override {
std::cout << "ConcreteProductB1 operationB" << std::endl;
}
};

// 具体产品B2
class ConcreteProductB2 : public AbstractProductB {
public:
void operationB() override {
std::cout << "ConcreteProductB2 operationB" << std::endl;
}
};

// 抽象工厂接口
class AbstractFactory {
public:
virtual AbstractProductA* createProductA() = 0;
virtual AbstractProductB* createProductB() = 0;
};

// 具体工厂1
class ConcreteFactory1 : public AbstractFactory {
public:
AbstractProductA* createProductA() override {
return new ConcreteProductA1();
}

AbstractProductB* createProductB() override {
return new ConcreteProductB1();
}
};

// 具体工厂2
class ConcreteFactory2 : public AbstractFactory {
public:
AbstractProductA* createProductA() override {
return new ConcreteProductA2();
}

AbstractProductB* createProductB() override {
return new ConcreteProductB2();
}
};

int main() {
// 使用具体工厂1创建产品
AbstractFactory* factory1 = new ConcreteFactory1();
AbstractProductA* productA1 = factory1->createProductA();
AbstractProductB* productB1 = factory1->createProductB();

productA1->operationA();
productB1->operationB();

// 使用具体工厂2创建产品
AbstractFactory* factory2 = new ConcreteFactory2();
AbstractProductA* productA2 = factory2->createProductA();
AbstractProductB* productB2 = factory2->createProductB();

productA2->operationA();
productB2->operationB();

delete factory1;
delete productA1;
delete productB1;

delete factory2;
delete productA2;
delete productB2;

return 0;
}

```

上述代码演示了一个简单的抽象工厂模式的实现，其中包括抽象产品、具体产品、抽象工厂和具体工厂。客户端可以使用具体工厂创建不同种类的产品，而不需要知道具体产品的类名。这提供了灵活性和可扩展性，允许您轻松添加新的产品和工厂。

##### 建造者（Builder）模式

将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。例如，构建包含多个部分的文档。

建造者（Builder）模式是一种创建型设计模式，它允许你分步骤地构建复杂对象。这个模式通常用于创建那些包含多个部分或参数很多的对象，而且这些对象的构建过程相对复杂，需要根据一些参数来定制。

**实现原理：**

建造者模式的核心思想是将一个复杂对象的构建过程拆分成多个步骤，每个步骤由一个具体的建造者类负责实现。通常，有一个指挥者（Director）类来协调建造者类的工作，指导对象的构建过程。建造者模式通常包括以下几个角色：

1. 产品（Product）：需要构建的复杂对象，它包含了多个部分。
2. 抽象建造者（Builder）：定义了构建产品的抽象接口，包括各个部分的构建方法。
3. 具体建造者（Concrete Builder）：实现了抽象建造者接口，负责构建产品的具体部分，并提供方法来设置这些部分。
4. 指挥者（Director）：负责协调具体建造者的工作，按照一定的顺序或逻辑来构建产品。

**特点：**

1. 分离复杂对象的构建过程和其表示，使得构建过程更加灵活，可以根据不同的需求定制对象的构建。
2. 隐藏了产品的内部结构，使得客户端不需要关心具体的构建细节。
3. 可以重用具体建造者类和指挥者类来构建不同的产品，提高了代码的复用性。
4. 建造者模式会增加代码的复杂度，因为需要定义多个具体建造者类和指挥者类。
5. 如果产品的部分组合比较简单，使用建造者模式可能会显得过于繁琐。

**C++实现代码示例：**

假设我们要构建一辆汽车对象，汽车有多个部分，包括引擎、轮胎和车身。我们将创建一个抽象建造者类 `CarBuilder`，具体建造者类 `ConcreteCarBuilder`，以及一个指挥者类 `Director` 来构建汽车对象。

```cpp
#include <iostream>
#include <string>

class Car {
public:
void setEngine(const std::string& engine) {
engine_ = engine;
}

void setTires(const std::string& tires) {
tires_ = tires;
}

void setBody(const std::string& body) {
body_ = body;
}

void showInfo() {
std::cout << "Engine: " << engine_ << std::endl;
std::cout << "Tires: " << tires_ << std::endl;
std::cout << "Body: " << body_ << std::endl;
}

private:
std::string engine_;
std::string tires_;
std::string body_;
};

class CarBuilder {
public:
virtual void buildEngine() = 0;
virtual void buildTires() = 0;
virtual void buildBody() = 0;
virtual Car getResult() = 0;
};

class ConcreteCarBuilder : public CarBuilder {
public:
void buildEngine() override {
car_.setEngine("V6 Engine");
}

void buildTires() override {
car_.setTires("18-inch Tires");
}

void buildBody() override {
car_.setBody("Sedan Body");
}

Car getResult() override {
return car_;
}

private:
Car car_;
};

class Director {
public:
Car construct() {
builder_->buildEngine();
builder_->buildTires();
builder_->buildBody();
return builder_->getResult();
}

void setBuilder(CarBuilder* builder) {
builder_ = builder;
}

private:
CarBuilder* builder_;
};

int main() {
ConcreteCarBuilder carBuilder;
Director director;

director.setBuilder(&carBuilder);
Car car = director.construct();

car.showInfo();

return 0;
}

```

在这个示例中，`Car` 类表示要构建的复杂对象，`CarBuilder` 是抽象建造者类，`ConcreteCarBuilder` 是具体建造者类，`Director` 是指挥者类。客户端通过指挥者来构建汽车对象，具体建造者类负责设置汽车的不同部分，最终构建出完整的汽车对象。

##### 代理（Proxy）模式

为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。例如，远程代理、虚拟代理、安全代理等。

代理模式（Proxy Pattern）是一种结构型设计模式，其目的是提供一个代理对象来控制对其他对象的访问。代理对象通常充当客户端和真实对象之间的中介，可以用于实现延迟加载、访问控制、缓存、监视等功能。在下面的回答中，我将详细解释代理模式的实现原理、优缺点，并提供一个简单的C++实现代码示例。

**实现原理：**

代理模式的核心思想是引入一个代理类，这个代理类包含了与真实对象相同的接口，并在内部维护一个指向真实对象的引用。代理类在执行操作时可以在适当的时候调用真实对象的方法。这个过程使得代理可以在不改变客户端代码的情况下控制对真实对象的访问。

**特点：**
1. 控制访问： 代理模式可以控制客户端对真实对象的访问，可以实现访问控制、权限管理等功能。
2. 延迟加载： 代理模式允许在需要的时候创建真实对象，从而实现延迟加载，提高性能。
3. 缓存： 代理可以维护一个缓存，存储先前访问的结果，当下次相同的请求到来时，可以直接返回缓存的结果，提高响应速度。
4. 降低耦合度： 代理模式可以隐藏真实对象的具体实现，降低客户端与真实对象之间的耦合度。
5. 复杂性增加： 引入代理类会增加代码的复杂性，因为需要额外的类来管理真实对象。
6. 性能损失： 在某些情况下，代理模式可能引入性能损失，特别是在使用缓存的情况下可能需要额外的开销。

**C++实现代码示例：**

假设我们有一个图像加载器，代理可以用于延迟加载图像：

```cpp
#include <iostream>
#include <string>

// 抽象图像接口
class Image {
public:
virtual void display() = 0;
};

// 真实图像类
class RealImage : public Image {
private:
std::string filename;

public:
RealImage(const std::string& file) : filename(file) {
loadFromDisk();
}

void display() override {
std::cout << "Displaying " << filename << std::endl;
}

void loadFromDisk() {
std::cout << "Loading " << filename << " from disk." << std::endl;
}
};

// 图像代理类
class ImageProxy : public Image {
private:
RealImage* realImage;
std::string filename;

public:
ImageProxy(const std::string& file) : filename(file), realImage(nullptr) {}

void display() override {
if (realImage == nullptr) {
realImage = new RealImage(filename);
}
realImage->display();
}
};

int main() {
Image* image1 = new ImageProxy("image1.jpg");
Image* image2 = new ImageProxy("image2.jpg");

// 图像在需要时才会被加载
image1->display();
image2->display();

// 注意：在实际应用中应该释放资源
delete image1;
delete image2;

return 0;
}

```

在这个示例中，`ImageProxy`充当了代理对象，用于控制对`RealImage`的访问。当调用`display`方法时，如果`RealImage`尚未加载，则会在需要时加载它。这样可以实现延迟加载的效果。

##### 适配器（Adapter）模式

将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。例如，使用不同格式的数据进行交互。

适配器（Adapter）模式是一种结构型设计模式，用于将一个类的接口转换成另一个接口，以便让两个不兼容的类能够一起工作。这种模式通常用于以下情况：

**实现原理：**

1. 当你有一个已经存在的类，但它的接口与你需要的接口不匹配时。
2. 当你想要复用一些现有的类，但它们的接口不符合你的需求。
3. 当你希望创建一个可复用的适配器，以便将不同的类与某个特定接口连接起来。

适配器模式有两种主要形式：类适配器和对象适配器。

1. **类适配器模式：**
在类适配器模式中，适配器类继承了需要适配的类，并实现目标接口。通过继承，适配器类可以访问原始类的方法，并将它们转换成目标接口的方法。这种方式需要使用多重继承或支持接口继承的编程语言。

**特点：**

- 可以在不修改现有代码的情况下适配不兼容的接口。
- 可以重用现有类的功能。
- 需要使用多重继承或接口继承，这在某些编程语言中可能不支持或不推荐使用。

1. **对象适配器模式：**

在对象适配器模式中，适配器类持有需要适配的对象，并实现目标接口。适配器类将客户端的请求委派给内部的对象来执行，从而实现了接口的适配。

**特点：**

- 不需要多重继承或接口继承，适配器可以用于任何类。
- 可以适配多个不同的类。
- 如果需要适配多个方法，适配器类可能会变得复杂。

对象适配器模式的实现：

```cpp
#include <iostream>

// 目标接口
class Target {
public:
virtual void request() = 0;
};

// 需要适配的类
class Adaptee {
public:
void specificRequest() {
std::cout << "Adaptee's specific request." << std::endl;
}
};

// 对象适配器类
class Adapter : public Target {
private:
Adaptee* adaptee;

public:
Adapter(Adaptee* adaptee) : adaptee(adaptee) {}

void request() override {
adaptee->specificRequest();
}
};

int main() {
Adaptee* adaptee = new Adaptee();
Target* adapter = new Adapter(adaptee);

adapter->request();

delete adaptee;
delete adapter;

return 0;
}

```

在上面的示例中，`Adaptee` 类具有一个名为 `specificRequest` 的方法，但我们希望将其适配为 `Target` 接口，以便客户端可以调用 `request` 方法。我们创建了一个 `Adapter` 类，该类持有一个 `Adaptee` 对象，并在 `request` 方法中调用了 `Adaptee` 的 `specificRequest` 方法。

##### 桥接（Bridge）模式

将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。例如，使用不同格式的数据进行交互。

##### 装饰（Decorator）模式

动态的给对象增加一些职责，即增加其额外的功能。例如，添加窗口的滚动条、边框等。

装饰器（Decorator）模式是一种结构型设计模式，用于动态地向对象添加新的功能或责任，而不需要修改其原始类。这种模式属于结构型模式，它通过一系列包装（装饰）对象来实现这一目标。装饰器模式允许你在运行时添加新功能，同时保持代码的开放封闭原则，不需要修改已有的类。

**实现原理：**

1. 创建一个抽象基类（Component），该类定义了被装饰对象和装饰对象共同拥有的接口。
2. 创建一个具体的组件类（ConcreteComponent），它是被装饰的对象，实现了抽象基类的接口。
3. 创建一个抽象装饰器类（Decorator），它也实现了抽象基类的接口，并包含一个指向抽象基类的引用。这个类可以包装具体组件对象，以添加额外的功能。
4. 创建具体的装饰器类（具体的Decorator子类），它扩展了抽象装饰器，并实现了额外的功能，通常通过在方法中调用被装饰对象的方法来实现。
5. 客户端代码创建一个具体组件对象，然后可以通过创建具体装饰器对象来包装该组件，从而添加额外的功能。客户端可以链式组合多个装饰器，以实现复杂的装饰逻辑。

**特点：**

1. 开放封闭原则：装饰器模式允许你在不修改现有代码的情况下添加新的功能，因此遵循了开放封闭原则。
2. 灵活性：你可以组合不同的装饰器以创建各种组合，以满足特定需求。
3. 单一责任原则：每个具体装饰器都专注于一个特定的功能，使代码更容易维护和扩展。
4. 可重用性：具体组件和具体装饰器可以在不同的上下文中重复使用。
5. 增加复杂性：使用装饰器模式会引入多个类，增加了代码的复杂性，特别是在有多个装饰器的情况下。
6. 客户端代码可能需要创建复杂的装饰器链，使得代码难以理解。

下面是一个简单的C++实现示例：

```cpp
#include <iostream>

// 抽象基类
class Component {
public:
virtual void operation() = 0;
};

// 具体组件
class ConcreteComponent : public Component {
public:
void operation() override {
std::cout << "ConcreteComponent operation" << std::endl;
}
};

// 抽象装饰器
class Decorator : public Component {
protected:
Component* component;

public:
Decorator(Component* comp) : component(comp) {}

void operation() override {
if (component) {
component->operation();
}
}
};

// 具体装饰器A
class ConcreteDecoratorA : public Decorator {
public:
ConcreteDecoratorA(Component* comp) : Decorator(comp) {}

void operation() override {
Decorator::operation();
std::cout << "ConcreteDecoratorA operation" << std::endl;
}
};

// 具体装饰器B
class ConcreteDecoratorB : public Decorator {
public:
ConcreteDecoratorB(Component* comp) : Decorator(comp) {}

void operation() override {
Decorator::operation();
std::cout << "ConcreteDecoratorB operation" << std::endl;
}
};

int main() {
Component* component = new ConcreteComponent();
Component* decoratedComponentA = new ConcreteDecoratorA(component);
Component* decoratedComponentB = new ConcreteDecoratorB(decoratedComponentA);

decoratedComponentB->operation();

delete decoratedComponentB;
delete decoratedComponentA;
delete component;

return 0;
}

```

在这个示例中，`Component` 是抽象基类，`ConcreteComponent` 是具体的组件类，`Decorator` 是抽象装饰器类，`ConcreteDecoratorA` 和 `ConcreteDecoratorB` 是具体的装饰器类。客户端代码可以创建组件对象，并用装饰器对象包装它，以实现不同的功能组合。

##### 外观（Facade）模式：

为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。例如，对外提供一个购物网站的统一接口，隐藏底层复杂的业务逻辑。

##### 享元（Flyweight）模式：

运用共享技术来有效地支持大量细粒度对象的复用。

##### 组合（Composite）模式：

将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。

##### 模板方法（TemplateMethod）模式：

定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。

模板方法（Template Method）模式是一种行为型设计模式，用于定义算法的基本骨架，而将一些步骤的具体实现延迟到子类中。这个模式通过将算法的不同部分委托给子类来实现，从而允许子类在不改变算法结构的情况下自定义算法的某些步骤。

**实现原理：**

1. 创建一个抽象基类，该基类包含一个模板方法（Template Method），该方法定义了算法的基本结构，包括一系列的步骤，这些步骤可以是抽象的或者有默认实现。
2. 在抽象基类中，定义一些具体的方法，这些方法可以被子类重写，以便定制算法的某些步骤。
3. 子类继承抽象基类，并实现其中的抽象方法，以提供算法步骤的具体实现。
4. 子类可以选择性地覆盖抽象方法，以根据需要自定义算法的某些部分，但不能改变算法的整体结构。

**特点：**

1. 提供了一种固定算法骨架，确保在不同的子类中保持一致的算法结构。
2. 允许子类根据自己的需求定制算法的某些步骤，提高了代码的可扩展性和灵活性。
3. 通过模板方法，将公共的行为移到父类中，减少了代码重复。
4. 如果算法的结构非常复杂，可能会导致维护困难，因为子类需要实现多个抽象方法，可能需要深入理解算法的内部结构。
5. 过度使用模板方法模式可能导致类层次结构过于庞大，难以管理。

现在，让我提供一个简单的C++实现代码示例来说明模板方法模式的应用：

```cpp
#include <iostream>

// 抽象基类
class AbstractAlgorithm {
public:
// 模板方法，定义算法骨架
void executeAlgorithm() {
step1(); // 步骤1
step2(); // 步骤2
step3(); // 步骤3
}

// 子类需要实现的抽象方法
virtual void step1() = 0;
virtual void step2() = 0;
virtual void step3() = 0;
};

// 具体子类1
class ConcreteAlgorithm1 : public AbstractAlgorithm {
public:
void step1() override {
std::cout << "ConcreteAlgorithm1: Step 1" << std::endl;
}

void step2() override {
std::cout << "ConcreteAlgorithm1: Step 2" << std::endl;
}

void step3() override {
std::cout << "ConcreteAlgorithm1: Step 3" << std::endl;
}
};

// 具体子类2
class ConcreteAlgorithm2 : public AbstractAlgorithm {
public:
void step1() override {
std::cout << "ConcreteAlgorithm2: Step 1" << std::endl;
}

void step2() override {
std::cout << "ConcreteAlgorithm2: Step 2" << std::endl;
}

void step3() override {
std::cout << "ConcreteAlgorithm2: Step 3" << std::endl;
}
};

int main() {
AbstractAlgorithm* algorithm1 = new ConcreteAlgorithm1();
AbstractAlgorithm* algorithm2 = new ConcreteAlgorithm2();

algorithm1->executeAlgorithm();
algorithm2->executeAlgorithm();

delete algorithm1;
delete algorithm2;

return 0;
}

```

在这个示例中，我们创建了一个抽象基类 `AbstractAlgorithm`，其中定义了一个模板方法 `executeAlgorithm`，它包括三个步骤。两个具体子类 `ConcreteAlgorithm1` 和 `ConcreteAlgorithm2` 继承自 `AbstractAlgorithm`，并实现了这三个步骤的具体逻辑。

在 `main` 函数中，我们创建了两个不同的子类对象，并调用它们的 `executeAlgorithm` 方法，以展示不同子类可以根据需要定制算法的某些步骤，但整体算法结构是一致的。

##### 策略（Strategy）模式

定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。例如，排序算法、支付方式选择等。

策略（Strategy）模式是一种行为型设计模式，它允许你定义一系列算法，并将每个算法封装成一个独立的对象，然后使这些算法可以互相替换。这种模式可以让客户端选择算法而不需要改变其结构。


**实现原理：**

策略模式的核心思想是将算法抽象成一个接口（或者抽象类），然后具体的算法实现都继承自这个接口。客户端通过一个策略接口来调用具体的算法，这样客户端可以在运行时选择不同的算法实现。策略模式主要包括以下角色：

1. Context（上下文）：维护一个对策略对象的引用，并提供一个接口供客户端调用以执行具体的算法。
2. Strategy（策略）：定义一个接口或抽象类，声明算法的抽象方法，具体的算法类实现这个接口。
3. ConcreteStrategy（具体策略）：实现具体的算法，并继承自策略接口，提供算法的具体实现。

**特点：**

1. 可扩展性：可以轻松添加新的算法，而无需修改现有的代码。
2. 可维护性：每个算法都被封装在一个独立的类中，易于维护和测试。
3. 灵活性：客户端可以在运行时选择不同的算法，因此具有灵活性。
4. 避免条件语句：减少了大量的条件语句，使代码更加清晰和可读。
5. 增加类的数量：每个算法都需要一个具体策略类，可能会增加类的数量，使得类的层次结构变得更复杂。
6. 客户端需要了解策略：客户端需要知道有哪些策略可供选择，可能需要在策略之间做出决策。

下面是一个简单的C++实现策略模式的示例代码：

```cpp
#include <iostream>

// Strategy 抽象类
class PaymentStrategy {
public:
virtual void pay(int amount) = 0;
};

// ConcreteStrategy1 具体策略类
class CreditCardPayment : public PaymentStrategy {
public:
void pay(int amount) override {
std::cout << "Paid " << amount << " using credit card." << std::endl;
}
};

// ConcreteStrategy2 具体策略类
class PayPalPayment : public PaymentStrategy {
public:
void pay(int amount) override {
std::cout << "Paid " << amount << " using PayPal." << std::endl;
}
};

// Context 上下文类
class ShoppingCart {
private:
PaymentStrategy* paymentStrategy;

public:
void setPaymentStrategy(PaymentStrategy* strategy) {
paymentStrategy = strategy;
}

void checkout(int amount) {
paymentStrategy->pay(amount);
}
};

int main() {
ShoppingCart cart;
PaymentStrategy* creditCard = new CreditCardPayment();
PaymentStrategy* paypal = new PayPalPayment();

cart.setPaymentStrategy(creditCard);
cart.checkout(100);

cart.setPaymentStrategy(paypal);
cart.checkout(50);

delete creditCard;
delete paypal;

return 0;
}

```

在上述示例中，我们定义了两个具体的支付策略（CreditCardPayment和PayPalPayment），它们都继承自抽象的PaymentStrategy类。然后，我们在上下文类ShoppingCart中使用策略模式来完成支付操作。客户端可以在运行时选择不同的支付策略。

##### 命令（Command）模式

将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。例如，排序算法、支付方式选择等。

##### 职责链（Chain of Responsibility）模式

把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。

职责链（Chain of Responsibility）模式是一种行为型设计模式，用于构建一条处理请求的责任链。在这个模式中，多个对象依次处理请求，直到其中一个对象能够处理该请求为止，或者请求被全部处理。这个模式允许你将请求发送者与接收者解耦，并且可以动态地改变请求的处理顺序。

**实现原理：**

1. 创建一个抽象处理器（Handler）基类，它定义了处理请求的接口，通常包括一个处理方法。
2. 每个具体处理器（ConcreteHandler）都继承自抽象处理器，它实现了处理方法，并决定是否能够处理请求。
3. 将这些具体处理器链接成一个链表或树状结构，形成责任链。
4. 当一个请求到达责任链的起点，它会依次经过链上的处理器，直到找到一个能够处理请求的处理器。
5. 如果没有处理器能够处理请求，可以选择不处理或者抛出异常。

**特点：**

1. 解耦请求发送者和接收者：请求发送者不需要知道哪个具体处理器来处理请求，只需要将请求发送到责任链的起点。
2. 灵活性：可以动态地改变责任链的结构和处理器的顺序，以满足不同的需求。
3. 单一职责原则：每个具体处理器只负责处理自己关心的请求，符合单一职责原则。
4. 有可能请求无法被处理：如果责任链没有正确配置或者没有合适的处理器，请求可能会无法被处理。
5. 性能问题：责任链可能会导致请求在链上依次传递，直到找到能够处理的处理器，可能会影响性能。

下面是一个简单的C++实现示例：

```cpp
#include <iostream>

class Handler {
public:
virtual void HandleRequest(int request) = 0;
virtual void SetSuccessor(Handler* successor) = 0;
};

class ConcreteHandlerA : public Handler {
private:
Handler* successor;

public:
void HandleRequest(int request) override {
if (request < 10) {
std::cout << "ConcreteHandlerA handled request: " << request << std::endl;
} else if (successor != nullptr) {
successor->HandleRequest(request);
}
}

void SetSuccessor(Handler* successor) override {
this->successor = successor;
}
};

class ConcreteHandlerB : public Handler {
private:
Handler* successor;

public:
void HandleRequest(int request) override {
if (request >= 10 && request < 20) {
std::cout << "ConcreteHandlerB handled request: " << request << std::endl;
} else if (successor != nullptr) {
successor->HandleRequest(request);
}
}

void SetSuccessor(Handler* successor) override {
this->successor = successor;
}
};

class ConcreteHandlerC : public Handler {
public:
void HandleRequest(int request) override {
if (request >= 20) {
std::cout << "ConcreteHandlerC handled request: " << request << std::endl;
} else {
std::cout << "Request cannot be handled." << std::endl;
}
}

void SetSuccessor(Handler* successor) override {
// ConcreteHandlerC is the last handler in the chain and does not have a successor.
}
};

int main() {
ConcreteHandlerA handlerA;
ConcreteHandlerB handlerB;
ConcreteHandlerC handlerC;

handlerA.SetSuccessor(&handlerB);
handlerB.SetSuccessor(&handlerC);

// Test requests
handlerA.HandleRequest(5);
handlerA.HandleRequest(15);
handlerA.HandleRequest(25);

return 0;
}

```

在这个示例中，我们创建了三个具体处理器 `ConcreteHandlerA`、`ConcreteHandlerB` 和 `ConcreteHandlerC`，它们依次处理请求，如果无法处理，则将请求传递给下一个处理器。通过配置处理器的顺序，我们可以动态地构建责任链来处理不同的请求。

##### 状态（State）模式：

允许一个对象在其内部状态发生改变时改变其行为能力。例如，游戏中的角色状态。

##### 观察者（Observer）模式：

多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。如，GUI框架中的事件处理。

观察者（Observer）模式是一种行为设计模式，用于定义一种对象之间的一对多依赖关系，当一个对象的状态发生变化时，所有依赖于它的对象都会得到通知并自动更新。这种模式通常用于实现发布-订阅系统，其中一个主题（或被观察者）维护一组观察者，当主题的状态发生变化时，它会通知所有观察者。

**实现原理：**

1. 主题（被观察者）：主题对象负责维护一个观察者列表，提供注册（添加观察者）和注销（移除观察者）的方法，以及通知观察者的方法。
2. 观察者：观察者对象包含一个更新方法，该方法在主题状态发生变化时被调用，用于执行相应的操作。
3. 当主题的状态发生变化时，它会遍历观察者列表，调用每个观察者的更新方法，通知它们状态的改变。

**特点：**

- 解耦性：观察者模式可以降低主题和观察者之间的耦合度，使它们可以独立变化，而不需要相互了解。
- 可扩展性：你可以轻松地添加新的观察者或主题，而不需要修改现有代码。
- 实时性：观察者可以在主题状态变化时立即做出响应，实现实时性的数据更新和通知。

- 如果观察者过多或者更新操作过于复杂，可能会导致性能问题。
- 观察者和主题之间的关系可能会变得复杂，难以理解。

```cpp
#include <iostream>
#include <vector>

class Observer {
public:
virtual void update() = 0;
};

class ConcreteObserver : public Observer {
public:
ConcreteObserver(const std::string& name) : name_(name) {}

void update() override {
std::cout << "Observer " << name_ << " received an update." << std::endl;
}

private:
std::string name_;
};

class Subject {
public:
virtual void registerObserver(Observer* observer) = 0;
virtual void removeObserver(Observer* observer) = 0;
virtual void notifyObservers() = 0;
};

class ConcreteSubject : public Subject {
public:
void registerObserver(Observer* observer) override {
observers_.push_back(observer);
}

void removeObserver(Observer* observer) override {
// Find and remove the observer from the list
auto it = std::find(observers_.begin(), observers_.end(), observer);
if (it != observers_.end()) {
observers_.erase(it);
}
}

void notifyObservers() override {
for (Observer* observer : observers_) {
observer->update();
}
}

void setState(int state) {
state_ = state;
notifyObservers(); // Notify observers when the state changes
}

private:
int state_ = 0;
std::vector<Observer*> observers_;
};

int main() {
ConcreteSubject subject;
ConcreteObserver observer1("Observer 1");
ConcreteObserver observer2("Observer 2");

subject.registerObserver(&observer1);
subject.registerObserver(&observer2);

subject.setState(1); // This will notify both observers

subject.removeObserver(&observer1); // Remove observer1
subject.setState(2); // This will only notify observer2

return 0;
}

```

在上面的示例中，我们创建了一个具体的主题 `ConcreteSubject` 和两个具体的观察者 `ConcreteObserver`。主题维护了观察者的列表，并在状态发生变化时通知观察者。观察者实现了 `update` 方法，在被通知时会输出一条消息。最后，我们在 `main` 函数中演示了如何注册观察者、移除观察者以及触发状态改变通知观察者。

##### 中介者（Mediator）模式

定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。

##### 迭代器（Iterator）模式

提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。例如，遍历集合、容器。

迭代器（Iterator）模式是一种行为型设计模式，它用于提供一种访问聚合对象（如列表、集合、数组等）元素的统一方式，而无需暴露底层数据结构的细节。这种模式可以帮助你在不影响集合对象的情况下遍历其元素。以下是迭代器模式的详细实现原理、优缺点以及一个简单的C++实现示例。

**实现原理：**

迭代器模式的核心思想是将遍历操作从聚合对象中分离出来，使得客户端可以通过迭代器对象来访问聚合对象中的元素，而不必了解聚合对象的内部结构。迭代器模式通常包括以下主要角色：

1. 迭代器（Iterator）：负责定义遍历集合元素的接口，包括访问下一个元素和判断是否还有元素等方法。
2. 具体迭代器（ConcreteIterator）：实现迭代器接口，提供具体的遍历方法。
3. 聚合（Aggregate）：负责定义创建迭代器的接口，通常包括一个获取迭代器的方法。
4. 具体聚合（ConcreteAggregate）：实现聚合接口，创建具体的迭代器对象。

**特点：**

1. 分离了客户端代码和集合对象的实现，降低了耦合度，使得代码更容易维护和扩展。
2. 提供了统一的遍历接口，使得客户端无需关心不同集合对象的遍历方式，提高了代码的可复用性。
3. 支持多种遍历方式，例如正向遍历、逆向遍历、跳跃遍历等，灵活性较高。

4. 增加了额外的类和接口，可能会导致代码复杂性增加。
5. 在某些编程语言中，迭代器模式的实现可能需要较多的代码，不够简洁。
6. 在某些情况下，使用迭代器模式可能会导致性能损失，因为需要维护额外的对象。

下面是一个简单的C++实现示例：

```cpp
#include <iostream>
#include <vector>

// 迭代器接口
class Iterator {
public:
virtual bool hasNext() = 0;
virtual int next() = 0;
};

// 具体迭代器实现
class ConcreteIterator : public Iterator {
private:
std::vector<int> data;
int index;

public:
ConcreteIterator(std::vector<int> items) : data(items), index(0) {}

bool hasNext() override {
return index < data.size();
}

int next() override {
if (hasNext()) {
return data[index++];
}
return -1; // 或者抛出异常表示遍历结束
}
};

// 聚合接口
class Aggregate {
public:
virtual Iterator* createIterator() = 0;
};

// 具体聚合实现
class ConcreteAggregate : public Aggregate {
private:
std::vector<int> data;

public:
ConcreteAggregate(std::vector<int> items) : data(items) {}

Iterator* createIterator() override {
return new ConcreteIterator(data);
}
};

int main() {
std::vector<int> items = {1, 2, 3, 4, 5};
ConcreteAggregate aggregate(items);
Iterator* iterator = aggregate.createIterator();

while (iterator->hasNext()) {
int value = iterator->next();
std::cout << value << " ";
}

delete iterator;

return 0;
}

```

在上面的示例中，我们创建了一个迭代器模式的简单实现，包括迭代器接口、具体迭代器实现、聚合接口以及具体聚合实现。客户端代码可以通过迭代器来遍历聚合对象中的元素，而不必了解聚合对象的内部结构。

##### 访问者（Visitor）模式

在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。例如，编译器中的抽象语法树遍历。

##### 备忘录（Memento）模式

在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。例如，文本编辑器的撤销功能。

##### 解释器（Interpreter）模式

提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。例如，正则表达式解析器。

##### 什么是有限状态机?

编程时实现相关业务逻辑时, 经常需要处理各种事件和状态切换, 将此业务模型进行抽象, 就可以设计有限状态机, 使得逻辑清晰，结构规整。

状态机可归纳为4个要素，即现态、条件、动作、次态。“现态”和“条件”是因，“动作”和“次态”是果。详解如下：

1. 现态：是指当前所处的状态。
2. 条件：又称为“事件”。当一个条件被满足，将会触发一个动作，或者执行一次状态的迁移。
3. 动作：条件满足后执行的动作。动作执行完毕后，可以迁移到新的状态，也可以仍旧保持原状态。动作不是必需的，当条件满足后，也可以不执行任何动作，直接迁移到新状态。
4. 次态：条件满足后要迁往的新状态。“次态”是相对于“现态”而言的，“次态”一旦被激活，就转变成新的“现态”了。

## **操作系统 （系统，内存， 进程）**

#### 基本关键词概念（进程，线程，阻塞，非阻塞，同步，异步，并发，互斥，锁，条件同步）

1. 线程：线程是进程内的执行单元，一个进程可以包含多个线程，它们共享该进程的地址空间和系统资源。线程则作为轻量级的执行单元，同一进程内的线程切换不需要切换内存空间和大部分执行上下文，因此线程之间的切换比进程之间的切换要快得多。
2. 进程：进程是操作系统进行资源分配和调度的基本单位，比如一个正在运行的程序，每个进程都有自己独立的地址空间，一套完整的系统资源（如内存、处理器时间等）。进程之间的内存空间是隔离的，这意味着一个进程不能直接访问另一个进程的资源。作为资源分配的单元，进程拥有独立的执行上下文，这意味着每次进程切换，操作系统需要保存和加载进程的上下文信息，这个过程相对耗时。
3. 阻塞：当执行其他任务时，必须等待此任务完成，才可以继续做事。
4. 非阻塞：当执行其他任务时，无需等待其完成，你可以继续做其他事。
5. 同步：当执行其他任务时，需要任务直接返回结果（所以一般是阻塞的），即按顺序执行任务。
6. 异步：当执行其他任务时，可以等会在需要时再取结果或不需要结果（所以一般是非阻塞）。实现多个任务并发执行.
7. 并发：指同时利用多个执行单元（如线程、进程等）执行多个任务的能力。并发的任务可能会相互影响，需要适当的互斥和同步机制来保证共享资源的正确访问和避免数据竞争。
8. 条件同步：当执行任务时，可以通过其他任务发出的条件信号指示以确认是否要继续执行任务。
9. 互斥：指在同一时刻只能有一个线程访问共享资源，其他线程需要等待当前线程释放资源后才能访问。
10. 锁：用于实现互斥的一种机制，例如互斥锁、读写锁、自旋锁等。
11. 条件变量：用于线程之间的通信和等待特定条件的发生，实现条件同步。
12. 信号量: 用于控制资源的访问数量和实现互斥，实现并发限流。
13. 原子操作：:指不可分割的操作，保证对共享资源的访问是原子的，避免并发访问共享资源时的竞争问题。
14. 线程池：是一组已经创建好的线程，可以重复使用，避免了线程创建和销毁的开销。

#### 系统相关：冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？

- **运算器：CPU** (CPU是计算机的大脑，负责执行存储在内存中的指令。它包括算术逻辑单元（ALU）和控制单元（CU），用于执行算术运算、逻辑操作和控制程序的流程。)
- **存储器：内存** (计算机的程序和数据都存储在内存中，它们以二进制形式表示，并可以通过地址访问。这意味着程序可以像数据一样被处理，从而实现了程序的灵活性和可编程性。)
- **控制器：南桥北桥** 北桥负责与CPU通信，并且连接高速设备（内存/显卡），并且与南桥通信；南桥负责与低速设备（硬盘/USB）通信，时钟/BIOS/系统管理/旧式设备控制，并且与北桥通信。
- **输入设备：键盘**
- **输出设备：显示器、网卡**

#### 系统相关：不同层次的**存储器**的优缺点(寄存器|缓存|内存|硬盘)

- 寄存器（Registers）: 最快的存储器，位于CPU内部，用于存储临时数据和中间结果。可以直接在寄存器之间执行操作，无需访问主内存。但是容量非常有限，通常只有几十个到几百个字节。成本高昂，由于其速度和容量限制，只存储最关键的数据。
- 高速缓存存储器（Cache Memory）: 介于寄存器和主内存之间，提供了快速的数据访问。增加了CPU对数据的命中率，减少了对主内存的频繁访问。容量有限，通常以KB为单位。增加了系统复杂性，需要管理缓存一致性和替换策略。
- 主内存（Main Memory）：比高速缓存大得多，通常以GB为单位。速度较快，适用于大多数计算任务。相对于CPU的速度而言较慢，可能导致内存访问延迟。大容量主内存需要更多的电力和散热管理。..
- 辅助存储器（Secondary Storage）：提供了长期数据存储，如硬盘驱动器（HDD）和固态硬盘（SSD）。大容量，适用于持久化数据。

#### 系统相关：当键盘输入字符，CPU 怎么感知，怎么和输入设备交互

- CPU 感知键盘输入通过中断和操作系统的协作，键盘输入被转换为字符或键值，并存储在输入缓冲区中，供应用程序使用。这个过程允许用户与计算机进行键盘输入交互。
    
    CPU 通过输入设备和操作系统的协作来感知和交互键盘输入。以下是一般的工作流程：
    1. 键盘输入:
    当用户按下或释放键盘上的键时，键盘硬件会产生一个电信号，代表被按下或释放的键。
    2. 键盘控制器:
    键盘控制器是键盘上的一块电路板，负责接收键盘的电信号并将其转换为计算机能够理解的格式。这个格式通常是键盘扫描码（scan code），每个按键都有一个唯一的扫描码。
    3. 中断请求 (IRQ):
    键盘控制器通常通过中断请求 (IRQ) 向 CPU 发出信号，以指示有键盘输入可用。IRQ 是一种硬件中断，用于通知 CPU 需要执行与输入设备交互的操作。
    4. 操作系统介入:
    当 CPU 收到 IRQ 信号时，操作系统的中断处理程序会执行。这个中断处理程序负责与键盘控制器通信，读取扫描码，然后将其转换为字符或键值。
    5. 输入缓冲区:
    操作系统通常维护一个输入缓冲区，用于存储从键盘读取的字符或键值。这些字符在缓冲区中排队等待被进一步处理。
    6. 应用程序交互:
    当应用程序需要读取键盘输入时，它会向操作系统请求从输入缓冲区中获取字符或键值。应用程序可以使用编程接口（例如 C 或 C++ 中的 getchar() 函数）来获取用户输入。
    7. 用户交互:
    应用程序通常会将用户输入用于各种操作，例如文本输入、游戏控制或系统命令执行。
    

#### 系统相关：操作系统起什么作用，为什么要有操作系统

操作系统（Operating System）是管理计算机硬件和软件资源的系统软件, 位于底层硬件与用户之间. 用户可以通过操作系统的用户界面，输入命令。操作系统则对命令进行解释，驱动硬件设备，实现用户要求。以现代标准而言，一个标准PC的操作系统应该提供以下的功能：

- **安全机制（Security）**: 操作系统监视系统的运行状态，以检测和处理错误。它还实施安全性措施，如权限管理和身份验证，以保护系统免受未经授权的访问和恶意软件攻击。
- **进程管理（Processing management）**: 不管是常驻程序或者应用程序，他们都以进程为标准执行单位。进程管理指的是操作系统调整多个进程的功能, 包括进程执行调度, 进程间通信, 进程异常处理, 死锁监测等问题。
    - 在单处理器，宏内核的情况下多进程只是简单迅速地切换各进程，让每个进程都能够执行; 在多内核或多处理器的情况下，所有进程透过许多协同技术在各处理器或内核上转换。
- **内存管理（Memory management）**:内存管理的主要目标是为进程分配内存空间、保证各进程间的内存隔离、提高内存的利用效率以及通过虚拟内存机制扩展物理内存的容量。
    - 操作系统负责为进程分配所需的内存空间，并在进程结束或不再需要这些内存时释放它们。内存分配可以是静态的（在程序运行之前分配）或者动态的（在程序运行期间分配）。
    - 操作系统为每个进程提供独立的虚拟地址空间，使得每个进程都认为自己独占整个内存, 确保各进程之间的内存隔离，防止一个进程访问或修改其他进程的内存数据。虚拟地址通过CPU的内存管理单元（MMU）映射到物理地址。虚拟内存通过分页机制将进程的地址空间划分为固定大小的页，虚拟页映射到物理内存的页框。当物理内存不足时，操作系统可以将不常用的页面暂时存储到磁盘（换出），在需要时再从磁盘读取（换入）.
    - 将进程的内存地址空间划分为多个段（如代码段、数据段和堆栈段）。每个段有独立的段基址和段界限，提高了内存管理的灵活性。
    - 操作系统允许将文件映射到进程的地址空间，使得文件内容可以像内存一样直接访问。
- **文件系统（File system）**: 操作系统提供了文件系统，允许用户和应用程序创建、读取、写入和删除文件。文件系统还管理文件的目录结构，使文件能够被组织和检索。
    - 系统可以以**日志式**或**非日志式**建置文件系统。日志式文件系统可以以较安全的手法执行系统恢复。如果一个没有日志式建置的文件系统遇上突然的系统崩溃，导致资料建立在一半时停顿，则此系统需要特殊的文件系统检查工具才能撤销；日志式则可自动恢复。微软的NTFS与Linux的ext3、ext4、reiserFS与JFS都是日志式文件系统。
- **网络通信（Networking）**
- **用户界面（User interface）**: 操作系统通常提供用户界面，以便用户与计算机交互。这可以是命令行界面（如终端或命令提示符）或图形用户界面（如 Windows、macOS 或 Linux 桌面环境）。
- **驱动程序（Device drivers）**: 操作系统包含设备驱动程序，这些驱动程序允许计算机与各种硬件设备（例如打印机、键盘、鼠标、网卡等）进行通信。驱动程序充当操作系统与硬件之间的桥梁。

操作系统在运行时会根据程序的执行情况和需要切换两种状态：内核态（Kernel Mode）和用户态（User Mode）。
1. **内核态（Kernel Mode）**:
    
    - 内核态是操作系统拥有最高权限的状态，在这种状态下，操作系统可以直接访问所有硬件资源和系统资源。
    - 在内核态下，操作系统可以执行特权指令，并且可以执行一些敏感的操作，如修改内存映射、控制设备等。
    - 内核态通常只有操作系统的内核代码可以运行，而应用程序不能直接运行在内核态下。
2. **用户态（User Mode）**:
    
    - 用户态是应用程序和用户代码运行的状态，在这种状态下，应用程序只能访问受限资源，不能直接访问硬件资源。
    - 当应用程序需要访问系统资源或执行特权操作时，必须通过系统调用的方式将控制权切换到内核态，由操作系统代表应用程序执行所需的操作，然后再将控制权返回给应用程序。

#### 系统相关：为什么操作系统中要有内核态、用户态状态的区分？

内核态（Kernel Mode）和用户态（User Mode）是计算机操作系统中两种不同的运行级别, 两者进行区分主要是为了**确保系统运行的安全和稳定**。

内核态是操作系统内核代码运行的环境(系统状态)，具有最高权限. 在这个模式下，CPU可以执行任何指令，并访问系统的所有资源。同时, 可以响应所有的中断请求，处理硬件事件和系统调用。

用户态是普通应用程序运行的环境(系统状态)，权限受限。在这个模式下, 可以进行日常的计算等操作, 但是当需要访问系统资源或执行特权操作时，用户态应用程序需要通过系统调用接口请求内核态服务。这样可以防止应用程序错误或恶意的直接破坏系统稳定性。

1. **安全性**：内核态允许操作系统执行管理硬件资源和运行关键系统任务的权限操作，例如管理内存、处理器调度和直接访问硬件。用户态则限制应用程序只能进行一些不会影响系统整体稳定性的操作。这样可以防止恶意软件或者错误的应用程序直接干预系统核心功能和硬件，保护系统不被破坏。
2. **稳定性**：通过将应用程序的运行环境限制在用户态，操作系统能够防止应用程序直接执行可能会导致系统不稳定的操作。如果一个应用程序崩溃，它不会影响到运行在内核态的系统核心部分，从而保证了系统的整体稳定性。
3. **资源管理**：内核态提供了必要的权限来有效地管理系统资源，如CPU时间分配、内存管理等。这种权限的区分确保了操作系统可以高效且公平地分配资源给各个运行中的程序，而不被任何一个用户程序所独占或滥用。
4. **隔离和控制**：内核态和用户态的分离使得操作系统可以更好地隔离不同的程序和进程，提高系统的容错能力。用户程序在用户态出错或行为异常时，不会直接影响到内核态的操作，这有助于维护系统的整体安全和稳定。
5. **效率**：虽然从用户态切换到内核态会有一定的性能开销，但这种设计使得操作系统能够更加有效地控制程序对硬件的访问和系统资源的使用，从而整体上提高了系统的运行效率和响应速度。

##### 怎么进入内核态：(系统调用)

进入内核态通常发生在用户程序执行某些需要操作系统介入的操作时。这些操作通常通过系统调用、中断或异常来实现。

1. **系统调用**是最常见的从用户态到内核态的转换方式。这个过程涉及到操作系统的API和内核级的服务例程，这些都是预先设计好的，确保在执行敏感或危险操作时能够保持系统的安全性和稳定性。当用户程序需要执行一些如文件操作、网络通信或进程管理等不能直接由用户程序控制的操作时，它会通过系统调用请求操作系统提供服务。系统调用是一种软件中断，它将CPU从用户态切换到内核态，以便操作系统可以安全地执行那些需要更高权限的操作。
2. **硬件中断**：当硬件设备需要注意时（例如，网络卡接收到新的数据包或硬盘完成数据读写操作），它会向CPU发送中断信号。接收到硬件中断信号后，CPU会暂停当前正在执行的任务，保存当前状态，然后转入内核态来处理这个中断。
3. **系统异常**：当发生异常事件（例如，除零错误、访问违规的内存地址等）时，CPU会自动转入内核态，操作系统接管控制，以处理这些异常。这通常涉及到错误的诊断、程序的中止或者其他错误恢复操作。
4. **特权指令**：有些特殊的CPU指令只能在内核态执行，这些指令通常涉及到硬件设置或是关键的系统配置。当这些指令执行时，它们会确保CPU处于内核态。

#### 系统相关：系统异常 | 硬件中断 | 软件中断 | 软中断

**系统异常:** 系统异常是指在 CPU 处理器执行指令过程中，由于某些异常情况（如不存在或未授权的非法指令、零做除数错误、页错误等）而引发的事件。异常是同步事件，当 CPU 检测到时会立即发送给内核处理, 每种异常都有对应的处理程序，由操作系统预定义。

**硬件中断:** 硬件中断是由外部硬件设备（如键盘、硬盘、网络接口等）发出的电信号，经由中断控制器加工转发给 CPU. 此时 CPU 停止当前指令的执行，保存当前上下文（包括程序计数器、状态寄存器等）, 从中断控制器获取中断向量号并在中断向量表中查找相应的中断服务例程（ISR）的地址。随后跳转到例程地址，执行相应的中断处理程序。
- 硬件中断是异步事件，可以在任何时间点发生，不依赖于当前指令的执行。
- 不同的中断有不同的优先级，系统会根据优先级处理高优先级的中断。
- 系统维护一个中断向量表，将中断号和对应的中断处理程序地址对应起来。

**软件中断:** 软件中断是由程序使用特定指令（如x86中的INT指令）主动触发的中断, 同步事件。常用于实现系统调用，程序通过软件中断请求操作系统提供的服务。软件中断会引发从用户态到内核态的切换，以便操作系统处理请求。

**软中断:** 软中断不是软件中断, 是一种特殊的中断机制，主要用于延迟处理某些任务，避免硬件中断处理程序中执行耗时操作。用于中断处理的下半程（Bottom Halves），非关键逻辑的部分，来提高中断处理的效率与实时性，最常用于 I/O 相关的中断处理。
- 软中断是在内核态运行的，但与硬件中断不同，它通常是由内核自己触发，用于延迟处理。
- 软中断处理通常具有较低的优先级，可以在较空闲的时候处理，以提高系统响应速度。
- 软中断机制在不同操作系统中可能有不同的实现，例如Linux内核中的软中断（SoftIRQ）。

区别于软中断（SoftIRQ），处理中断下半程的方法除了软中断，还有 tasklet，二者存在一定的区别与联系：

- 二者都可以被注册用于中断处理下半程的延时任务；
- 同一种类型的 tasklet 只能串行执行，而同类型的软中断可以多个 CPU 并发执行，不同类型的软中断和 tasklet 均可并发执行；
- tasklet 底层是基于两种软中断来实现的，分别是 HI_SOFTIRQ 和 TASKLET_SOFTIRQ；

#### 进程管理：进程，线程，协程

**进程**正在运行的程序实例, 是**操作系统中**的一个**独立执行单位**，它拥有**独立**的内存空间、代码、数据和系统**资源**，不同进程能够并发地执行不同的任务，并且无法直接访问其他进程的内存。
- 在操作系统中进程的**切换开销较大**，因为切换涉及到保存和恢复整个进程的上下文(内存映射关系, 文件描述符, 整体内存空间(代码段, 数据段, 堆栈等), 内核态和用户态的转换等)。
- 进程虽然相互独立，但是通过进程间通信（IPC）机制来交换信息，如**管道、消息队列、共享内存**。

**线程**是**进程内的执行单元**，多个线程**共享**同一进程的内存空间、代码和数据，因此不同线程之间可以更轻松地进行通信和数据共享，但同时也需要考虑线程安全问题。线程的切换开销较小，因为切换只涉及保存和恢复线程的上下文(寄存器状态: 寄存器值、程序计数器等, 私有数据: 局部变量等)，通常不需要显式地使用锁和同步机制。

**协程**是一种比线程更轻量级的并发编程技术，允许在单个线程内执行多个独立的任务，避免了大部分线程切换的开销。线程内的协程采用协作式调度，任务在适当的时机主动让出执行权，实现任务间的协作和切换。

- **进程状态的切换(**创建→就绪→运行→阻塞→唤醒→终止**)**
    
    **进程**从创建开始到退出的流程**状态**: 创建→就绪→运行→阻塞→唤醒→终止
    
    ![Untitled](软件工程师.assets/Untitled%2070.png)
    
    只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。
    
    • 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。
    

####  进程管理：常用的进程或线程间通信方式(管道 | 共享内存 | 消息队列 | 套接字 | 信号 | 信号量)

**进程间通信: 管道 | 共享内存 | 消息队列 | 套接字 | 信号 | 信号量**

- 管道：
    - 无名管道（内存文件）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程之间使用。通常用于具有亲缘关系的进程间通信，如父子进程。父进程创建管道，然后 fork 出子进程，父子进程可以通过管道进行通信。
    - 有名管道（FIFO 文件，借助文件系统）：有名管道也是半双工的通信方式，但是允许在没有亲缘关系的进程之间使用，管道是先进先出的通信方式。有名管道在文件系统中有一个路径名，进程可以通过路径名打开这个管道来进行通信。
- 共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与信号量，配合使用来实现进程间的同步和通信。
- 消息队列：消息队列是有消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
- 套接字：套接字通常用于网络编程，通过套接字，进程可以在网络上发送和接收数据, 适用于不同机器间进程通信. 在本地也可作为两个进程通信的方式。
- 信号：用于通知接收进程某个事件已经发生，比如按下 ctrl + C 就是信号。每个信号都有一个唯一的编号，当进程接收到信号时，可以执行预先定义的信号处理函数来处理信号。
- 信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，实现进程、线程的对临界区的同步及互斥访问。

**线程间通信: 信号 | 锁 | 条件变量 | 信号量 | 全局变量 | 消息 | 事件**
实际上只有进程间需要通信,同一进程的线程共享地址空间,没有通信的必要，但要做好同步/互斥,保护共享的全局变量。
- Linux：信号：类似进程间的信号处理
- Linux：锁机制：互斥锁、读写锁和自旋锁
- Linux：条件变量：使用通知的方式解锁，与互斥锁配合使用
- Linux：信号量：包括无名线程信号量和命名线程信号量
- Windows：全局变量：需要有多个线程来访问一个全局变量时，通常我们会在这个全局变量前加上 volatile 声明，以防编译器对此变量进行优化
- Windows：Message 消息机制：常用的 Message 通信的接口主要有两个：PostMessage 和 PostThreadMessage，PostMessage 为线程向主窗口发送消息。而 PostThreadMessage 是任意两个线程之间的通信接口。
- Windows：CEvent 对象：CEvent 为 MFC 中的一个对象，可以通过对 CEvent 的触发状态进行改变，从而实现线程间的通信和同步，这个主要是实现线程直接同步的一种方法。

实际物理内存较小但能够运行多个程序的原因在于虚拟内存和操作系统的内存管理机制。虚拟内存允许操作系统将进程的虚拟地址空间映射到物理内存或磁盘上的一页文件，从而实现了对大于物理内存的内存空间的支持。

#### 进程管理：进程创建和执行经历状态

1. **新建状态（New）**：进程刚刚被创建，正在等待分配资源，例如分配内存空间、初始化数据结构等。
2. **就绪状态（Ready）**：进程已经准备好运行，但由于CPU正在执行其他进程，因此暂时无法执行。进程处于就绪队列中等待CPU调度执行。
3. **运行状态（Running）**：进程正在CPU上执行指令，处于运行状态。在单CPU系统中，同一时刻只能有一个进程处于运行状态。
4. **阻塞状态（Blocked）**：进程暂时无法执行，因为它正在等待某个事件的发生，例如等待I/O操作完成、等待某个信号量的释放等。在这种情况下，进程会被移动到阻塞队列中，直到事件发生为止。
5. **终止状态（Terminated）**：进程已经执行完成或被终止，但其在系统中的相关资源（如内存空间、打开的文件等）还未被释放。最终，进程将被完全移出系统。

#### 进程管理：进程调度(抢占式,非抢占式)及其算法(先来先服务, 最短作业, 最短剩余时间, 时间片轮转, 优先级, 最高响应比)

进程由 CPU 执行, 当 CPU 空闲时，操作系统会决定在多个就绪态进程中选择哪一个进程分配给 CPU执行。进程调度可以分为抢占式和非抢占式两种方式：
1. **非抢占式调度**：在非抢占式调度中，一旦 CPU 开始执行一个进程，该进程将一直执行直到完成或主动释放 CPU。在这种调度方式下，只有当进程自愿放弃 CPU（如等待 I/O 操作完成）或者进程终止时，系统才会进行调度切换到另一个进程。典型的非抢占式调度算法包括 FCFS（先来先服务）和 SJF（短作业优先）。
2. **抢占式调度**：在抢占式调度中，操作系统可以在一个进程执行期间暂停该进程的执行，并将 CPU 分配给另一个优先级更高的进程。抢占式调度可以通过时钟中断或者更高优先级进程就绪等方式触发。常见的抢占式调度算法有优先级调度、轮转调度和多级反馈队列调度等。

- **先来先服务（First-Come, First-Served，FCFS）**：这是最简单的调度算法，按照进程到达的顺序进行调度。先到达的进程首先得到处理器的时间。不考虑优先级或执行时间。缺点是可能导致长作业时间（长进程等待时间）。
- **最短作业优先（Shortest Job First，SJF）:** 选择执行时间最短的进程，以最小化平均等待时间。这是一种非抢占式算法，要求提前知道每个进程的执行时间。长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。
- **最短剩余时间优先（Shortest Remaining Time Next，SRTN）**：最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。
- **时间片轮转调度（Round Robin，RR）**：将所有就绪进程按先来先服务的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。
- **优先级调度（Priority Scheduling）**：每个进程都有一个优先级，高优先级的进程优先执行。这可以是非抢占式或抢占式的，具体取决于算法的实现。
- **最高响应比优先（Highest Response Ratio Next，HRRN）**：计算每个进程的响应比（等待时间加上服务时间的比例），然后选择响应比最高的进程执行。
    

#### 进程管理：进程（线程）调度算法（先来先服务调度算法、短作业(进程)优先调度算法、高优先级优先调度算法、时间片轮转法、多级反馈队列调度算法）

1. 先来先服务调度算法：每次调度都是从后备作业（进程）队列中选择一个或多个最先进入该队列的作业（进程），将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。
2. 短作业(进程)优先调度算法：短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业（进程），将它们调入内存运行。
3. 高优先级优先调度算法：当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程
4. 时间片轮转法：每次调度时，把 CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几 ms 到几百 ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。
5. 多级反馈队列调度算法：综合前面多种调度算法。

在这些调度算法中，有抢占式和非抢占式的区别。

1. **非抢占式优先权算法** 在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时，系统方可再将处理机重新分配给另一优先权最高的进程。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。
2. **抢占式优先权调度算法** 在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。因此，在采用这种调度算法时，是每当系统中出现一个新的就绪进程 i 时，就将其优先权 Pi 与正在执行的进程 j 的优先权 Pj 进行比较。如果 Pi≤Pj，原进程 Pj 便继续执行；但如果是 Pi>Pj，则立即停止 Pj 的执行，做进程切换，使 i 进程投入执行。显然，这种抢占式的优先权调度算法能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。

区别：

非抢占式（Nonpreemptive）：让进程运行直到结束或阻塞的调度方式，容易实现，适合专用系统，不适合通用系统。抢占式（Preemptive）：允许将逻辑上可继续运行的在运行过程暂停的调度方式可防止单一进程长时间独占，CPU 系统开销大（降低途径：硬件实现进程切换，或扩充主存以贮存大部分程序）

#### 进程管理：一个进程可以创建多少线程，和什么有关？

当一个线程被创建时，操作系统会为其分配一个栈空间。栈空间的大小通常在几 MB 到几十 MB 之间，
- 在32位系统中，由于地址总线只有32根，所以最多只能寻址 2^32 个地址，即4GB。其中，一部分地址空间被保留给内核空间，因此用户态的虚拟地址空间一般只有3GB左右可供用户程序使用。
- 而在64位系统中，地址总线有64根，理论上可以寻址 2^64 个地址，用户态的虚拟空间大到有 128 TB，理论上不会受虚拟内存大小的限制，而会受系统的参数或性能限制。

#### 进程管理：多线程和多进程管理的虚拟技术(时分复用技术和空分复用技术)

多进程与多线程：多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。

虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。

#### 进程管理：守护进程、僵尸进程和孤儿进程 (怎么避免)

- **守护进程:** 指在后台运行的，没有控制终端与之相连的进程。它独立于控制终端，周期性地执行某种任务。Linux 的大多数服务器就是用守护进程的方式实现的，如 web 服务器进程 http 等
    
    创建守护进程要点：
    
    （1）让程序在后台执行。方法是调用 fork（）产生一个子进程，然后使父进程退出。
    
    （2）调用 setsid（）创建一个新对话期。控制终端、登录会话和进程组通常是从父进程继承下来的，守护进程要摆脱它们，不受它们的影响，方法是调用 setsid（）使进程成为一个会话组长。setsid（）调用成功后，进程成为新的会话组长和进程组长，并与原来的登录会话、进程组和控制终端脱离。
    
    （3）禁止进程重新打开控制终端。经过以上步骤，进程已经成为一个无终端的会话组长，但是它可以重新申请打开一个终端。为了避免这种情况发生，可以通过使进程不再是会话组长来实现。再一次通过 fork（）创建新的子进程，使调用 fork 的进程退出。
    
    （4）关闭不再需要的文件描述符。子进程从父进程继承打开的文件描述符。如不关闭，将会浪费系统资源，造成进程所在的文件系统无法卸下以及引起无法预料的错误。首先获得最高文件描述符值，然后用一个循环程序，关闭 0 到最高文件描述符值的所有文件描述符。
    
    （5）将当前目录更改为根目录。
    
    （6）子进程从父进程继承的文件创建屏蔽字可能会拒绝某些许可权。为防止这一点，使用 unmask（0）将屏蔽字清零。
    
    （7）处理 SIGCHLD 信号。对于服务器进程，在请求到来时往往生成子进程处理请求。如果子进程等待父进程捕获状态，则子进程将成为僵尸进程（zombie），从而占用系统资源。如果父进程等待子进程结束，将增加父进程的负担，影响服务器进程的并发性能。在 Linux 下可以简单地将 SIGCHLD 信号的操作设为 SIG_IGN。这样，子进程结束时不会产生僵尸进程。
    
- **孤儿进程:** 如果父进程先退出，子进程还没退出，那么子进程的父进程将变为 init 进程。（注：任何一个进程都必须有父进程）。
    
    一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被 init 进程(进程号为 1)所收养，并由 init 进程对它们完成状态收集工作。
    
- **僵尸进程:** 如果子进程先退出，父进程还没退出，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则这个时候子进程就成为僵尸进程。
    
    如果子进程先退出，父进程还没退出，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则这个时候子进程就成为僵尸进程。
    
    设置**僵尸进程的目**的是维护子进程的信息，以便父进程在以后某个时候获取。这些信息至少包括进程 ID，进程的终止状态，以及该进程使用的 CPU 时间，所以当终止子进程的父进程调用 wait 或 waitpid 时就可以得到这些信息。如果一个进程终止，而该进程有子进程处于僵尸状态，那么它的所有僵尸子进程的父进程 ID 将被重置为 1（init 进程）。继承这些子进程的 init 进程将清理它们（也就是说 init 进程将 wait 它们，从而去除它们的僵尸状态）。
    
    **如何避免僵尸进程？**
    
    - 通过 signal(SIGCHLD, SIG_IGN)通知内核对子进程的结束不关心，由内核回收。如果不想让父进程挂起，可以在父进程中加入一条语句：signal(SIGCHLD,SIG_IGN);表示父进程忽略 SIGCHLD 信号，该信号是子进程退出的时候向父进程发送的。
    - 父进程调用 wait/waitpid 等函数等待子进程结束，如果尚无子进程退出 wait 会导致父进程阻塞。waitpid 可以通过传递 WNOHANG 使父进程不阻塞立即返回。
    - 如果父进程很忙可以用 signal 注册信号处理函数，在信号处理函数调用 wait/waitpid 等待子进程退出。
    - 通过两次调用 fork。父进程首先调用 fork 创建一个子进程然后 waitpid 等待子进程退出，子进程再 fork 一个孙进程后退出。这样子进程退出后会被父进程等待回收，而对于孙子进程其父进程已经退出所以孙进程成为一个孤儿进程，孤儿进程由 init 进程接管，孙进程结束后，init 会等待回收。

#### 进程管理：程序运行时(从就绪态到运行态), CPU 资源是什么时候被申请的？

CPU 资源在计算机系统中是根据需要被申请的，通常是由运行的程序或进程触发。以下是一些常见的情况：
程序启动： 当用户启动一个应用程序时，操作系统会为该程序分配 CPU 资源。这包括将程序加载到内存中，并将控制权转移到程序的入口点，以便开始执行程序。
进程创建：当一个进程需要执行时，操作系统会创建该进程。这通常涉及分配必要的资源（内存、文件描述符等）以及将进程的控制块（包含有关进程的信息，如状态、寄存器状态等）加载到内核中。
就绪队列：进程创建或是需要执行时，它会进入操作系统的就绪队列，其中包含了所有准备好运行的进程, 等待 CPU 时间。

**进程切换**： 在操作系统中，调度器负责选择哪个进程将在 CPU 上执行。在进程调度器选择程序后，它将CPU资源分配给该程序, 并执行上下文切换操作。
- 这涉及**保存当前**正在运行进程的状态, 包括保存寄存器状态、程序计数器、堆栈指针以及其他必要的寄存器和状态信息。并**加载被选中进程**的寄存器状态。
- 这将确保进程从上一次中断的地方继续执行。操作系统会从其控制块或内核数据结构中获取其状态信息, 包括加载新进程的寄存器状态、程序计数器和其他必要信息。如果新进程的地址空间与当前进程不同，则可能需要执行**地址空间切换,** 包括切换内存映射，以便新进程可以访问其独立的内存空间。
**运行态**：一旦上下文切换完成，被选中的进程成功从就绪态转换为运行态，它可以在 CPU 上执行指令。

**程序执行:** 被选中的进程现在在 CPU 上运行，执行其指令，直到它主动放弃 CPU 时间、等待 I/O 操作完成、或者由于其他原因被操作系统挂起。当进程放弃 CPU 时间或进入阻塞状态时，它将返回到就绪队列，等待下一次被调度执行。

#### 进程管理：终端退出，终端运行的进程会怎样

终端在退出时会发送 SIGHUP 给对应的 bash 进程，bash 进程收到这个信号后首先将它发给 session 下面的进程，如果程序没有对 SIGHUP 信号做特殊处理，那么进程就会随着终端关闭而退出

#### 进程管理：如何让进程后台运行

1）命令后面加上&即可，实际上，这样是将命令放入到一个作业队列中了

（2）ctrl + z 挂起进程，使用 jobs 查看序号，在使用 bg %序号后台运行进程

（3）nohup + &，将标准输出和标准错误缺省会被重定向到 nohup.out 文件中，忽略所有挂断（SIGHUP）信号

（4）运行指令前面 + setsid，使其父进程编程 init 进程，不受 HUP 信号的影响

（5）将命令+ &放在()括号中，也可以是进程不受 HUP 信号的影响

#### 内存管理相关：内存管理技术: 虚拟内存和物理内存

**物理内存**： 真实存在的，插在内存槽上的内存条（RAM, 随机访问存储器）, 用于存储程序和数据，CPU 可以直接访问这些数据。

**虚拟内存**: 是计算机系统内的一种**内存管理技术**, 使得应用程序拥有一个连续可用的虚拟地址空间, 并将虚拟地址映射到计算机物理内存中的物理地址中。

每个进程只能看到虚拟内存空间，它提供了一个连续的地址范围，允许进程使用虚拟地址来访问物理内存位置。不同进程不能直接访问对方的地址空间。这种隔离有助于防止进程之间相互干扰或滥用内存。

进程所持有的虚拟地址可以通过 CPU 中的内存管理单元（MMU）自动将虚拟地址转换为物理地址, 然后再通过物理地址访问内存.

目前的操作系统管理虚拟地址与物理地址之间的关系一般是通过内存分段(代码分段、数据分段、栈段、堆段)和内存分页, 以及一些其他的高速缓存方法来实现的.

当程序访问某个内存区域时, 操作系统会将对应的页面加载到物理内存中, 程序就可以访问这些内存区域了. 

如果物理内存不足, 一些操作系统会提供扩展功能, 实现会将部分数据和程序所在页面写入硬盘中, 以腾出空间给需要使用的页面. 这个过程对程序员是非透明的, 程序员只需要使用合适的方式分配和释放堆内存, 其它内存区域都是由编译器和操作系统自动管理的. 因此, 一般来说虚拟内存空间往往远大于实际物理内存空间.

#### 内存管理相关：内存分配方式（分页、分段(代码分段、数据分段、栈段、堆段)、段页式,）

- **分页**是一种将虚拟内存和物理内存都划分为固定大小的块的方法，通常是4KB，这些块称为“页面”。操作系统通过页表来映射虚拟页到物理页。当程序需要访问某个地址时，操作系统查找相应的页面，如果该页面不在物理内存中，则发生“页面缺失”，系统将从磁盘中调入缺失的页面到物理内存中。分页也减少了内存碎片，但由于每次访问都可能涉及到页表查找，可能导致一定的性能开销。
- 缺页中断触发条件: 缺页中断是在进程（或线程）访问虚拟内存中的某个页时，如果该页当前不在物理内存中，操作系统会引发缺页中断，触发页的换入操作。
- **分段**是一种按照程序的逻辑结构来划分内存的方法，每个“段”可能代表程序的一部分，每个段可以包含不同类型的数据，如代码段、数据段、堆栈段等。分段允许程序和数据以不同长度的段存在，每个段都有自己的起始地址和长度，更符合程序的自然结构。但是可能导致段内碎片，因为每个段的大小不一。
- 段页式内存管理结合了分段和分页的优势，首先将内存分段，每个段内部再进行分页。这种方法既保留了分段的优点，如支持程序的逻辑结构和保护，同时又兼顾了分页的高效内存利用率和简化的管理。段页式管理增加了地址转换的复杂性，因为地址转换需要两次映射：先段内映射再页内映射。

#### 内存管理相关：内存分段布局(内核空间和用户空间(代码, 数据,BSS,堆,内存映射,栈段))

程序进程的虚拟地址空间会被分为用户空间和内核空间两个部分. 
内核空间则包含操作系统内核的代码和数据，例如中断处理程序、系统调用接口等。

用户空间中, 从低地址到高地址，一个程序的内存区域一般被分成如下几个区。

- **代码段：** 主要存储可执行二进制代码, 字符串字面值, 该区域的属性是只读的.
    - `const char* str = "Hello, world!";`
- **数据段:** 指的是主要存放已初始化且初值不为 0 的全局变量和只读常量, 静态变量等.
    - `全局: int globalVar = 42;` 
    - `const int readOnlyVar = 42;`
    - `static int staticVar = 100;`
    - `static const float staticConst = 3.14f;`
    - `func{const int localConst = 50;}`
- **BSS 段：** 存放未初始化或初始值为 0 的全局变量和局部静态变量, 以及未定义且初值不为 0 的符号.
    - `全局: int globalVar;` 
    - `static int localVar;`
- **堆区：** 由 new 分配的内存块，一般一个 new 就要对应一个 delete。
- **共享库的内存映射段:** 内核将将硬盘文件的内容直接映射到内存, 一种方便高效的文件 I/O 方式, 通常被用来加载动态库. 任何应用程序都可以通过 Linux 的 `mmap()` 系统调用或者 Windows 的  `CreateFileMapping() / MapViewOfFile()`  请求这种映射.
- **栈区：** 用来存储局部变量, 临时变量, 返回值, 函数参数, 函数的返回指针等. 当这些变量超出了当前作用域时将会自动弹出. 该栈的最大存储是有大小的, 该值固定, 超过该大小将会造成栈溢出. 操作方式类似于数据结构中的栈. 例如, 调用一个方法或函数时, 会将一个新的栈帧（stack frame）压入到栈中, 这个栈帧会在函数返回时被清理掉.

#### 内存管理相关：**堆和栈**的区别(内存管理)

堆（Heap）和栈（Stack）是计算机内存管理中的两种主要方式, 两者主要有以下区别:

内存分配方式
- **栈（Stack）**：
    - **自动分配和释放**：栈内存由操作系统自动管理，分配和释放都由系统完成，通常在函数调用时分配，在函数返回时释放。
    - **固定大小**：栈的大小在程序启动时就确定了，因此在嵌套调用和递归较深时可能会出现栈溢出（Stack Overflow）。
- **堆（Heap）**：
    - **手动分配和释放**：堆内存由程序员通过动态内存分配函数（如 `malloc` 、 `free` ，或 `new` 、 `delete` ）来管理。程序员需要显式地分配和释放内存。
    - **动态大小**：堆的大小是动态变化的，可以在运行时根据需要分配内存，但这也可能导致内存碎片和分配/释放的开销较大。

**内存管理方式**
- **栈（Stack）**：
    - **LIFO（后进先出）**：栈是一个后进先出的数据结构，最先分配的内存最后被释放。这种顺序使得栈内存的分配和释放非常高效。
    - **局部性好**：由于栈内存是连续分配的，因此具有良好的局部性，有助于缓存性能。
- **堆（Heap）**：
    - **自由存储**：堆是一块大的内存区域，内存分配是随机的，不遵循任何顺序，这使得内存分配更加灵活。
    - **碎片化问题**：由于堆内存的自由分配和释放，可能会产生内存碎片，降低内存使用效率。

**使用场景**

- **栈（Stack）**：
    - **函数调用和局部变量**：栈主要用于存储函数调用的上下文，包括函数的局部变量、参数、返回地址等。
    - **递归**：递归调用时，每次递归调用都会在栈上分配新的栈帧，直到递归返回。
- **堆（Heap）**：
    - **动态数据**：堆用于存储动态分配的数据，比如通过 `malloc` 或 `new` 分配的对象和数组。
    - **长生命周期数据**：如果数据需要在函数调用结束后依然存在（即生命周期超过函数调用），应该使用堆内存。

**性能**
- **栈（Stack）**：
    - **速度快**：由于栈内存的分配和释放是自动且顺序的，其开销非常低，速度很快。
    - **有限大小**：栈的大小通常较小，受限于操作系统的设置，如果超出限制，会导致栈溢出。
- **堆（Heap）**：
    - **速度慢**：由于堆内存的分配和释放需要维护数据结构（如自由列表），其开销相对较高，速度较慢。
    - **大小灵活**：堆的大小只受限于可用内存，总体上可以分配更大的内存块。

**典型问题**

- **栈（Stack）**：
    - **栈溢出**：如果递归太深或分配过多局部变量，可能会导致栈溢出。
    - **固定内存**：栈内存的大小是固定的，不能动态调整。
- **堆（Heap）**：
    - **内存泄漏**：如果分配的内存没有正确释放，会导致内存泄漏。
    - **内存碎片**：频繁的分配和释放操作会导致内存碎片化，降低内存利用效率。

- 栈是一种线性数据结构，使用的是一种特殊的数据存储方式，称为"先进后出"（LIFO，Last-In-First-Out）。栈中的数据以堆叠的方式存储，只有栈顶的数据可以直接访问，要访问或删除其他数据，必须先将上面的数据出栈。堆是一块大的内存区域，用于动态分配内存, 内存分配是随机的，不遵循任何顺序。在堆中，数据的存储和访问也没有固定的顺序。数据在堆中以分散的方式存储，可以通过指针相互关联。
- 栈内存分配由编译器自动管理，用于存储局部变量、函数参数、返回地址以及函数调用的上下文信息。栈的分配和释放是非常快速的，但栈的大小通常是有限的，编译时或运行时确定。堆内存分配是动态的，由程序员手动申请和释放。在堆中，数据的生存期不受限制，可以持续存在直到程序明确释放。堆的大小通常受限于操作系统和可用物理内存。
- 栈上的数据的生命周期由其作用域（例如，函数的局部变量）控制。当变量超出作用域时，它们将被自动销毁，即出栈。栈上的数据生命周期短暂，适用于保存临时变量。堆上的数据的生命周期由程序员显式管理。它们可以长时间存在，直到程序员释放它们。这使得堆适合存储动态分配的数据，如动态数组和对象。
- 栈上的数据访问速度通常非常快，因为它们存储在内存中的连续位置，并且不需要寻址操作。栈上的访问时间是常数时间（O(1)）。堆上的数据访问速度较慢，因为需要通过指针来寻址，并且数据可能分散在内存中的不同位置。堆上的访问时间通常是对数时间（O(log n)）或线性时间（O(n)，取决于数据结构的实现）。

#### 内存管理相关：程序从堆中动态分配内存时，虚拟内存上怎么操作的

当程序请求动态分配内存时，操作系统会在程序的虚拟地址空间中找到一块合适的未使用的地址范围，并将其映射到物理内存中。这个映射是通过页表来实现的。
页表：是一个存放在物理内存中的数据结构，它记录了虚拟页与物理页的映射关系

在进行动态内存分配时，例如 malloc() 函数或者其他高级语言中的 new 关键字，操作系统会在硬盘中创建或申请一段虚拟内存空间，并更新到页表（分配一个页表条目（PTE），使该 PTE 指向硬盘上这个新创建的虚拟页），通过 PTE 建立虚拟页和物理页的映射关系。

#### 内存管理相关：内存管理技术: 内存页面置换算法(最佳置换法, 先进先出置换算法, 最近最久未使用置换算法, 时钟置换算法(CLOCK))

当一个程序或进程尝试访问一个还未加载到物理内存的页面，或者物理内存已满需要载入新页面时，页面置换算法决定将哪个已存在的页面被移出物理内存以释放空间，使得新的页面能够被载入。

- **最佳置换法(OPT)：**一种理想化的算法，它置换将来最长时间不会被访问的页面。
    
    最佳置换算法(OPT，Optimal) :每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。
    
    ![http://oss.interviewguide.cn/img/202205212345108.png](http://oss.interviewguide.cn/img/202205212345108.png)
    
    最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，最佳置换算法是无法实现的
    
- **先进先出置换算法(FIFO)：**按照页面进入内存的顺序进行置换，最先进入内存的页面将最先被置换出去。
    
    先进先出置换算法(FIFO) :每次选择淘汰的页面是最早进入内存的页面 实现方法:把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面队列的最大长度取决于系统为进程分配了多少个内存块。
    
    ![http://oss.interviewguide.cn/img/202205212345413.png](http://oss.interviewguide.cn/img/202205212345413.png)
    
    ![http://oss.interviewguide.cn/img/202205212345552.png](http://oss.interviewguide.cn/img/202205212345552.png)
    
    Belady异常—当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。
    
    只有FIFO算法会产生Belady异常，而LRU和OPT算法永远不会出现Belady异常。另外，FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，算法性能差
    
    FIFO的性能较差，因为较早调入的页往往是经常被访问的页，这些页在FIFO算法下被反复调入和调出，并且有Belady现象。所谓Belady现象是指：采用FIFO算法时，如果对—个进程未分配它所要求的全部页面，有时就会出现分配的页面数增多但缺页率反而提高的异常现象。
    
- **最近最久未使用置换算法(LRU)：**这种算法置换最长时间未被访问的页面。理论上，最近未被访问的页面在未来也不太可能被访问。
    
    最近最久未使用置换算法(LRU，least recently used) :每次淘汰的页面是最近最久未使用的页面 实现方法:赋予每个页面对应的页表项中，用访问字段记录该页面自.上次被访问以来所经历的时间t(该算法的实现需要专门的硬件支持，虽然算法性能好，但是实现困难，开销大)。当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面。
    
    LRU性能较好，但需要寄存器和栈的硬件支持。LRU是堆栈类算法，理论上可以证明，堆栈类算法不可能出现Belady异常。
    
    ![http://oss.interviewguide.cn/img/202205212345619.png](http://oss.interviewguide.cn/img/202205212345619.png)
    
    在手动做题时，若需要淘汰页面，可以逆向检查此时在内存中的几个页面号。在逆向扫描过程中最后一个出现的页号就是要淘汰的页面。
    
- **时钟置换算法(CLOCK)**：一种实现简单且效果良好的近似LRU算法，使用一个循环列表（时钟）和一个使用位来标记每个页面的访问情况。
    
    最佳置换算法性OPT能最好，但无法实现；先进先出置换算法实现简单，但算法性能差；最近最久未使用置换算法性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。
    
    所以操作系统的设计者尝试了很多算法，试图用比较小的开销接近LRU的性能，这类算法都是CLOCK算法的变体，因为算法要循环扫描缓冲区像时钟一样转动。所以叫clock算法。
    
    时钟置换算法是一种性能和开销较均衡的算法，又称CLOCK算法，或最近未用算法(NRU，Not Recently Used)
    
    简单的CLOCK算法实现方法:为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰-一个页面时，只需检查页的访问位。如果是0，就选择该页换出;如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第- - ~轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描(第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择–个淘汰页面最多会经过两轮扫描)
    
    ![http://oss.interviewguide.cn/img/202205212345526.png](http://oss.interviewguide.cn/img/202205212345526.png)
    
- **改进型的时钟置换算法**
    
    简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过,就不需要执行I/O操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。
    
    因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他条件都相同时，应优先淘汰没有修改过的页面，避免I/O操作。这就是改进型的时钟置换算法的思想。修改位=0，表示页面没有被修改过;修改位=1，表示页面被修改过。
    
    为方便讨论，用(访问位，修改位)的形式表示各页面状态。如(1, 1)表示一个页面近期被访问过，且被修改过。
    
    改进型的Clock算法需要综合考虑某一内存页面的访问位和修改位来判断是否置换该页面。在实际编写算法过程中，同样可以用一个等长的整型数组来标识每个内存块的修改状态。访问位A和修改位M可以组成一下四种类型的页面。
    
    算法规则:将所有可能被置换的页面排成–个循环队列
    
    > 第一轮:从当前位置开始扫描到第一个(A =0, M = 0)的帧用于替换。表示该页面最近既未被访问，又未被修改，是最佳淘汰页 第二轮:若第一轮扫描失败，则重新扫描，查找第一个(A =1, M = 0)的帧用于替换。本轮将所有扫描过的帧访问位设为0。表示该页面最近未被访问，但已被修改，并不是很好的淘汰页。 第三轮:若第二轮扫描失败，则重新扫描，查找第一个(A =0, M = 1)的帧用于替换。本轮扫描不修改任何标志位。表示该页面最近已被访问，但未被修改，该页有可能再被访问。 第四轮:若第三轮扫描失败，则重新扫描，查找第一个A =1, M = 1)的帧用于替换。表示该页最近已被访问且被修改，该页可能再被访问。
    > 
    
    由于第二轮已将所有帧的访问位设为0，因此经过第三轮、第四轮扫描一定会有一个帧被选中，因此改进型CLOCK置换算法选择- -个淘汰页面最多会进行四轮扫描
    
    ![http://oss.interviewguide.cn/img/202205212345046.png](http://oss.interviewguide.cn/img/202205212345046.png)
    
    算法规则：将所有可能被置换的页面排成一个循环队列 第一轮:从当前位置开始扫描到第-一个(0, 0)的帧用于替换。本轮扫描不修改任何标志位。(第一优先级:最近没访问，且没修改的页面) 第二轮:若第一轮扫描失败，则重新扫描，查找第一个(0, 1)的帧用于替换。本轮将所有扫描过的帧访问位设为0 (第二优先级: 最近没访问，但修改过的页面) 第三轮:若第二轮扫描失败，则重新扫描，查找第一个(0, 0)的帧用于替换。本轮扫描不修改任何标志位(第三优先级:最近访问过，但没修改的页面) 第四轮:若第三轮扫描失败，则重新扫描，查找第一个(0, 1)的帧用于替换。(第四优先级:最近访问过，且修改过的页面) 由于第二轮已将所有帧的访问位设为0，因此经过第三轮、第四轮扫描一定会有一个帧被选中，因此改进型CLOCK置换算法选择一个淘汰页面最多会进行四轮扫描
    

#### 内存管理相关：程序从堆中动态分配内存时，虚拟内存上怎么操作的

在进行动态内存分配时，例如malloc()函数或者其他高级语言中的new关键字，操作系统会在硬盘中创建或申请一段虚拟内存空间，并更新到页表（分配一个页表条目（PTE），使该PTE指向硬盘上这个新创建的虚拟页），通过PTE建立虚拟页和物理页的映射关系。

#### 内存管理相关：逻辑地址(页表|页面|页偏移)如何转换为物理地址

**页面**：这是虚拟内存系统中管理内存的基本单位。通常，操作系统会将虚拟内存和物理内存都分割成同样大小的块，这些块被称为“页面”。

**逻辑地址**由页号和页内偏移组成。页号用于查找对应的物理内存块号，而页内偏移定义了在物理内存块内的具体位置。

**页表**是一个数据结构，它将虚拟页号映射到物理内存块号。每个进程都有自己的页表，通常存储在内存中，可以借助进程的页表将逻辑地址转换为物理地址。

操作系统通过页表寄存器(PTR)来访问当前执行进程的页表，其中存放了页表在内存中的起始地址F和页表长度M。进程未执行时，页表的始址和页表长度放在进程控制块(PCB) 中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。

注意:页面大小是2的整数幂 设页面大小为L，逻辑地址A到物理地址E的变换过程如下:

例:若页面大小L为1K字节，页号2对应的内存块号b=8，将逻辑地址A=2500转换为物理地址E。 等价描述：某系统按字节寻址，逻辑地址结构中，页内偏移量占10位(说明一个页面的大小为2^10B = 1KB)，页号2对应的内存块号 b=8，将逻辑地址A=2500转换为物理地址E。

![Untitled](软件工程师.assets/Untitled%2067.png)

![Untitled](软件工程师.assets/Untitled%2068.png)

#### 内存管理相关：什么是快表(高速缓冲存储器)

快表，又称联想寄存器(TLB) ，是一种访问速度比内存快很多的高速缓冲存储器，用来存放存储了最近使用的页表项，包括页号和相应的物理块号，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。

![Untitled](软件工程师.assets/Untitled%2069.png)

| 地址变换过程 | 访问一个逻辑地址的访存次数 |
| --- | --- |
| 基本地址变换机构 | ①算页号、页内偏移量 ②检查页号合法性 ③查页表，找到页面存放的内存块号 ④根据内存块号与页内偏移量得到物理地址 ⑤访问目标内存单元 |
| 具有快表的地址变换机构 | ①算页号、页内偏移量 ②检查页号合法性 ③查快表。若命中，即可知道页面存放的内存块号，可直接进行⑤;若未命中则进行④ ④查页表，找到页面存放的内存块号，并且将页表项复制到快表中 ⑤根据内存块号与页内偏移量得到物理地址 ⑥访问目标内存单元 |

#### 内存管理相关：内存交换和覆盖有什么区别？

交换技术主要是在不同进程（或作业）之间进行，而覆盖则用于同一程序或进程中。

由于程序运行时并非任何时候都要访问程序及数据的各个部分（尤其是大程序），因此可以把用户空间分成为一个固定区和若干个覆盖区。将经常活跃的部分放在固定区，其余部分按照调用关系分段，首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统将其调入覆盖区，替换覆盖区中原有的段。

**覆盖技术的特点：**是打破了必须将一个进程的全部信息装入内存后才能运行的限制，但当同时运行程序的代码量大于主存时仍不能运行，再而，大家要注意到，内存中能够更新的地方只有覆盖区的段，不在覆盖区的段会常驻内存。

**交换(对换)技术的设计思想**：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存(进程在内存与磁盘间动态调度)

换入：把准备好竞争CPU运行的程序从辅存移到内存。 换出：把处于等待状态（或CPU调度原则下被剥夺运行权力）的程序从内存移到辅存，把内存空间腾出来。

**什么时候会进行内存的交换？**

内存交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如:在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程;如果缺页率明显下降，就可以暂停换出。

**内存交换中，被换出的进程保存在哪里？**

保存在磁盘中，也就是外存中。具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式;对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用连续分配方式(学过文件管理章节后即可理解)。总之，对换区的I/O速度比文件区的更快。

#### 内存管理相关：动态内存分区分配算法(首次适应算法, 最佳适应算法, 最坏适应算法, 邻近适应算法, )

- **首次适应算法**
    
    算法思想：每次都从低地址开始查找，找到第–个能满足大小的空闲分区。
    
    如何实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链( 或空闲分[表)，找到大小能满足要求的第-一个空闲分区。
    
- **最佳适应算法**
    
    算法思想:由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区,即，优先使用更小的空闲区。
    
    如何实现:空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第-一个空闲分区。
    
- **最坏适应算法**
    
    算法思想:为了解决最佳适应算法的问题—即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。
    
    如何实现:空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第-一个空闲分区。
    
- **邻近适应算法**
    
    算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。
    
    如何实现：空闲分区以地址递增的顺序排列(可排成-一个循环链表)。每次分配内存时从上次查找结束的位置开始查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。
    
- 比较表格
    
    | 算法 | 算法思想 | 分区排列顺序 | 优点 | 缺点 |
    | --- | --- | --- | --- | --- |
    | 首次适应 | 从头到尾找适合的分区 | 空闲分区以地址递增次序排列 | 综合看性能最好。算法开销小，回收分区后一.般不需要对空闲分区队列重新排序 |  |
    | 最佳适应 | 优先使用更小的分区，以保留更多大分区 | 空闲分区以容量递增次序排列 | 会有更多的大分区被保留下来，更能满足大进程需求 | 会产生很多太小的、难以利用的碎片;算法开销大，回收分区后可能需要对空闲分区队列重新排序 |
    | 最坏适应 | 优先使用更大的分区，以防止产生太小的不可用的碎片 | 空闲分区以容量递减次序排列 | 可以减少难以利用的小碎片 | 大分区容易被用完，不利于大进程;算法开销大(原因同上) |
    | 邻近适应 | 由首次适应演变而来，每次从上次查找结束位置开始查找 | 空闲分区以地址递增次序排列(可排列成循环链表) | 不用每次都从低地址的小分区开始检索。算法开销小(原因同首次适应算法) | 会使高地址的大分区也被用完 |

#### 内存管理相关：内存交换空间概念

Linux 中的交换空间（Swap space）在**物理内存**（RAM）被充满时被使用。如果系统需要更多的内存资源，而物理内存已经充满，内存中不活跃的页就会被移到交换空间去。虽然交换空间可以为带有少量内存的机器提供帮助，但是这种方法不应该被当做是对内存的取代。交换空间位于硬盘驱动器上，它比进入物理内存要慢。 交换空间可以是一个专用的交换分区（推荐的方法），交换文件，或两者的组合。 交换空间的总大小应该相当于你的计算机内存的两倍和 32 MB这两个值中较大的一个，但是它不能超过 2048MB（2 GB）。

#### 内存管理相关：操作系统在对内存进行管理的时候需要做些什么

- 操作系统负责内存空间的分配与回收。
- 操作系统需要提供某种技术从逻辑上对内存空间进行扩充。
- 操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换。
- 操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰

## 计算机网络

### OSI 网络七层模型和五层模型

五层：应用层→传输层→网络层→数据链路层→物理层
七层：应用层→表示层→会话层→传输层→网络层→数据链路层→物理层

OSI 七层模型的各个层次和它们的主要功能：

1. 应用层（Application Layer）
- 功能：为用户和应用程序提供网络服务接口，包括文件传输、电子邮件、Web 浏览等, 直接与应用程序交互，应用层的数据单位是消息或数据。
- 包含的协议/组成：常见的协议包括超文本传输协议（HTTP）、文件传输协议（FTP）、简单邮件传输协议（SMTP）、域名系统（DNS）等。
- 传输过程：应用层处理应用程序的网络请求和响应，将用户输入的数据传送给下层，接收和处理从下层传来的数据。

2. 表示层（Presentation Layer）：
- 功能：负责数据的格式化和转换，包括数据加密、解密、压缩、解压等，并确保数据在不同系统之间的兼容性，表示层的数据单位是数据表示（Data Representation）。
- 包含的协议/组成：常见的协议和标准包括加密协议（如SSL/TLS）、JPEG、MPEG等。
- 传输过程：表示层对数据进行编码、解码、加密、解密等处理，确保数据在不同系统之间的兼容性。

3. 会话层（Session Layer）：
- 功能：负责建立、维护和终止会话，管理多个应用程序之间的通信。它定义了会话的控制和同步，会话层的数据单位是会话数据（Session Data）。
- 包含的协议/组成：常见的协议包括远程过程调用（RPC）、会话控制协议（SCP）等。
- 传输过程：会话层在通信双方之间建立会话，管理会话状态，并在需要时重新建立会话。

4. 传输层（Transport Layer）：
- 功能：提供端到端的通信，确保数据的可靠传输，处理数据的分段和重组。它负责主机之间的数据传输，传输层的数据单位是报文段（Segment）。
- 包含的协议/组成：传输控制协议（TCP）和用户数据报协议（UDP）是最常见的协议。
- 传输过程：传输层将数据分成段，并为每个段添加传输控制信息，确保数据段能够可靠地到达目的地并按顺序重组。

5. 网络层（Network Layer）：
- 功能：负责数据包的路由和转发，实现不同网络之间的通信。它定义了数据包如何在不同网络之间传输，网络层的数据单位是数据包（Packet）。
- 包含的协议/组成：常见的协议包括互联网协议（IP）、互联网控制消息协议（ICMP）、地址解析协议（ARP）等。
- 传输过程：网络层根据路由表决定数据包的转发路径，并处理数据包的地址转换和网络间的数据转发。

6. 数据链路层（Data Link Layer）：
- 功能：提供数据帧的传输和接收，处理物理层传输错误，实现逐帧访问、流控制和错误检测。它负责点对点之间的数据传输，数据链路层的数据单位是帧（Frame）。
- 包含的协议/组成：常见的协议有以太网（Ethernet）、点对点协议（PPP）、链路控制协议（LCP）等。
- 传输过程：数据链路层将物理层传输的数据组织成帧，添加头部和尾部信息，用于检测和纠正传输错误。

7. 物理层（Physical Layer）：
- 功能：定义物理媒体和物理连接的特性，如电压、信号传输速率、线缆类型等。它负责实际的比特流传输，物理层的数据单位是比特（Bit）。
- 包含的协议/组成：物理层的组成包括网线、光纤、电缆、集线器、交换机、网络接口卡等。
- 传输过程：物理层将数据转换为可以在物理媒介上传输的信号，并负责接收和解码这些信号。

### URL解析过程

DNS 解析(获得IP地址)→建立 TCP/UDP 连接→发起 HTTP/HTTPS/SMTP/POP3/FTP/DNS请求→服务器处理请求→服务器响应 →浏览器解析 HTTP 数据→浏览器请求资源→浏览器渲染页面→关闭连接

### DNS 域名解析过程

本地 DNS 缓存(浏览器/系统/路由器) → 本地 DNS 服务器→根域名服务器→顶级域名服务器→权威域名服务器→解析响应→保存结果至缓存 (将主机域名转换为 ip 地址，属于应用层协议，使用**UDP传输**)（展开查看浏览器 dns 解析流程）

• 请求一旦发起，若是 chrome 浏览器，先在浏览器找之前**有没有缓存过的域名所对应的ip地址**，有的话，直接跳过dns解析了，若是没有，就会**找硬盘的hosts文件**，看看有没有，有的话，直接找到hosts文件里面的ip
• 如果本地的hosts文件没有能得到对应的ip地址，浏览器会发出一个**dns请求到本地dns服务器**，**本地dns服务器一般都是你的网络接入服务器商提供**，比如中国电信，中国移动等。
• 查询你输入的网址的DNS请求到达本地DNS服务器之后，**本地DNS服务器会首先查询它的缓存记录**，如果缓存中有此条记录，就可以直接返回结果，此过程是**递归的方式进行查询**。如果没有，本地DNS服务器还要向**DNS根服务器**进行查询。
• 本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。
• 最后，本地DNS服务器向**域名的解析服务器**发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。

### ipv4 和 ipv6 的区别，以及优缺点。

1. IPv4：IPv4 使用32位地址长度，通常以点分十进制形式表示，例如192.168.1.1。

特点：
- 早期标准，广泛应用，成熟的基础设施和广泛的支持。
- 地址空间有限，地址耗尽问题严重，需要使用NAT（网络地址转换）等技术来延缓地址枯竭。
- 需要手动分配IP地址，配置较为复杂。但是可以通过动态主机配置协议（DHCP）自动分配IP地址。
- 路由：依赖于IP头部中的TTL（生存时间）字段来防止数据包无限循环。并支持在路由器上进行数据包的分段和重组，但效率较低。
- IPSec（互联网协议安全）是可选的，未强制实施。
- 支持广播（向所有设备发送数据包）。支持多播（向一组特定设备发送数据包）。

2. IPv6：IPv6使用128位地址长度, 32 个以冒号分隔的八组四位十六进制数表示，例如 `2001:0db8:85a3:0000:0000:8a2e:03 70:7334`

特点：
- 支持无状态地址自动配置（SLAAC），设备可以自动生成唯一的IP地址。并支持通过DHCPv6自动配置，但不依赖于DHCP。
- 使用跳数限制字段（Hop Limit）来防止数据包无限循环。不支持路由器分段，要求端到端路径上的MTU（最大传输单元）一致。
- IPSec 是协议的一部分，默认支持但不强制使用，提供更高的安全性。
- 不支持广播，使用链路本地多播和任播（向最近的设备发送数据包）。支持增强的多播功能，支持更高效的多播通信。

### 应用层协议: HTTP 和 HTTPS 和 DNS

#### HTTP 请求结构，和响应报文结构

HTTP 请求结构：一个 HTTP 请求一般由请求行，请求头，请求体几个部分组成。

```html
# HTTP 1.1

# 起始行
<Method> <URL> <HTTP Version>

- `<Method>`：请求方法，表示对资源的操作类型，如GET、POST、PUT、HEAD、DELETE、CONNECT、OPTIONS、TRACE等。
- `<URL>`：请求的URL，指定了服务器上的资源路径。
- `<HTTP Version>`：HTTP协议的版本，例如HTTP/1.0。
- `Exemple`: GET /home HTTP/1.1

# 请求头
Host: <host-name>
User-Agent: <user-agent-info>
Content-Type: <content-type> 标记报文 body 部分的数据类型
Accept: <media-types> 希望接收特定类型的数据
Content-Length: <content-length>
Content-Encoding: <Content-Encoding> 标记发送数据的压缩方式
Accept-Encoding: <Content-Encoding> 标记希望接收的数据压缩方式
Content-Language: zh-CN, zh, en
Accept-Language: zh-CN, zh, en

# 空行 + 请求体
```

- HTTP 请求协议头(请求方法) 特点和区别
    - GET: 请求指定的页面信息，并返回实体主体。
    - HEAD: 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头
    - POST: 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。
    - PUT: 从客户端向服务器传送的数据取代指定的文档的内容。
    - DELETE: 请求服务器删除指定的页面。
    - CONNECT: HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。
    - OPTIONS: 列出可对资源实行的请求方法，用来跨域请求
    - TRACE: 追踪请求-响应的传输路径, 主要用于测试或诊断。
    - PATCH: 对 PUT 方法的补充，用来对已知资源进行局部更新 。

HTTP 响应报文结构

```html
# HTTP 1.1

# 状态行
<Version> <Status Code> <Reason>

- `<Version>`：HTTP协议的版本，例如HTTP/1.0。
- `<Status Code>`：状态码。
- `<Reason>`：原因。
- `Exemple`: HTTP/1.1 200 OK

# 请求头
Host: <host-name>
User-Agent: <user-agent-info>
Content-Type: <content-type>
Content-Length: <content-length>
Accept: <media-types>

# 空行 + 响应体
```

HTTP **响应状态码**介绍和区别：

1 xx: 表示目前是协议处理的中间状态，还需要后续操作。
- **100 Continue** ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。
2 xx: 表示成功状态。
- **200 OK:** 请求已经成功处理
- **204 No Content** ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。
- **206 Partial Content** ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。
3 xx: 重定向状态，资源位置发生变动，需要重新请求。
- **301 Moved Permanently** ：永久性重定向
- **302 Found** ：临时性重定向
- **303 See Other** ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。
- **304 Not Modified** ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。
- **307 Temporary Redirect** ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。
4 xx: 请求报文有误。
- **400 Bad Request** ：（笼统提示错误）
- **401 Unauthorized** ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。
- **403 Forbidden** ：（请求被服务器拒绝）
- **404 Not Found:**（资源未找到）
- 405（请求方法不被服务器端允许）
- 406（资源无法满足客户端的条件）
- 408（服务器等待了太长时间）
- 409（多个请求发生了冲突）
- 413（请求体的数据过大）
- 414（请求行里的 URI 太大）
- 429（客户端发送的请求过多）
- 431（请求头的字段内容太大）
5 xx: 服务器端发生错误。
- **500 Internal Server Error** ：**（**笼统提示**服务器出错）**
- 501（请求的功能还不支持）
- 502（访问的时候出错）
- 503 **Service Unavailable** ：（服务器当前很忙）
    

#### GET、POST 区别，安全性

- 最**直观**的区别就是 GET 把参数包含在 URL 中，以 `?` 分割URL和传输数据，参数之间以 `&` 相连, 只能接收 ASCII 字符，有长度限制；POST 通过 request body 传递参数，没有限制。
- 从**缓存**的角度，GET 请求会被浏览器主动缓存下来，留下历史记录； POST 默认不会。
- 从**安全**的角度，GET 一般放在 URL 中，因此不安全；POST 放在请求体中，更适合传输敏感信息。
- 从**幂等性**的角度，`GET`是**幂等**的，而`POST`不是。(`幂等`表示执行相同的操作，结果也是相同的，即GET不会对服务器产生影响， 只读)  因为get请求是幂等的，**在网络不好的隧道中会尝试重试**。如果用get请求增数据，会有**重复操作**的风险，而这种重复操作可能会导致副作用（浏览器和操作系统并不知道你会用get请求去做增操作）。
- 从 **TCP** 的角度，GET 请求会把请求报文一次性发出去，服务器响应 200 状态; 而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100 (continue)， 然后发 body 部分, 服务器响应 200 状态。

#### http 和 https 的区别

HTTP 是**明文协议**，数据在 TCP 传输过程中不经过加密，容易被窃听和篡改。

HTTPS 通过使用 SSL（Secure Sockets Layer）或 TLS（Transport Layer Security）协议通过**信息加密**, **数据校验**和**身份验证**过程确保传输的数据的机密性和完整性，提供更高的安全性, 防止中间人攻击和伪装。

HTTP 默认使用端口号 80 进行通信，而 HTTPS 默认使用端口号 443。

#### http 1.0, http 1.1 和 http 2.0 三者的区别

HTTP 1.0：
- **无状态连接**：每个请求和响应都是独立的，服务器不保留客户端的状态。
- **单请求-单响应**：每次连接只能处理一个请求，完成后就关闭连接。

HTTP 1.1：
- **持久连接（Persistent Connections）**：默认情况下，连接在传输完成后不会立即关闭，可以复用同一连接处理多个请求，减少了开销。
- **请求管道化（Pipelining）**：允许在一个连接上同时发送多个请求，而不必等待前一个请求的响应，从而提高了效率（尽管这种特性在实际应用中支持有限）。
- **分块传输编码（Chunked Transfer Encoding）**：允许在不确定内容长度的情况下分块发送响应。
- **附加请求头和响应头**：包括缓存控制（Cache-Control）、内容协商（Content Negotiation）等，使客户端和服务器之间的通信更灵活和高效。

3. 引入了虚拟主机（Virtual Host）的支持，使得多个域名可以共享同一个IP地址。
5. 引入了更多的缓存机制，包括可缓存的响应标识和缓存控制头部。
6. 支持基本的身份认证和持久化连接的身份认证。

HTTP 2.0：
- **二进制分帧（Binary Framing）**：HTTP 2.0 使用二进制格式而非文本格式进行传输，将请求和响应数据分割为更小的帧，可以并行发送和解析, 使解析更高效且错误率更低。
- **多路复用（Multiplexing）**：在一个连接中可以同时发送多个请求和响应，不会像 HTTP 1.1 中那样因为一个请求阻塞而影响其他请求（队头阻塞问题）。
- **头部压缩（Header Compression）**：使用 HPACK 算法对请求和响应头部进行压缩，减少了传输的数据量，尤其在头部信息较多的情况下效果明显。
- **服务器主动推送（Server Push）**：服务器可以在客户端请求之前主动推送资源到客户端，提高加载速度。


4. 引入了流（Stream）的概念，一个连接可以同时处理多个请求/响应流，可以优先处理重要的请求。
5. 支持请求的优先级和流控制，可以指定请求的重要性和资源分配。
6. 支持服务器推送的数据流共享同一个连接，减少了连接的数量和资源消耗。
    

#### HTTPS 的加密原理

HTTP 是**明文协议**，数据在 TCP 传输过程中不经过加密，容易被窃听和篡改。

HTTPS 是在 http 的基础上通过 SSL/TLS 协议确保请求的**机密性**, **完整性**和**可信性**，防止数据被中间人攻击者截获和篡改。以下是HTTPS的加密原理的基本过程：

SSL/TLS 协议中不同过程的实现：

- **机密性**数据在传输过程中被窃听, 由**混合加密过程**来实现。在 HTTPS 握手阶段，采用非对称加密帮助安全地交换对称密钥。在 HTTPS 建立连接时，客户端和服务器会协商一个**对称加密**的会话密钥，用于本次会话的数据加密。
- **完整性**确保数据在传输过程中未被篡改, 由 **哈希消息认证码**  HMAC 来实现。在数据包的加密和解密过程中，会利用对称密钥计算明文数据的校验和(哈希值)作为消息验证代码 MAC 与数据一起发送. 接收方用同样的方法计算 MAC, 并与接收到的MAC进行比较, 以确认数据在传输过程中是否被篡改。
- **可信性**是由数字证书来实现的，其中包含了服务器的公钥，证书颁发机构（CA）签名的信息，以验证证书的真实性来证明其身份。

#### https 连接建立过程，以及 SSL/TLS 工作原理(tls 握手，混合加密，数字证书验证)

HTTPS 是应用层协议，一般来说需要先完成 TCP 连接建立，然后走 TLS 握手过程后，才能建立通信安全的连接, 进行 HTTP 通信。

**RSA 握手过程(旧)**

介绍：传统的 TLS 握手基本都是使用 RSA 算法来实现**密钥交换**的，在将 TLS 证书部署服务端时，证书文件中包含一对公私钥，其中公钥会在 TLS 握手阶段传递给客户端，私钥则一直留在服务端，一定要确保私钥不能被窃取。在 RSA 密钥协商算法中，客户端会生成随机密钥，并使用服务端的公钥加密后再传给服务端。根据非对称加密算法，公钥加密的消息仅能通过私钥解密，这样服务端解密后，双方就得到了相同的密钥，再用它加密应用消息。
    
1. **第一次握手:** 客户端首先会发一个「**Client Hello**」消息, 消息里面有客户端使用的 **SSL/TLS 版本号**、支持的**加密算法**列表，以及生成的**随机数（用于生成会话密钥）** 等信息
2. **第二次握手:** 当服务端收到客户端的「Client Hello」消息后，会确认 TLS 版本号是否支持，并从**加密算法**组合列表中选择一个，以及生成**随机数（用于生成会话密钥）**。然后向客户端返回以下消息：
    - 返回「**Server Hello**」消息，消息里面有服务器确认的 **TLS 版本号**，**随机数**，**加密算法组合**。算法举例: 「**密钥交换算法(RSA) + 签名算法(RSA) + 对称加密算法 (AES)+ 摘要算法(SHA256)**」: TLS_RSA_WITH_AES_128_GCM_SHA256
    - 返回「**Server Certificate**」消息给客户端，这个消息里含有数字证书, 用于证明自己身份。只有证书合法，才代表服务端身份是可信的。
    - 返回「**Server Hello Done**」消息给客户端，目的是告诉客户端，我已经把该给你的东西都给你了，本次打招呼完毕。
    - 可选返回「**Server Key Exchange**」消息给客户端，获取加密套件需要的额外的密钥交换信息（例如使用DHE或ECDHE）。
    - 可选返回「**Certificate Request**」消息给客户端，请求客户端发送数字证书，进行身份验证。
3. **客户端校验服务端的数字证书**
    - 客户端会验证服务器所发送证书的签名，过程如下：
        - 客户端从证书中提取出证书签名和签名算法。
        - 获取包括证书的主体信息和公钥内容，但不包括签名部分。
        - 使用证书中指明的签名哈希算法计算证书主体信息的Hash值。
        - 通常浏览器和操作系统中集成了 CA 的公钥信息，使用签名算法和此公钥解密证书中的签名。并比较解密后的值与客户端计算的Hash值。如果两者匹配，说明签名有效，证书没有被篡改。
    - 客户端会验证服务器所发送证书的签发链，直到找到一个受信任的根证书为止。从服务器证书开始，检查其颁发者是否是受信任的CA，或由受信任的中间CA签发。验证中间证书的颁发者，逐级向上直到找到一个受信任的根证书。确保整个证书链中的所有证书都是有效的（未过期、未被吊销等）。
4. **第三次握手:**
    - 客户端生成一个新的**随机数 (*pre-master*)**，并用服务器的 **RSA 公钥**加密该随机数，发送「**Change Cipher Key Exchange**」消息给服务端。服务端收到后，用 **RSA 私钥解密**，得到客户端发来的随机数 (pre-master)。
        - 至此，**客户端和服务端双方都共享了三个随机数，分别是 Client Random、Server Random、pre-master**。
        - 双方根据已经得到的三个随机数，生成**会话密钥（Master Secret）**，它是对称密钥，用于对后续的 HTTP 请求/响应的数据加解密。
    - 生成完会话密钥后，然后客户端发一个「**Change Cipher Spec**」，告诉服务端开始使用加密方式发送消息。
    - 客户端再发一个「**Encrypted Handshake Message（Finishd）**」消息，把之前所有发送的数据做个摘要，再用会话密钥（master secret）加密一下，让服务器做个验证，验证加密通信是否可用和之前握手信息是否有被中途篡改过。
5. **第四次握手:**
    服务器也是同样的操作，发「**Change Cipher Spec**」和「**Encrypted Handshake Message**」消息，如果双方都验证加密和解密没问题，那么握手正式完成。

RSA缺点：**使用 RSA 密钥协商算法的最大问题是不支持前向保密**。因为客户端传递随机数（用于生成对称加密密钥的条件之一）给服务端时使用的是公钥加密的，服务端收到到后，会用私钥解密得到随机数。所以一旦服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解。
    
**ECDHE 握手过程(新)**
- **第一次握手:** 客户端首先会发一个「**Client Hello**」消息，消息里面有客户端使用的 TLS 版本号、支持的密码套件列表，以及生成的**随机数（*Client Random*）**。
- **第二次握手:** 当服务端收到客户端的「Client Hello」消息后，，会确认 TLS 版本号是否支持，和从密码套件列表中选择一个密码套件，以及生成**随机数（*Server Random*）**。
    - 返回「**Server Hello**」消息，消息里面有服务器确认的 TLS 版本号，也给出了一个**随机数（*Server Random*）**，然后从客户端的密码套件列表选择了一个合适的密码套件。密码套件举例: 「**密钥交换算法(ECDHE) + 签名算法(RSA) + 对称加密算法 (AES)+ 摘要算法(SHA384)**」: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
    - 发送「**Certificate**」消息给客户端，这个消息里含有数字证书, 用于证明自己身份。只有证书合法，才代表服务端身份是可信的。
    - 发送「**Server Key Exchange**」消息，这个消息里含有随机数, 使用的椭圆曲线、椭圆曲线基点 G、服务端椭圆曲线的公钥。
        - 选择了**名为 named_curve 的椭圆曲线**，选好了椭圆曲线相当于**椭圆曲线基点 G** 也定好了，这些都会公开给客户端；
        - 生成**随机数**作为服务端椭圆曲线的私钥，保留到本地；
        - 根据基点 G 和私钥计算出**服务端的椭圆曲线公钥**，这个会公开给客户端。
        - 为了保证这个椭圆曲线的公钥不被第三方篡改，服务端会用 RSA **签名算法**给服务端的椭圆曲线公钥做个签名。
    - 发送「**Server Hello Done**」消息给客户端，目的是告诉客户端，我已经把该给你的东西都给你了，本次打招呼完毕。
- **[客户端验证证书:](https://www.notion.so/f51ddacaf59e418798c51469a4c4b2e3?pvs=21)**（看上面）
- **第三次握手:**
    客户端会生成一个随机数作为客户端椭圆曲线的私钥，然后再根据服务端前面给的信息，生成**客户端的椭圆曲线公钥**，然后用「**Client Key Exchange**」消息发给服务端。
    
    至此，双方都有对方的椭圆曲线公钥、自己的椭圆曲线私钥、椭圆曲线基点 G。于是，双方都就计算出点（x，y），其中 x 坐标值双方都是一样的，前面说 ECDHE 算法时候，说 x 是会话密钥，**但实际应用中，x 还不是最终的会话密钥**。
    
    **最终的会话密钥，就是用「客户端随机数 + 服务端随机数 + x（ECDHE 算法算出的共享密钥） 」三个材料生成的**。
    
    TLS 设计者不信任客户端或服务器「伪随机数」的可靠性，为了保证真正的完全随机，把三个不可靠的随机数混合起来，那么「随机」的程度就非常高了，足够让黑客计算出最终的会话密钥，安全性更高。
    
    算好会话密钥后，客户端会发一个「**Change Cipher Spec**」消息，告诉服务端后续改用对称算法加密通信。
    
    接着，客户端会发「**Encrypted Handshake Message**」消息，把之前发送的数据做一个摘要，再用对称密钥加密一下，让服务端做个验证，验证下本次生成的对称密钥是否可以正常使用。
    
- **第四次握手:**
    最后，服务端也会有一个同样的操作，发「**Change Cipher Spec**」和「**Encrypted Handshake Message**」消息，如果双方都验证加密和解密没问题，那么握手正式完成。于是，就可以正常收发加密的 HTTP 请求和响应了。
        
- **RSA 和 ECDHE 握手过程的区别：**
    - RSA 密钥协商算法「不支持」前向保密，ECDHE 密钥协商算法「支持」前向保密；前向保密指的是长期使用的主密钥泄漏不会导致过去的会话密钥泄漏。 前向保密能够保护过去进行的通讯不受密码或密钥在未来暴露的威胁。
    - 使用了 RSA 密钥协商算法，TLS 完成四次握手后，才能进行应用数据传输，而对于 ECDHE 算法，客户端可以不用等服务端的最后一次 TLS 握手，就可以提前发出加密的 HTTP 数据，节省了一个消息的往返时间；
    - 使用 ECDHE， 在 TLS 第 2 次握手中，会出现服务器端发出的「Server Key Exchange」消息，而 RSA 握手过程没有该消息；

#### 对称, 非对称加密和混合加密的优缺点

- **对称加密的优缺点：** 对称加密是指加密和解密使用相同的密钥。
    - 优点：对称加密算法加密和解密速度快，计算效率高。
    - 缺点：对称加密需要共享密钥，如果密钥在传输过程中被拦截，数据的安全性就会受到威胁。此外，对称加密无法提供身份验证和密钥协商的机制。
- **非对称加密的优缺点：** 非对称加密（Asymmetric Encryption）使用一对密钥：公钥和私钥。公钥用于加密，私钥用于解密。
    - 优点：非对称加密使用公钥和私钥，公钥可以公开，私钥保密，提供了更好的安全性。非对称加密可以实现身份验证和密钥交换。
    - 缺点：非对称加密算法计算复杂，加密和解密速度较慢，相对于对称加密而言，计算开销较大。
- **混合使用对称和非对称加密的原因：**
    - 效率：**对称加密算法计算速度快，适合大量数据的加密和解密。** 而非对称加密算法计算速度慢，适合进行密钥交换和身份验证。通过混合使用对称和非对称加密，能够在保证安全性的同时提高效率。
    - 安全性：**通过使用非对称加密进行密钥交换**，确保了密钥在传输过程中的安全性。随后使用对称加密进行实际的数据传输，提供了更快速和高效的加密和解密过程。
    - 综合优势：混合使用对称和非对称加密结合了两者的优势，

#### 数字证书详细验证过程

**服务端证书获取**
    
数字证书都是由 CA （证书认证机构）签名，一般包含「公钥, 持有者信息, 证书认证机构（CA）的信息, 数字签名及算法, 证书有效期」等信息
- 首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；
- 然后 CA 会使用自己的私钥将该 Hash 值加密，生成证书的签名(Certificate Signature)；
- 最后将证书签名添加在文件证书上，形成数字证书；
**客户端对证书信任链进行验证**(当前证书->中间证书->根证书)
- 根证书是指操作系统或应用程序预装的受信任的根证书列表。这些证书是由可信任的证书颁发机构（CA）签发, 由操作系统或应用程序供应商预装，并定期更新。
- 客户端收到 baidu.com 的证书后，发现这个证书的签发者不是根证书，就无法根据本地已有的根证书中的公钥去验证 baidu.com 证书是否可信。于是，客户端根据 baidu.com 证书中的签发者，找到该证书的颁发机构是 “GlobalSign Organization Validation CA - SHA 256 - G 2”，然后向 CA 请求该中间证书。
- 请求到证书后发现 “GlobalSign Organization Validation CA - SHA 256 - G 2” 证书是由 “GlobalSign Root CA” 签发的，由于 “GlobalSign Root CA” 没有再上级签发机构，说明它是根证书，也就是自签证书。应用软件会检查此证书有否已预载于根证书清单上，如果有，则可以利用根证书中的公钥去验证 “GlobalSign Organization Validation CA - SHA 256 - G 2” 证书，如果发现验证通过，就认为该中间证书是可信的。
- “GlobalSign Organization Validation CA - SHA 256 - G 2” 证书被信任后，可以使用 “GlobalSign Organization Validation CA - SHA 256 - G 2” 证书中的公钥去验证 baidu.com 证书的可信性，如果验证通过，就可以信任 baidu.com 证书。

**证书有效性验证过程**

1. **获取签名信息**：
    - 每个数字证书包含一个签名字段，这个签名是上一级CA使用其私钥对证书内容（包括公钥、主体信息、有效期等）的哈希值进行加密得到的。
2. **提取证书的签名算法**：
    - 证书中包含签名算法信息，常见的有RSA、ECDSA等，以及使用的哈希函数（如SHA-256）。
3. **计算证书内容的哈希值**：
    - 客户端对证书内容（不包括签名本身）使用相同的哈希函数计算哈希值。这一步骤生成一个固定长度的哈希值，该值称为消息摘要。
4. **使用上一级CA的公钥解密签名**：
    - 客户端使用上一级CA的公钥对证书的签名字段进行解密，得到签名的哈希值。这个过程与加密相反，使用公钥解密出由私钥加密的哈希值。
5. **比较哈希值**：
    - 客户端将自己计算的证书内容哈希值与使用上一级CA公钥解密得到的签名哈希值进行比较。
    - 如果两者匹配，说明证书内容没有被篡改，并且确实是由上一级CA签发的。
    - 如果不匹配，说明证书内容可能被篡改或者证书签名不正确，客户端将认为证书无效。

#### 一个 TCP 连接中可以**发送和接收多个** HTTP 请求或响应吗

HTTP/1.1 存在一个问题，单个 TCP 连接在同一时刻只能处理一个请求. 在 HTTP/1.1 存在 Pipelining 技术可以完成这个多个请求同时发送，但是由于浏览器默认关闭，所以可以认为这是不可行的。

在 HTTP2 中由于 Multiplexing 特点的存在，多个 HTTP 请求可以在同一个 TCP 连接中并行进行。
    

#### 对同一主机**建立 TCP 连接的数量**有没有**限制**？

HTTP/1.1 没有多路传输, 当浏览器拿到一个有几十张图片的网页, 只开一个 TCP 连接顺序下载会很慢. 如果每个图片都开一个 TCP 连接进行 HTTP 请求, 电脑是难以承受的.

Chrome 最多允许对同一个 Host 建立六个 TCP 连接。不同的浏览器有一些区别。

如果图片都是 HTTPS 连接并且在同一个域名下，那么浏览器在 SSL 握手之后会和服务器商量能不能用 HTTP2，如果能的话就使用 Multiplexing 功能在这个连接上进行多路传输。

如果发现用不了 HTTP2 呢？或者用不了 HTTPS（现实中的 HTTP2 都是在 HTTPS 上实现的，所以也就是只能使用 HTTP/1.1）。那浏览器就会在一个 HOST 上建立多个 TCP 连接，连接数量的最大限制取决于浏览器设置，这些连接会在空闲的时候被浏览器用来发送新的请求，如果所有的连接都正在发送请求呢？那其他的请求就只能等等
    

#### HTTP 服务器缓存的作用

**原因**

- 缓解服务器压力；
- 降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。

**实现方法**

- 让代理服务器进行缓存；
- 让客户端浏览器进行缓存。

**如何保证缓存是最新的**

ax-age 指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。

max-age 指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间。

Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期

HTTP/1.1 通过 Cache-Control 首部字段来控制缓存。

**禁止进行缓存**

no-store 指令规定不能对请求或响应的任何一部分进行缓存。 `Cache-Control: no-store`

**强制确认缓存**

no-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应。 `Cache-Control: no-cache`
    

### 应用层信息存储与安全保证： Cookie 和 Session

 **Cookie:** HTTP 协议是**无状态**的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务，HTTP/1.1 引入 Cookie 来保存状态信息。

Cookie 特点：
- **工作方式**：Cookies 是小型的文本文件，由服务器发送到用户的浏览器，并存储在用户的本地计算机上。每次用户请求同一网站时，浏览器会将相关的 Cookies 发送回服务器, 于告知服务端两个请求是否来自同一浏览器。
- **存储位置**：以键值对的方式来存储 http 请求的状态信息，存储在用户的浏览器中，可以跨不同会话和访问保留。
**- 使用方式：** 服务端可以通过响应头中的 `Set-Cookie` 字段来对客户端写入 `Cookie` 。客户端可以通过请求头中的 `Cookie` 携带 Cookie 信息。容易被攻击窃取，不安全。
    
**Cookie 属性：**
- Expires： 过期时间日期
- Max-Age：过期时间间隔
- Domain 和 path：绑定的域名和路径
- Secure：限定 HTTPS 传输
- HttpOnly： 限定 HTTP 传输
        
Session 特点
    
**工作方式**：Session 是一种在服务器端存储用户信息的方式，通常基于唯一的会话标识（Session ID）。每个用户会话通常与一个唯一的会话ID相关联，该ID存储在 Cookies 或 URL 参数中。session 创建完之后，会把 session 的 id 发送给客户端，客户端再存储到浏览器中。这样客户端每次访问服务器时，都会带着 sessionid，服务器拿到 sessionid 之后，在内存找到与之对应的 session 这样就可以正常工作了。

**存储位置**：会话数据存储在服务器上，以键值对的形式保存在服务器的内存或持久化存储中（如数据库）。

**使用方式：** Session 数据可以用来存储用户状态信息（敏感信息），对客户端是不可见的，相对来说更安全，并在用户关闭浏览器或超过一定时间（如长时间不活动）后失效。

#### 使用 Session 维护用户登录状态的过程如下：

1. 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；
2. 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；
3. 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；
4. 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。

#### Session和cookie应该如何去选择（适用场景）？

- Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；
- Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；
- 对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。

### 传输层协议: **TCP 和 UDP**

#### TCP 和 UDP 的区别

TCP 和 UDP 的区别：是否提供**可靠的面向连接**的数据传输(连接稳定, 数据传输可靠, 流量控制, 拥塞控制, 数据有序)
- TCP 和 UDP 的应用场景不同：
    - TCP 网页浏览、电子邮件、文件传输
    - UDP 音频和视频流媒体、网络游戏)
- TCP 面向**连接**（如打电话要先拨号建立连接）; UDP是无连接的，即发送数据之前不需要建立连接
- TCP提供**可靠的服务**。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付
- TCP**面向字节流**，实际上是TCP把数据看成一连串无结构的字节流，发送方 TCP 会将数据放入“蓄水池”（缓存区），等到可以发送的时候就发送，不能发送就等着 TCP 会根据当前网络的拥塞状态来确定每个报文段的大小。; UDP是**面向报文**的，没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
- 每一条TCP连接只能是**点到点的**; UDP支持**一对一**，一对多，多对一和多对多的交互通信
- TCP首部**开销**20字节; UDP的首部开销小，只有8个字节
- TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道

####  **TCP头部中有哪些信息？**

- 序号（32bit）：传输方向上字节流的字节编号。初始时序号会被设置一个随机的初始值（ISN），之后每次发送数据时，序号值 = ISN + 数据在整个字节流中的偏移。假设A -> B且ISN = 1024，第一段数据512字节已经到B，则第二段数据发送时序号为1024 + 512。用于解决网络包乱序问题。
- 确认号（32bit）：接收方对发送方TCP报文段的响应，其值是收到的序号值 + 1。
- 首部长（4bit）：标识首部有多少个4字节 * 首部长，最大为15，即60字节。
- 标志位（6bit）：
    - URG：标志紧急指针是否有效。
    - ACK：标志确认号是否有效（确认报文段）。用于解决丢包问题。
    - PSH：提示接收端立即从缓冲读走数据。
    - RST：表示要求对方重新建立连接（复位报文段）。
    - SYN：表示请求建立一个连接（连接报文段）。
    - FIN：表示关闭连接（断开报文段）。
- 窗口（16bit）：接收窗口。用于告知对方（发送方）本方的缓冲还能接收多少字节数据。用于解决流控。
- 校验和（16bit）：接收端用CRC检验整个报文段有无损坏。

#### TCP 如何保障数据传输可靠性

TCP 给每个发送的数据包分配一个序列号，接收端收到数据后会发送确认消息给发送端，确认收到的数据的序列号。如果发送端在一定时间内未收到确认消息，则认为数据丢失，触发重传机制，重新发送数据。通过序列号和确认机制，TCP 可以确保数据的可靠传输。

#### TCP 如何设计连接的**流量控制**和**拥塞控制**的。

流量控制使用**滑动窗口机制**实现，用于确保发送方不会发送超过接收方处理能力的数据量，防止接收方缓冲区溢出。 
- 每个 TCP 连接都有一个发送窗口和接收窗口，发送窗口表示发送端可以发送的数据量，接收窗口表示接收端的缓冲区大小，用于指示接收端当前可以接收的数据量。
- 当接收方接收并处理了部分数据，会动态调整发送窗口和接收窗口的大小，控制发送端的发送速率，确保发送端和接收端之间的数据传输平衡，避免发送端发送过多的数据导致接收端缓冲区溢出。
- 当接收方的接收缓冲区满时，会在ACK报文中将窗口大小设置为零，通知发送方停止发送数据。同时，当接收窗口为零时，发送端会定期发送零窗口探测报文给接收端，探测接收方的窗口是否已经重新打开。如果连续多次探测（例如3次）未收到响应，可能会认为连接已经断开。

拥塞控制用于防止网络因过载而导致的性能下降。TCP的拥塞控制通过多种算法共同实现，包括慢启动、拥塞避免、快重传和快恢复。

**慢启动：** 

TCP 连接刚建立时，发送端会先以较小的发送窗口大小开始发送数据，然后逐渐增加发送窗口的大小，以指数级增长。这样可以在网络中逐渐探测网络的拥塞程度，避免突然发送大量数据导致网络拥塞。慢启动算法：
    1. 连接建好的开始先初始化拥塞窗口 cwnd 大小为 1，表明可以传一个 MSS 大小的数据。
    2. 每当收到一个 ACK，cwnd 大小加一，呈线性上升。
    3. 每当过了一个往返延迟时间 RTT(Round-Trip Time)，cwnd 大小直接翻倍，乘以 2，呈指数让升。
    4. 还有一个 ssthresh（slow start threshold），是一个上限，当 cwnd >= ssthresh 时，就会进入“拥塞避免过程”

**拥塞避免：**

一旦发送端确定网络的拥塞程度过了慢启动阈值后，会进入拥塞避免阶段，发送窗口的增长变得线性，缓慢的增加调整到网络的最佳值。发送端每收到一个确认消息，发送窗口只会增加一个 MSS（最大报文段长度）的大小，以控制发送速率，避免过度注入数据导致网络拥塞。拥塞避免算法:
        
- 当拥塞窗口大小 cwnd 大于等于慢启动阈值 ssthresh 后，就进入拥塞避免算法。
- 收到一个 ACK，则 cwnd = cwnd + 1 / cwnd
- 每当过了一个往返延迟时间 RTT，cwnd 大小加一。

**快速重传和快速恢复：**

当发送端连续收到三个重复的确认消息（指确认同一个序列号的数据），它会认为网络发生拥塞，并触发快速重传和快速恢复机制。发送端会立即重传丢失的数据包，而不等待超时时间的到达，并将拥塞窗口减半，以降低发送速率。快速重传 Fast Retransmit 算法：
- cwnd 大小缩小为当前的一半
- ssthresh 设置为缩小后的 cwnd 大小
- 然后进入快速恢复算法 Fast Recovery。

在快速重传后，快速恢复机制使得发送端不需要重新进入慢启动阶段，而是将拥塞窗口设置为当前拥塞窗口的一半，继续线性增加发送窗口的大小。快速恢复算法：
    
- cwnd = cwnd + 3 MSS，加 3 MSS 的原因是因为收到 3 个重复的 ACK。
- 重传 DACKs 指定的数据包。
- 如果再收到 DACKs，那么 cwnd 大小增加一。
- 如果收到新的 ACK，表明重传的包成功了，那么退出快速恢复算法。将 cwnd 设置为 ssthresh，然后进入拥塞避免算法。

**超时重传:**

超时重传是TCP协议中用于处理丢失数据包的机制。当发送方发送数据包后，没有收到对应的确认（ACK）时，就会启动超时重传机制，即重新发送之前发送的数据包。
- 如果超时时间到了仍未收到确认，则认为数据包丢失，启动超时重传机制。
- 发送方重新发送之前发送的数据包。
- 重传后，发送方通常会更新超时时间，以适应网络环境的变化。可能会采用指数增长的方式来调整超时时间。
    

#### TCP 如何保障连接的稳定性: 依赖于   **三次握手**    建立稳定连接, 和    **四次挥手**    安全释放连接.

- 三次握手过程
    1. 客户端向服务器发送一个 TCP 数据包， 其中包含**SYN**（同步）标志位， 随机的**初始序列号X。**客户端进入 **SYN-SENT 状态**，等待服务器的响应。如果服务器端不能连接，则直接进入 **CLOSED** 状态。
    2. 服务器向客户端回应一个 TCP 数据包，其中包含 SYN 和ACK 标志位，无数据，随机的**初始序列号Y，确认号X+1。**服务器进入 **SYN_RCVD** 状态。
    3. 客户端向服务器发送一个 TCP 数据包，其中包含 ACK 标志位，无数据，**序列号X+1，确认号Y+1；**客户端进入 **ESTABLISHED** 状态。服务器端收到客户端的 ACK 之后进入 **ESTABLISHED** 状态。

- 四次挥手过程
    1. 客户端向服务器发送一个 TCP 数据包，其中包含 FIN 标志，没有数据，序号值 x+1, 和确认值 y+1.  客户端进入**FIN_WAIT_1**状态。
    2. 服务端向客户端发送一个 TCP 数据包，其中包含 ACK 标志，没有数据，序号值 y+1, 和确认值 x+2. 服务端进入 **CLOSE_WAIT** 状态。客户端收到后进入 **FIN_WAIT_2** 状态.
    3. 主机进程进入等待终止状态， 还可以发送数据， 假设为 length 长度。
    4. 服务端向客户端发送一个 TCP 数据包，其中包含 FIN 标志，没有数据，序号值 y+1+length, 和确认值 x+2. 服务端进入 **LAST_ACK** 状态。
    5. 客户端向服务器发送一个 TCP 数据包，其中包含 ACK 标志，没有数据，序号值 x+2 , 和确认值 y+2+length. 客户端主动进入 **TIME_WAIT** 状态. 服务端收到后进入 **CLOSED** 状态. 
    6. 客户端等待 2 倍的MSL，最大报文寿命, 进入进入 **CLOSED** 状态。

#### 为什么要三次握手而不是两次握手

- 两次握手只能确认服务端的连接可靠性，而无法确认主机的连接可靠性(例如接收到的客户端请求是被阻塞后的旧连接或重复连接)。
- 三次握手可以**避免资源浪费**
    - **阻止无效的旧连接**（引起原因：客户端宕机和历史请求连接堵塞）
            当客户端先发送了 SYN 报文后，客户端发生宕机，并且这个 SYN 报文还被网络阻塞了。此时客户端重启后会重新向服务端建立连接，发送新的 SYN 报文，并带有新的初始化序号。这种情况会出现「旧 SYN 报文」比「最新的 SYN 」 报文早到达情况。
            如果是两次握手的话, 当「服务端」先收到的是旧的 SYN 报文，并对其进行回应， 发出响应报文后, 会直接进入 ESTABLISHED 状态。 此时意味着「服务端」可以给对方发送数据了， 并可能会直接发送数据.  但是「客户端」在验证响应报文的序号与自己发出的最新的SYN 报文的序号时，会发现连接时异常的, 直接断开这次连接， 使得「服务端」的资源有了浪费， 因为它可能正在发送数据.
            如果是三次握手的话, 需要「服务端」接收到「客户端」第三次确认后才进入 ESTABLISHED 状态。因此即使「服务端」先收到了旧的 SYN 报文，也会等待「客户端」确认前两次握手正常后才建立连接，发送数据。
    - **防止无效的重复连接**（引起原因：历史请求连接堵塞）
            当客户端先发送了 SYN 报文后，如果此 SYN 报文被网络阻塞了，服务端无法及时的对这次连接建立请求进行回应。此时客户端会在等待一段时间后，重新发送一样的 SYN 报文。这种情况会出现多个相同的报文都到达「服务端」情况。
            如果是两次握手的话，「服务端」会在收到第一个 SYN 报文后回复响应报文。 并且由于「服务端」无法确认自己的响应报文是否正常发送给了「客户端」，也只能在后续收到相同的 SYN 报文后， 为每次申请都建立连接。
- 三次握手才可以**同步双方的初始序列号**
        TCP的可靠传输依赖于超时重传， 流量控制，拥塞控制和按序发送机制。其中按序发送机制的话，要求「客户端」和「服务端」都必须维护两个序号和确认号。
        如果是两次握手的话，只保证了一方的初始序列号能被对方成功接收，无法保证双方的初始序列号都能被确认接收。

#### 三次握手过程中可以携带数据吗？

其实第三次握手的时候，是可以携带数据的。但是，**第一次、第二次握手不可以携带数据**

为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。

也就是说，**第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。**
        

#### 为什么要四次挥手

因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中**ACK报文是用来应答的，SYN报文是用来同步的**。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，"你发的FIN报文我收到了"。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。

任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。
        

#### 挥手的 **TIME_WAIT 状态 (2MSL等待状态)** 的作用

客户端在发送完最后一个确认报文后，进入 **TIME_WAIT**  状态，2MSL 后才进入关闭状态, 是为了避免服务端因为没有收到主机的确认报文段，从而导致无限重传。

每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。

对一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）。

这种2MSL等待的另一个结果是这个TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。这个连接只能在2MSL结束后才能再被使用。

为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。
  

#### 什么是TCP粘包/拆包(封包)？发生的原因？

**TCP粘包**是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。

原因：
- 由TCP**连接复用**造成的粘包问题。
- 因为TCP默认会使用 **Nagle 算法**，此算法会导致粘包问题。
    - 只有上一个分组得到确认，才会发送下一个分组；
    - 收集多个小分组，在一个确认到来时一起发送。
- **数据包过大**造成的粘包问题。
- 流量控制，**拥塞控制**也可能导致粘包。
- **接收方不及时接收缓冲区的包，造成多个包接收**
**解决**：
1. **Nagle算法**问题导致的，需要结合应用场景适当关闭该算法
2. 尾部标记序列。通过特殊标识符表示数据包的边界，例如\n\r，\t，或者一些隐藏字符。
3. 头部标记分步接收。在TCP报文的头部加上表示数据长度。
4. 应用层发送数据时**定长**发送。

**封包(拆包)** 就是在发送数据报的时候为每个TCP数据包加上一个包头，将数据报分为包头和包体两个部分。包头是一个固定长度的结构体，里面包含该数据包的总长度。

**原因：**
1、应用程序写入数据的字节大小大于套接字发送缓冲区的大小.
2、进行 MSS 大小的TCP分段。( MSS=TCP报文段长度-TCP首部长度)
3、以太网的 payload 大于MTU进行 IP 分片。（ MTU指：一种通信协议的某一层上面所能通过的最大数据包大小。）
**解决：**
1、消息定长。
2、在包尾部增加回车或者空格符等特殊字符进行分割
3、将消息分为消息头和消息尾
4、使用其它复杂的协议，如RTMP协议等。

#### **常见TCP的连接状态有哪些？**

- CLOSED：初始状态。
- LISTEN：服务器处于监听状态。
- SYN_SEND：客户端socket执行CONNECT连接，发送SYN包，进入此状态。
- SYN_RECV：服务端收到SYN包并发送服务端SYN包，进入此状态。
- ESTABLISH：表示连接建立。客户端发送了最后一个ACK包后进入此状态，服务端接收到ACK包后进入此状态。
- FIN_WAIT_1：终止连接的一方（通常是客户机）发送了FIN报文后进入。等待对方FIN。
- CLOSE_WAIT：（假设服务器）接收到客户机FIN包之后等待关闭的阶段。在接收到对方的FIN包之后，自然是需要立即回复ACK包的，表示已经知道断开请求。但是本方是否立即断开连接（发送FIN包）取决于是否还有数据需要发送给客户端，若有，则在发送FIN包之前均为此状态。
- FIN_WAIT_2：此时是半连接状态，即有一方要求关闭连接，等待另一方关闭。客户端接收到服务器的ACK包，但并没有立即接收到服务端的FIN包，进入FIN_WAIT_2状态。
- LAST_ACK：服务端发动最后的FIN包，等待最后的客户端ACK响应，进入此状态。
- TIME_WAIT：客户端收到服务端的FIN包，并立即发出ACK包做最后的确认，在此之后的2MSL时间称为TIME_WAIT状态。

#### **什么是半连接队列？**

服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个**队列**里，我们把这种队列称之为**半连接队列**。

当然还有一个**全连接队列**，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。

这里在补充一点关于**SYN-ACK 重传次数**的问题： 服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。 注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s......

#### TCP 一对一信道，服务器怎么同时与多个客户端建立连接。

1. **多进程或多线程模型**：
    - 当服务器接收到新的客户端连接请求时，它会创建一个新的进程或线程来处理这个连接。
    - 每个进程或线程都独立地处理与各自客户端的交互。
    - 这种模型能够实现真正的并行处理，但会随着连接数增加而导致资源（如内存和CPU）的过度消耗。
2. **事件驱动或异步 I/O 模型**：
    - 在这种模型中，服务器使用单一线程处理所有连接。
    - 当数据从任何客户端到达时，服务器的事件循环会被触发，然后处理这些数据。
    - 这种模型非常适合大量的、短时活跃的连接，因为它避免了多进程或多线程的开销。
    - Node.js 就是使用这种模型的一个例子。
3. **多路复用模型**（如 **`select`**、**`poll`**、**`epoll`**、**`kqueue`** 等）：
    - 服务器使用一个线程监视多个客户端连接。
    - 使用系统调用（如 **`select`** 或 **`epoll`**）来检测多个文件描述符的活动。
    - 当某个客户端有数据到达或处于可写状态时，服务器会被通知并处理这些事件。
    - 这种模型结合了多线程/多进程和事件驱动的优势，允许单一线程高效地处理大量连接。
4. **组合模型**：
    - 在某些复杂的场景下，服务器可能会结合上述几种模型来达到最佳效果。
    - 例如，它可能使用多个线程，每个线程都采用事件驱动模型来处理一部分客户端连接。

#### **服务器出现大量 close_wait 的连接的原因是什么？有什么解决方法？**

close_wait 状态是在TCP四次挥手的时候收到FIN但是没有发送自己的FIN时出现的，服务器出现大量close_wait状态的原因有两种：

- 服务器内部业务处理占用了过多时间，都没能处理完业务；或者还有数据需要发送；或者服务器的业务逻辑有问题，没有执行 close() 方法
- 服务器的父进程派生出子进程，子进程继承了socket，收到FIN的时候子进程处理但父进程没有处理该信号，导致 socket 的引用不为0无法回收

处理方法：

- 停止应用程序
- 修改程序里的bug

### 传输层工具: **Socket**

#### Socket 通信流程:

- 1.服务器端创建一个Socket对象，并绑定到一个特定的IP地址和端口号上，以侦听等待客户端的连接请求。
    
    ```cpp
    #include <iostream>
    #include <sys/socket.h>
    #include <netinet/in.h>
    #include <unistd.h>
    
    int main() {
        // 创建套接字
        int serverSocket = socket(AF_INET, SOCK_STREAM, 0);
    
        // 绑定地址和端口
        sockaddr_in serverAddress{};
        serverAddress.sin_family = AF_INET;
        serverAddress.sin_port = htons(8080);
        serverAddress.sin_addr.s_addr = INADDR_ANY;
        bind(serverSocket, (struct sockaddr*)&serverAddress, sizeof(serverAddress));
    
        // 监听连接请求
        listen(serverSocket, 5);
    
        while (true) {
            // 接受客户端连接
            sockaddr_in clientAddress{};
            socklen_t clientAddressLength = sizeof(clientAddress);
            int clientSocket = accept(serverSocket, (struct sockaddr*)&clientAddress, &clientAddressLength);
    
            // 处理客户端请求
            char buffer[1024];
            ssize_t bytesRead = recv(clientSocket, buffer, sizeof(buffer), 0);
    
            // 发送响应给客户端
            const char* response = "Hello, client!";
            send(clientSocket, response, strlen(response), 0);
    
            // 关闭客户端套接字
            close(clientSocket);
        }
    
        // 关闭服务端套接字
        close(serverSocket);
    
        return 0;
    }
    ```
    
- 2.客户端创建 Socket 并指定IP地址和端口号连接服务器，服务器接受连接请求并创建新的Socket与客户端通信。
    
    ```cpp
    #include <iostream>
    #include <sys/socket.h>
    #include <netinet/in.h>
    #include <arpa/inet.h>
    #include <unistd.h>
    
    int main() {
        // 创建套接字
        int clientSocket = socket(AF_INET, SOCK_STREAM, 0);
    
        // 设置服务端地址和端口
        sockaddr_in serverAddress{};
        serverAddress.sin_family = AF_INET;
        serverAddress.sin_port = htons(8080);
        inet_pton(AF_INET, "server_ip", &(serverAddress.sin_addr));
    
        // 连接到服务端
        connect(clientSocket, (struct sockaddr*)&serverAddress, sizeof(serverAddress));
    
        // 发送请求给服务端
        const char* request = "Hello, server!";
        send(clientSocket, request, strlen(request), 0);
    
        // 接收服务端的响应
        char buffer[1024];
        ssize_t bytesRead = recv(clientSocket, buffer, sizeof(buffer), 0);
    
        // 处理响应
        std::cout << "Response from server: " << buffer << std::endl;
    
        // 关闭套接字
        close(clientSocket);
    
        return 0;
    }
    ```
    
- 3.双方通过读写Socket来进行数据传输，通信结束后关闭Socket连接, 释放相关资源。

#### Socket **建立 TCP 服务器**流程

![Untitled](软件工程师.assets/Untitled%2071.png)

- 服务器：
    - 创建socket -> int socket(int domain, int type, int protocol);
        - domain：协议域，决定了socket的地址类型，IPv4为AF_INET。
        - type：指定socket类型，SOCK_STREAM为TCP连接。
        - protocol：指定协议。IPPROTO_TCP表示TCP协议，为0时自动选择type默认协议。
    - 绑定socket和端口号 -> int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
        - sockfd：socket返回的套接字描述符，类似于文件描述符fd。
        - addr：有个sockaddr类型数据的指针，指向的是被绑定结构变量。
        
        ```
            // IPv4的sockaddr地址结构
            struct sockaddr_in {
                sa_family_t sin_family;    // 协议类型，AF_INET
                in_port_t sin_port;    // 端口号
                struct in_addr sin_addr;    // IP地址
            };
            struct in_addr {
                uint32_t s_addr;
            }
        
                @阿秀: 代码已成功复制到剪贴板
        
        ```
        
        123456789
        
        - addrlen：地址长度。
    - 监听端口号 -> int listen(int sockfd, int backlog);
        - sockfd：要监听的sock描述字。
        - backlog：socket可以排队的最大连接数。
    - 接收用户请求 -> int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
        - sockfd：服务器socket描述字。
        - addr：指向地址结构指针。
        - addrlen：协议地址长度。
        - 注：一旦accept某个客户机请求成功将返回一个全新的描述符用于标识具体客户的TCP连接。
    - 从socket中读取字符 -> ssize_t read(int fd, void *buf, size_t count);
        - fd：连接描述字。
        - buf：缓冲区buf。
        - count：缓冲区长度。
        - 注：大于0表示读取的字节数，返回0表示文件读取结束，小于0表示发生错误。
    - 关闭socket -> int close(int fd);
        - fd：accept返回的连接描述字，每个连接有一个，生命周期为连接周期。
        - 注：sockfd是监听描述字，一个服务器只有一个，用于监听是否有连接；fd是连接描述字，用于每个连接的操作。
- 客户机：
    - 创建socket -> int socket(int domain, int type, int protocol);
    - 连接指定计算机 -> int connect(int sockfd, struct sockaddr* addr, socklen_t addrlen);
        - sockfd客户端的sock描述字。
        - addr：服务器的地址。
        - addrlen：socket地址长度。
    - 向socket写入信息 -> ssize_t write(int fd, const void *buf, size_t count);
        - fd、buf、count：同read中意义。
        - 大于0表示写了部分或全部数据，小于0表示出错。
    - 关闭oscket -> int close(int fd);
        - fd：同服务器端fd。

#### Socket 的阻塞模式

阻塞I/O模式(同步操作)会在执行I/O操作时阻塞应用程序的执行，直到操作完成，而非阻塞I/O模式会立即返回，应用程序可以继续执行其他任务。默认阻塞. 阻塞I/O模式在等待I/O操作完成期间，会让CPU处于空闲状态。

#### Socket 的I/O复用:

- select 基于轮询, 使用 fd_set 结构体来存储需要监听的 Socket 文件描述符集合。当调用select函数时，它会将需要监听的Socket文件描述符集合传递给内核。内核会阻塞等待，直到集合中的任何一个文件描述符上有I/O事件发生时才返回。返回后，可以通过遍历fd_set集合来确定哪些文件描述符有I/O事件发生，并进行相应的处理。
- poll 基于轮询, 使用 pollfd 结构体数组来存储需要监听的Socket和相应的事件。当调用poll函数时，它会将需要监听的 Socket 和相应的事件传递给内核。内核会阻塞等待，直到数组中的任何一个Socket上有I/O事件发生时才返回。返回后，可以遍历pollfd数组来确定哪些Socket有I/O事件发生，并进行相应的处理。
- epoll, 基于事件唤醒回调机制, 使用一个内核维护的红黑树（rbtree）来存储需要监听的Socket和相应的事件。每个节点表示一个Socket和事件，通过节点的key和value来存储相关信息。当创建 epoll 实例时，内核会分配一个红黑树和一个用于存储就绪事件的链表。通过 epoll_ctl 函数可以将需要监听的Socket和相应的事件注册到红黑树中。当调用 epoll_wait 函数时，内核会阻塞等待，直到有事件发生时才返回。返回后，可以遍历就绪事件链表来确定具体发生事件的Socket，并进行相应的处理。

#### Socket 长连接:

是指在网络通信中，客户端与服务器之间建立的连接在通信完成后没有使其立即关闭连接, 而是将连接继续持续保持一段较长的时间的过程. 减少服务器端因频繁地建立和断开连接的资源消耗, 避免重新进行握手和认证的过程.

#### socket 监听的端口**怎么判断这个端口是TCP的还是UDP的**

客户端程序运行时可以通过 `int sockfd = socket(AF_INET, SOCK_DGRAM, 0);` 指定 `SOCK_DGRAM` 或 `SOCK_STREAM` 来创建UDP或TCP类型的套接字

在服务端可以使用**`getsockopt`**函数, 通过使用**`SOL_SOCKET`**选项中的**`SO_TYPE`**来获取套接字类型。 `getsockopt(sockfd, SOL_SOCKET, SO_TYPE, &opt, &optlen)` 

如果**`SO_TYPE`**返回值 `opt` 为**`SOCK_STREAM`**，那么这个套接字是TCP。如果返回值为**`SOCK_DGRAM`**，那么这个套接字是UDP。
    

#### 常见端口，端口有效范围？

- **HTTP (80)**：用于传输超文本传输协议（HTTP）数据，用于Web服务。
- **HTTPS (443)**：用于传输加密的超文本传输协议（HTTPS）数据，用于安全的Web服务。
- **SSH (22)**：用于安全的远程登录会话。
- **FTP (20, 21)**：用于文件传输协议（FTP）的数据传输和控制。
- **SMTP (25)**：用于简单邮件传输协议（SMTP），用于发送电子邮件。
- **POP3 (110)**：用于邮局协议版本3（POP3），用于接收电子邮件。
- **IMAP (143)**：用于Internet消息访问协议（IMAP），也用于接收电子邮件。

- **系统端口**：0到1023端口号被称为系统端口或知名端口，通常被一些常见的网络服务使用。
- **用户端口**：1024到49151端口号被称为用户端口或登记端口，通常由应用程序使用。
- **动态或私有端口**：49152到65535端口号被称为动态或私有端口，通常由客户端应用程序使用，用于临时通信。

### 网络层协议: **ICMP**

互联网控制消息协议 (ICMP) 是一组通信规则，设备使用这些规则在网络中传达数据传输错误。在发送方和接收方之间的消息交换中，可能会出现某些意外错误。例如，消息可能太长，或者数据包可能无法按顺序到达，因此接收方无法汇编。在这种情况下，接收方使用 ICMP 向发送方发送错误消息并请求重新发送消息。

互联网控制消息协议 (ICMP) 通常与其他网络协议（如 TCP/IP 或用户数据报协议 (UDP)）一起使用。发生某些网络事件时，主机和路由器会交换 ICMP 消息或 ICMP 数据包。

ICMP 数据包包括 ICMP 数据包标头和 ICMP 数据部分。

#### **ICMP 数据包标头**

ICMP 标头包含有关数据包类型、数据包代码、校验和和标识符的信息。ICMP 数据包发送后，消息接收方将读取标头信息。它将根据数据包的类型采取适当的操作。

例如，如果类型为回显请求，则接收方将发送包含相同数据的回显回复。如果收到“目的地不可达”类型的数据包，则接收方会回复一个类似类型的数据包。

#### **ICMP 数据部分**

ICMP 消息中的数据部分包括目的地的 IP 地址或故障原因等信息。它还包含用于识别错误的错误代码或数字代码。

下面是一些示例：

- 目的地不可达（类型 3）代码表示网络上不存在该接收方设备
- 重定向（类型 5）代码会向另一台路由器发送一条消息，表明有更好的到达目的地的路由
- 回显请求和回显回复（类型 8 和 10）代码测试设备之间的连接性
- 超时消息显示数据包已超过到达目的地的最大时间
- 参数问题消息指示路由器何时遇到 IP 字段标头问题
- 当路由器遇到拥塞并且需要限制其接收的数据包数量时，会发送“源点抑制”消息

#### **ICMP 与 TCP 之间有什么区别？**

TCP 是一种面向连接的协议，用于进行可靠的、经过错误检查的数据传输。它通常用于网页浏览、电子邮件、远程登录和文件传输应用程序。TCP 需要握手，即在发送方和接收方之间建立信任和身份验证的一系列消息。TCP 可保证消息送达。

相比之下，互联网控制消息协议 (ICMP) 是一种无连接协议。它不保证消息送达。由于 ICMP 仅用于错误报告，因此 ICMP 消息也比 TCP 数据包小。

ICMP 和 TCP 结合使用，以确定 TCP 传输失败的原因。

### 数据链路层协议: **ARP 和 RARP 和 PPP**

- **ARP 地址解析协议:** 根据IP地址获取物理地址
- **RARP 反向地址转换协议:** 根据物理地址获取IP地址
    
    概括： 反向地址转换协议，网络层协议，RARP与ARP工作方式相反。 RARP使只知道自己硬件地址的主机能够知道其IP地址。RARP发出要反向解释的物理地址并希望返回其IP地址，应答包括能够提供所需信息的RARP服务器发出的IP地址。 原理： (1)网络上的每台设备都会有一个独一无二的硬件地址，通常是由设备厂商分配的MAC地址。主机从网卡上读取MAC地址，然后在网络上发送一个RARP请求的广播数据包，请求RARP服务器回复该主机的IP地址。
    
    (2)RARP服务器收到了RARP请求数据包，为其分配IP地址，并将RARP回应发送给主机。
    
    (3)PC1收到RARP回应后，就使用得到的IP地址进行通讯。
    
- **PPP 点对点协议:**  主要是用来通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共通的解决方案

### DNS 相关问题（DNS劫持，DNS污染，DNS域名类型）

#### DNS 中常见的安全威胁概念(缓存污染, 劫持,欺骗,攻击,隧道中间人攻击)

- **DNS 缓存污染**：攻击者向 DNS 服务器注入错误的 DNS 记录，从而导致用户被重定向到恶意网站或服务。
    - DNS查询通常基于的UDP是无连接不可靠的协议，因此DNS的查询非常容易被篡改，通过对UDP端口53上的DNS查询进行入侵检测，一经发现与关键词相匹配的请求则立即伪装成目标域名的解析服务器（NS，Name Server）给查询者返回虚假结果。
- **DNS 劫持**：通过劫持了DNS服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，从而导致用户被重定向到恶意网站或服务。
    - 对于DNS劫持，可以采用使用国外免费公用的DNS服务器解决。例如OpenDNS（208.67.222.222）或GoogleDNS（8.8.8.8）。
- **DNS 欺骗**：攻击者使用欺骗性技术让受害者的计算机相信恶意 DNS 服务器是合法的 DNS 服务器，从而导致用户被重定向到恶意网站或服务。
- **DNS 放大攻击**：*攻击者利用易受攻击的 DNS 服务器来放大 DNS 查询流量，从而淹没目标服务器或网络。
- **DNS 隧道**：攻击者通过 DNS 协议隧道其他类型的流量，如命令和控制通信或数据渗透。
- **中间人 (MitM) 攻击**：攻击者拦截 DNS 查询并在用户和权威 DNS 服务器之间进行修改，从而重定向用户到恶意网站或服务。
- **域名系统安全扩展 (DNSSEC) 欺骗**：攻击者创建虚假的 DNSSEC 记录，从而可以伪造合法网站的 DNS 记录并重定向用户到恶意网站或服务。

#### DNS域名系统的不同类型有哪些？

- **A 记录**： 将域名映射到 IPv4 地址。
- **AAAA 记录**： 将域名映射到 IPv6 地址。
- **CNAME 记录**： 将别名（规范名称）映射到另一个域名。
- **MX 记录**： 将域名映射到邮件服务器。
- **NS 记录**： 将域名映射到权威 DNS 服务器。
- **TXT 记录**： 存储与域名关联的文本信息。
- **SRV 记录**： 指定特定服务的服务器。
- **PTR 记录**： 将 IP 地址反向映射到域名（用于反向 DNS 查询）。
- **SOA 记录**： 存储有关 DNS 区域的元数据，例如起始权限服务器、区域序列号和刷新间隔。

### **SQL注入攻击了解吗？**

攻击者在HTTP请求中注入恶意的SQL代码，服务器使用参数构建数据库SQL命令时，恶意SQL被一起构造，并在数据库中执行。用户登录，输入用户名 lianggzone，密码‘ or ‘1’=’1 ，如果此时使用参数构造的方式，就会出现 select * from user where name = ‘lianggzone’ and password = ‘’ or ‘1’=‘1’不管用户名和密码是什么内容，使查询出来的用户列表不为空。如何防范SQL注入攻击使用预编译的 PrepareStatement 是必须的，但是一般我们会从两个方面同时入手。 
Web端 
1）有效性检验。 
2）限制字符串输入的长度。
服务端 
1）不用拼接SQL字符串。 
2）使用预编译的PrepareStatement。 
3）有效性检验。

(为什么服务端还要做有效性检验？第一准则，外部都是不可信的，防止攻击者绕过Web端请求) 4）过滤SQL需要的参数中的特殊字符。比如单引号、双引号。

### **DDos 攻击了解吗？**

客户端向服务端发送请求链接数据包，服务端向客户端发送确认数据包，客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认没有彻底根治的办法，除非不使用TCP 

DDos 预防： 
1. 限制同时打开SYN半链接的数目 
2. 缩短SYN半链接的Time out 时间 
3. 关闭不必要的服务

### **MTU和MSS分别是什么？**

MTU：maximum transmission unit，最大传输单元，由硬件规定，如以太网的MTU为1500字节。

MSS：maximum segment size，最大分节大小，为TCP数据包每次传输的最大数据分段大小，一般由发送端向对端TCP通知对端在每个分节中能发送的最大TCP数据。MSS值为MTU值减去IPv4 Header（20 Byte）和TCP header（20 Byte）得到。

### **Ping命令基于什么协议？原理是什么？**

ping是基于网络层的ICMP协议实现的。通过向对方发送一个**ICMP回送请求报文**，如果对方主机可达的话会收到该报文，并响应一个**ICMP回送回答报文**。

### **SYN攻击是什么？**

**服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的**，所以服务器容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。

检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。

**常见的防御 SYN 攻击的方法有如下几种：**

- 缩短超时（SYN Timeout）时间
- 增加最大半连接数
- 过滤网关防护
- SYN cookies技术

### **XSS攻击是什么？**

跨站点脚本攻击，指攻击者通过篡改网页，嵌入恶意脚本程序，在用户浏览网页时，控制用户浏览器进行恶意操作的一种攻击方式。如何防范XSS攻击 1）前端，服务端，同时需要字符串输入的长度限制。 2）前端，服务端，同时需要对HTML转义处理。将其中的”<”,”>”等特殊字符进行转义编码。 防 XSS 的核心是必须对输入的数据做过滤处理。

### **CSRF攻击？你知道吗？**

跨站点请求伪造，指攻击者通过跨站请求，以合法的用户的身份进行非法操作。可以这么理解CSRF攻击：攻击者盗用你的身份，以你的名义向第三方网站发送恶意请求。CRSF能做的事情包括利用你的身份发邮件，发短信，进行交易转账，甚至盗取账号信息。

**如何防范CSRF攻击**
安全框架，例如Spring Security。 token机制。在HTTP请求中进行token验证，如果请求中没有token或者token内容不正确，则认为CSRF攻击而拒绝该请求。 验证码。通常情况下，验证码能够很好的遏制CSRF攻击，但是很多情况下，出于用户体验考虑，验证码只能作为一种辅助手段，而不是最主要的解决方案。 referer识别。在HTTP Header中有一个字段Referer，它记录了HTTP请求的来源地址。如果Referer是其他网站，就有可能是CSRF攻击，则拒绝该请求。但是，服务器并非都能取到Referer。很多用户出于隐私保护的考虑，限制了Referer的发送。在某些情况下，浏览器也不会发送Referer，例如HTTPS跳转到HTTP。 1）验证请求来源地址； 2）关键操作添加验证码； 3）在请求地址添加 token 并验证。

### **文件上传漏洞是如何发生的？**

文件上传漏洞，指的是用户上传一个可执行的脚本文件，并通过此脚本文件获得了执行服务端命令的能力。 许多第三方框架、服务，都曾经被爆出文件上传漏洞，比如很早之前的Struts2，以及富文本编辑器等等，可被攻击者上传恶意代码，有可能服务端就被人黑了。

**如何防范文件上传漏洞**
文件上传的目录设置为不可执行。

1）判断文件类型。在判断文件类型的时候，可以结合使用MIME Type，后缀检查等方式。因为对于上传文件，不能简单地通过后缀名称来判断文件的类型，因为攻击者可以将可执行文件的后缀名称改为图片或其他后缀类型，诱导用户执行。

2）对上传的文件类型进行白名单校验，只允许上传可靠类型。

3）上传的文件需要进行重新命名，使攻击者无法猜想上传文件的访问路径，将极大地增加攻击成本，同时向shell.php.rar.ara这种文件，因为重命名而无法成功实施攻击。

4）限制上传文件的大小。

5）单独设置文件服务器的域名。

### **如果web页面卡了，怎么定位问题所在？**

1. **开发者工具**：大多数现代浏览器都提供了开发者工具，你可以使用其中的“网络”和“性能”选项卡来查看加载缓慢的资源或执行缓慢的脚本。
2. **JavaScript 性能**：使用开发者工具的“性能”选项卡来录制页面加载和运行时的性能。这可以帮助你找到导致卡顿的 JavaScript 函数或事件。
3. **静态资源加载**：在“网络”选项卡中，检查是否有加载缓慢或失败的资源，如图片、CSS、JavaScript 文件等。
4. **Web 服务器性能**：检查 Web 服务器的性能和响应时间。可能需要查看服务器的日志或使用监控工具。
5. **第三方内容**：考虑是否有嵌入的第三方内容或服务导致页面卡顿，例如广告、统计脚本或其他外部资源。
6. **浏览器兼容性**：检查问题是否仅在某些浏览器或版本中出现。

### 示例：用户登陆具体的流程

1. 用户打开登录页面：用户在应用程序或系统中打开登录页面或界面。
2. 输入用户名和密码：用户在登录页面中输入其注册或分配的用户名和相应的密码。有些系统可能还要求用户提供其他身份验证信息，如验证码、安全问题等。
3. 提交登录信息：用户点击登录按钮或执行相应的登录操作，将用户名和密码等登录信息提交给后端服务器或认证服务器。
4. 服务器验证：后端服务器或认证服务器接收到用户提交的登录信息后，对用户名和密码进行验证。验证过程可能涉及对密码的加密比对、与存储的用户信息进行匹配等。
5. 认证结果返回：根据验证结果，服务器将认证结果返回给前端应用程序或系统。如果验证成功，用户将被授权访问特定的资源或功能；如果验证失败，用户将被要求重新输入正确的登录信息或进行其他操作。
6. 用户会话建立：如果登录验证成功，服务器会为该用户建立一个会话或生成一个令牌（Token）。该会话或令牌将用于后续请求的身份验证和授权。
7. 跳转或登录成功提示：根据应用程序的设计，登录成功后可能会自动跳转到用户的个人主页、仪表盘或其他目标页面。或者，在登录成功后，系统会显示登录成功的提示信息，并提供相关的操作选项。

### 示例：百度搜索”xxxx"返回结果的一个过程

- 查询解析：百度搜索引擎首先对您输入的关键词进行查询解析，即对关键词进行分词和理解。它会将关键词拆分成单词或短语，并理解搜索意图。
- 搜索索引：百度搜索引擎会在其庞大的索引数据库中查找与您的关键词相关的网页、文章、图片、视频等内容。索引是一个巨大的数据库，其中包含了互联网上几乎所有的网页和资源的信息。
- 排名算法：百度的排名算法将根据一系列因素对搜索结果进行排序。这些因素可能包括关键词的相关性、网页的权威性、用户的搜索历史、地理位置等。排名算法旨在将最相关和最有价值的结果展示给用户。
- 结果呈现：根据排名算法的结果，百度搜索引擎会生成搜索结果页面，并显示与您的搜索相关的网页标题、描述和链接。通常，搜索结果页面会包含多个有机搜索结果（自然排名）和一些广告结果（根据广告竞价排名）。
- 用户反馈和实时更新：百度搜索引擎会根据用户的点击、滚动和停留时间等行为反馈来优化搜索结果。如果用户普遍点击某个搜索结果并停留时间较长，百度会认为该结果具有较高的相关性，并在以后的搜索中提供类似的结果。

## **数据结构**

### **一维数组和链表**的区别

- 存储方式:
    - 数组是一种连续存储数据的数据结构，所有元素在内存中是相邻的。这使得数组可以快速访问任何元素，只需知道索引即可。
    - 链表是一种非连续存储数据的数据结构，元素（节点）通过指针链接在一起。每个节点包含一个数据元素和一个指向下一个节点的指针。
- 访问:
    - 数组中是连续存储的，因此可以通过索引进行快速随机访问，时间复杂度为O(1)。
    - 链表不支持快速随机访问，必须从头节点开始遍历链表才能找到所需的元素，时间复杂度为O(n)，其中n是链表的大小。
- 插入和删除操作
    - 在数组中插入或删除元素通常需要移动其他元素，以保持连续性。这可能会导致插入和删除操作的时间复杂度为O(n)，其中n是数组的大小。
    - 链表在插入和删除操作上非常高效，只需调整节点的指针即可，时间复杂度通常为O(1)。
- 空间复杂度
    - 通常需要分配一块连续的内存来存储所有元素，因此可能会浪费一些空间。
    - 链表只在每个节点上存储数据和指针，不需要额外的内存来维护连续性，因此通常更省空间。

### **队列和栈**的区别

- 队列是一种先进先出（FIFO）的数据结构，这意味着最先添加到队列的元素会最先被移除。在队列中，元素只能从队尾添加，从队头移除。
- 栈是一种先进后出（LIFO）的数据结构，这意味着最后添加到栈的元素会最先被移除。在栈中，元素只能从栈顶添加和移除。
- 队列常用于需要按**顺序处理任务**的情况，如任务调度、广度优先搜索（BFS）、打印队列等。
- 栈通常用于需要**回溯或撤销操作**的情况，如深度优先搜索（DFS）、函数调用堆栈、表达式求值等。

### **堆和栈**的区别(内存管理)

堆（Heap）和栈（Stack）是计算机内存管理中的两种主要方式, 两者主要有以下区别:

内存分配方式
- **栈（Stack）**：
    - **自动分配和释放**：栈内存由操作系统自动管理，分配和释放都由系统完成，通常在函数调用时分配，在函数返回时释放。
    - **固定大小**：栈的大小在程序启动时就确定了，因此在嵌套调用和递归较深时可能会出现栈溢出（Stack Overflow）。
- **堆（Heap）**：
    - **手动分配和释放**：堆内存由程序员通过动态内存分配函数（如`malloc`、`free`，或`new`、`delete`）来管理。程序员需要显式地分配和释放内存。
    - **动态大小**：堆的大小是动态变化的，可以在运行时根据需要分配内存，但这也可能导致内存碎片和分配/释放的开销较大。

**内存管理方式**
- **栈（Stack）**：
    - **LIFO（后进先出）**：栈是一个后进先出的数据结构，最先分配的内存最后被释放。这种顺序使得栈内存的分配和释放非常高效。
    - **局部性好**：由于栈内存是连续分配的，因此具有良好的局部性，有助于缓存性能。
- **堆（Heap）**：
    - **自由存储**：堆是一块大的内存区域，内存分配是随机的，不遵循任何顺序，这使得内存分配更加灵活。
    - **碎片化问题**：由于堆内存的自由分配和释放，可能会产生内存碎片，降低内存使用效率。

**使用场景**

- **栈（Stack）**：
    - **函数调用和局部变量**：栈主要用于存储函数调用的上下文，包括函数的局部变量、参数、返回地址等。
    - **递归**：递归调用时，每次递归调用都会在栈上分配新的栈帧，直到递归返回。
- **堆（Heap）**：
    - **动态数据**：堆用于存储动态分配的数据，比如通过`malloc`或`new`分配的对象和数组。
    - **长生命周期数据**：如果数据需要在函数调用结束后依然存在（即生命周期超过函数调用），应该使用堆内存。

**性能**
- **栈（Stack）**：
    - **速度快**：由于栈内存的分配和释放是自动且顺序的，其开销非常低，速度很快。
    - **有限大小**：栈的大小通常较小，受限于操作系统的设置，如果超出限制，会导致栈溢出。
- **堆（Heap）**：
    - **速度慢**：由于堆内存的分配和释放需要维护数据结构（如自由列表），其开销相对较高，速度较慢。
    - **大小灵活**：堆的大小只受限于可用内存，总体上可以分配更大的内存块。

**典型问题**

- **栈（Stack）**：
    - **栈溢出**：如果递归太深或分配过多局部变量，可能会导致栈溢出。
    - **固定内存**：栈内存的大小是固定的，不能动态调整。
- **堆（Heap）**：
    - **内存泄漏**：如果分配的内存没有正确释放，会导致内存泄漏。
    - **内存碎片**：频繁的分配和释放操作会导致内存碎片化，降低内存利用效率。

- 栈是一种线性数据结构，使用的是一种特殊的数据存储方式，称为"先进后出"（LIFO，Last-In-First-Out）。栈中的数据以堆叠的方式存储，只有栈顶的数据可以直接访问，要访问或删除其他数据，必须先将上面的数据出栈。堆是一块大的内存区域，用于动态分配内存, 内存分配是随机的，不遵循任何顺序。在堆中，数据的存储和访问也没有固定的顺序。数据在堆中以分散的方式存储，可以通过指针相互关联。
- 栈内存分配由编译器自动管理，用于存储局部变量、函数参数、返回地址以及函数调用的上下文信息。栈的分配和释放是非常快速的，但栈的大小通常是有限的，编译时或运行时确定。堆内存分配是动态的，由程序员手动申请和释放。在堆中，数据的生存期不受限制，可以持续存在直到程序明确释放。堆的大小通常受限于操作系统和可用物理内存。
- 栈上的数据的生命周期由其作用域（例如，函数的局部变量）控制。当变量超出作用域时，它们将被自动销毁，即出栈。栈上的数据生命周期短暂，适用于保存临时变量。堆上的数据的生命周期由程序员显式管理。它们可以长时间存在，直到程序员释放它们。这使得堆适合存储动态分配的数据，如动态数组和对象。
- 栈上的数据访问速度通常非常快，因为它们存储在内存中的连续位置，并且不需要寻址操作。栈上的访问时间是常数时间（O(1)）。堆上的数据访问速度较慢，因为需要通过指针来寻址，并且数据可能分散在内存中的不同位置。堆上的访问时间通常是对数时间（O(log n)）或线性时间（O(n)，取决于数据结构的实现）。

### **堆和栈**的区别(数据结构)

堆是一种特殊的树状数据结构，通常实现为一个完全二叉树，以数组形式存储。用于实现优先队列。堆有两种主要类型：
1. **最大堆（Max Heap）**：
    - 在最大堆中，每个节点的值都大于或等于其子节点的值。
    - 最大堆的根节点包含最大值。
2. **最小堆（Min Heap）**：
    - 在最小堆中，每个节点的值都小于或等于其子节点的值。
    - 最小堆的根节点包含最小值。

应用场景：

- **优先队列**：如任务调度、事件驱动仿真系统。
- **排序算法**：堆排序。
- **图算法**：如Dijkstra和Prim算法中的优先队列。


栈是一种后进先出（LIFO，Last In First Out）的数据结构。只允许在一端进行插入和删除操作，称为栈顶。
- **操作**：
    - 压栈（push）：将元素添加到栈顶。
    - 出栈（pop）：从栈顶移除元素。
    - 查看栈顶元素（peek/top）：获取栈顶元素而不移除它。
应用场景：
- **函数调用管理**：实现递归函数调用的系统栈。
- **表达式求值**：如中缀表达式转换为后缀表达式（逆波兰表示法）。
- **括号匹配**：检查括号匹配的有效性。
- **回溯算法**：如深度优先搜索（DFS）。

### **数组和 vector** 的区别

- 数组通常具有静态大小，一旦创建，其大小通常不会自动变化，除非重新创建一个新的数组。在很多编程语言中，数组的大小在创建时就固定了。向量是一种动态大小的数据结构，可以根据需要自动扩展或缩小。向量会自动处理内存的分配和释放，使得添加或删除元素变得更加方便。
- 通常需要手动管理内存分配和释放。在很多编程语言中，数组是在栈上或堆上分配的，需要程序员负责释放内存，以避免内存泄漏。向量通常由语言或标准库提供，它们自动管理内存分配和释放，减轻了程序员的负担，降低了内存泄漏的风险。
- 由于大小固定，如果需要更多的空间来存储元素，通常需要手动创建一个新的更大的数组，然后将元素复制到新数组中，这可能会导致性能开销。
- 向量会自动管理容量的增长，当需要更多空间时，它会分配更大的内存块，并将元素移动到新内存中，通常在对数时间内完成。

### **线性结构: 数组**：一组连续的内存单元，具有固定大小的数据结构，其中每个元素都可以通过其索引来访问。

### **线性结构: 链表**：由包含指针和数据元素的节点组成，节点之间通过指针链接在一起。

单链表

双链表

循环链表

### **线性结构: 栈**（Stack）：遵循先进后出（FILO）原则的数据结构。操作包括压栈（push）和弹栈（pop）。

- 栈的实际应用
    
    操作“回退”功能
    
    实现 C 语言函数的相互调用
    
    “进制转换”
    
    “括号匹配”
    

### **线性结构: 队列**（Queue）：遵循先进先出（FIFO）原则的数据结构。操作包括入队（enqueue）和出队（dequeue）。

顺序队列: 

循环队列: 

双端队列: 

- 队列的实际应用
    
    处理竞争资源分配问题，比如操作系统 CPU 资源分配时，根据“先进先出”原则，最先进队列的程序出队列，并获得 CPU 的使用权。
    

### **非线性结构: 多维数组**

### **非线性结构: 树**

#### 普通二叉树: 

每个节点最多只有两个分支的树结构.

- 二叉树的第 $k$ 层至多拥有 $2^{k-1}$ 个节点;
- 深度为 $k$ 的二叉树至多总共有 $2^{k}-1$ 个节点;
- 非空的二叉树，若树叶总数(叶子节点)为 $n_0$ ，分支度为 2 (有两个非空子节点的节点)的总数为 $n_2$ ，则 $n_0 = n_2 + 1$ .

#### 完全二叉树

最后一层可能不是满的, 其余层都是满的. 并且最后一层要么是满的，要么仅在**右边缺少连续若干节点**.
    
- 深度为 k 的完全二叉树，至少有 $2^{k-1}$ 个节点，至多有 $2^{k}-1$ 个节点。
- 具有 n 个节点的完全二叉树的深度为 $log_2 n+1$ .
    

#### 完美二叉树: 

每一层上的节点数都是**最大节点数**. 
一棵深度为 $k$  的完美二叉树：
- 共有  $2^k-1$ 个结点
- 结点个数一定为奇数
- 第  $i$ 层有  $2^{i-1}$ 个结点
- 有 $2^{k-1}$ 个叶子

#### 搜索二叉树

对于任意树节点, 非空左子节点值均小于当前节点值, 非空右子节点值均大于当前节点值.

1. 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；
2. 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；
3. 任意节点的左、右子树也分别为二叉查找树；

查找、插入的时间复杂度较低。为 $O(\log n)$。

| 算法 | 平均 | 最差 |
| --- | --- | --- |
| 空间 | O(n) | O(n) |
| 搜索 | O(log n) | O(n) |
| 插入 | O(log n) | O(n) |
| 删除 | O(log n) | O(n) |
- **查找算法过程:**
    1. 若当前节点是空树，则搜索失败.
    2. 若当前节点值等于要查询的值，则查找成功；
    3. 若当前节点值大于要查询的值，则搜索左子树；
    4. 若当前节点值小于要查询的值，则搜索右子树。
    
    ```cpp
    bool search(TreeNode* root, int target) {
      if (root == nullptr) {
        return false;
      }
      if (root->key == target) {
        return true;
      } else if (target < root->key) {
        return search(root->left, target);
      } else {
        return search(root->right, target);
      }
    }
    ```
    
- **插入算法过程**
    1. 若当前节点是空树，则构建一个新节点, 并返回给上一节点进行插入.
    2. 若当前节点值等于要插入的值，则当作重复值处理.
    3. 若当前节点值大于要插入的值，则将新值插入到左子树.
    4. 若当前节点值小于要插入的值，则将新值插入到右子树.
    5. 新插入节点总是叶子节点
    
    ```cpp
    TreeNode* insert(TreeNode* root, int value) {
      if (root == nullptr) {
        return new TreeNode(value);
      }
      if (value < root->key) {
        root->left = insert(root->left, value);
      } else if (value > root->key) {
        root->right = insert(root->right, value);
      } else {
        root->count++;  // 节点值相等，增加重复数量
      }
      return root;
    }
    ```
    
- **删除算法过程:**
    1. 先在二叉搜索树中查找等于要删除的值的节点.
    2. 若其存在, 且为叶子结点, 直接删除该节点即可, 并返回空节点代替自己的位置.
    3. 若其存在, 且只有一个子节点, 则直接删除该节点, 并返回其子节点, 使其代替自己的位置.
    4. 若其存在, 且有两个非空子节点, 则在删除该节点之后, 为保持其它元素之间的相对位置不变，可按中序遍历保持有序进行调整. 
        1. 一般是用它左子树的最大值（左子树最右的节点）或右子树的最小值（右子树最左的节点）代替它，然后将它删除。
        2. 其一是令*p的左子树为*f的左/右（依*p是*f的左子树还是右子树而定）子树，*s为*p左子树的最右下的结点，而*p的右子树为*s的右子树；
        3. 其二是令*p的直接前驱（in-order predecessor）或直接后继（in-order successor）替代*p，然后再从二叉查找树中删去它的直接前驱（或直接后继）。
    
    ```cpp
    TreeNode* remove(TreeNode* root, int value) {
      if (root == nullptr) {
        return root;
      }
      if (value < root->key) {
        root->left = remove(root->left, value);
      } else if (value > root->key) {
        root->right = remove(root->right, value);
      } else {
        if (root->count > 1) {
          root->count--;  // 节点重复数量大于1，减少重复数量
        } else {
          if (root->left == nullptr) {
            TreeNode* temp = root->right;
            delete root;
            return temp;
          } else if (root->right == nullptr) {
            TreeNode* temp = root->left;
            delete root;
            return temp;
          } else {
            TreeNode* successor = root->right;
            
                    while (successor->left != nullptr) { 
                        successor = successor->left; 
                    }
    
            root->key = successor->key;
            root->count = successor->count;  // 更新重复数量
            root->right = remove(root->right, successor->key);
          }
        }
      }
      return root;
    }
    ```
    

#### 平衡二叉树（如 AVL 树）: 

^8f3141

通过规则(限定任一节点对应的两棵子树的最大高度差的绝对值为1)，减小树的深度，从而达到减小查询的复杂度的目的 O(log *n*).
    
**解决问题:** 虽然搜索二叉树一定程度上可以提高搜索效率，但是当原序列有序时，例如序列 A = {1，2，3，4，5，6}，构造二叉搜索树为右斜树，同时二叉树退化成单链表，搜索效率降低为 O(n)。

- **查找算法过程: 与搜索二叉树相同.**
- **插入算法过程:**
    - 执行与搜索二叉树相同的插入过程;
    - 更新当前节点的高度, 这里通过高度来间接计算子树的高度差.
    - 获取当前节点的平衡因子（左子树高度-右子树高度）
        - **Left Left case:** 在根节点的左孩的左侧添加新节点, 平衡因子为2; 对根节点进行**右旋**操作.
        - **left Right case:** 在根节点的左孩的右侧添加新节点, 平衡因子为2; 对根节点的左孩执行**左旋**操作, 然后对根节点执行**右旋**操作.
        - **Right Right Case:** 在根节点的右孩的右侧添加新节点, 平衡因子为-2; 对根节点进行**左旋**操作.
        - **Right Left Case:** 在根节点的右孩的左侧添加新节点, 平衡因子为-2; 对根节点的右孩执行**右旋**操作, 然后对根节点执行**左旋**操作.
    
    ```cpp
    int height(TreeNode* node)
    {
        return (node == nullptr) ? 0 : node->height;
    }
    
    int max(int a, int b)
    {
        return (a > b) ? a : b;
    }
    
    int getBalanceFactor(TreeNode* node)
    {
        return (node == nullptr) ? 0 : height(node->left) - height(node->right);
    }
    
    TreeNode* insert(TreeNode* root, int value) {
        if (root == nullptr) {
            return new TreeNode(value);
        }
        
        if (value < root->key) {
            root->left = insert(root->left, value);
        }
        else if (value > root->key) {
            root->right = insert(root->right, value);
        }
        else {
            // Duplicate values are not allowed
            return root;
        }
        
        root->height = 1 + max(height(root->left),
                            height(root->right));
     
    
        int balance = getBalanceFactor(root);
        
        if (balance > 1 ) {
            if (value < root->left->key) {
                return rightRotate(root);
            }
            else {
                root->left = leftRotate(root->left);
                return rightRotate(root);
            }
        }
        
        if (balance < -1) {
            if (value > root->right->key) {
                return leftRotate(root);
            }
            else {
                root->right = rightRotate(root->right);
                return leftRotate(root);
            }
        }
        
        return root;
    }
    ```
    
- **删除算法过程:**

平衡的调整操作分为包括 **左旋（Left Rotate）** 和 **右旋（Right Rotate）** 两种。这两种操作均不改变中序遍历序列。

**左旋操作：**

- 当前节点的右孩替代此节点位置.
- 右孩的左子树变为该节点的右子树
- 节点本身作为右孩的左子树

 **右旋操作：**

- 节点的左孩子代表此节点
- 左孩的右子树变为节点的左子树
- 节点本身作为左孩的右子树

```cpp
TreeNode* leftRotate(TreeNode* root) {
  TreeNode* newRoot = root->right; // 获取右孩
  root->right = newRoot->left; // 右孩的左子树变为该节点的右子树
  newRoot->left = root; // 节点本身变为右孩的左子树
  
// 更新相关节点的信息
    root->height = 1 + max(height(root->left),
                        height(root->right));
    newRoot->height = 1 + max(height(newRoot->left),
                        height(newRoot->right));
  return newRoot;  // 返回新的根节点
}

TreeNode* rightRotate(TreeNode* root) {
  TreeNode* newRoot = root->left; // 获取左孩
  root->left = newRoot->right; // 左孩的右子树变为节点的左子树
  newRoot->right = root; // 节点本身作为左孩的右子树

    // 更新相关节点的信息
    root->height = 1 + max(height(root->left),
                        height(root->right));
    newRoot->height = 1 + max(height(newRoot->left),
                        height(newRoot->right));
  return newRoot;
}
```

#### 平衡树: 红黑树

^c3449d

通过规则( 节点只能为红色和黑色; 根节点必须为黑色; 空节点必须为黑色; 红色节点的子节点必须为黑色; 从根节点到叶子节点的每条路径上的黑色节点数量必须相同)，减小树的深度，从而达到减小查询的复杂度的目的 O(log *n*).
    
红黑树相对于AVL树来说，牺牲了部分平衡性以换取插入和删除操作时少量的旋转操作，整体来说插入和删除的性能要优于AVL树。

**必需规则:**

1. 每个节点要么是红色，要么是黑色。
2. 所有空节点都被视为黑色。
3. 红色节点的子节点必须为黑色;
4. 从给定节点到其任何后代空节点的每条路径都会经过相同数量的黑色节点。

**推导性质:**

- 如果节点**N恰好有一个子节点，那么它一定是红色子节点，因为如果它是黑色的，则其 NIL 后代将位于与N**的 NIL 子节点不同的黑色深度，从而违反了要求 4。
- **从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。**

红黑树相对于AVL树来说，牺牲了部分平衡性以换取插入和删除操作时少量的旋转操作，整体来说性能要优于AVL树。

- 就插入节点导致树失衡的情况，AVL树和红黑树都是最多两次树旋转来实现平衡，旋转的量级是O(1)。
- 删除节点导致失衡，AVL需要维护从被删除节点到根节点root这条路径上所有节点的平衡，旋转的量级为O(logN)；而红黑树最多只需要旋转3次实现平衡，只需O(1)，所以说红黑树删除节点的的效率更高，开销更小。
- AVL 的结构相较于红黑树更为平衡，因此AVL的查找效率更高。

#### 平衡书（B 树）

^79488e

通过保留平衡树的特性, 并在节点中存储更多子节点, 来减小树的深度, 从而达到减小查询的复杂度的目的 O(log *n*). B 树非常适合读写相对较大数据块的存储系统，例如数据库和文件系统。

1. 每个**节点最多**有 m 个子节点。
2. 每一个**非叶子节点**（除根节点）最少有 $\frac{m}{2}$ 个子节点。
3. 如果**根节点不是叶子节点**，那么它至少有两个子节点。
4. 有 k 个子节点的非叶子节点拥有 k-1 个键，且升序排列，满足 $k[i] < k[i+1]$。
5. 每个节点至多包含 $2k-1$ 个键。
6. 所有的叶子节点都在同一层。


 B 树最初被发明用于管理大型随机访问文件的索引页, 并在树中除叶节点之外的每个节点中保存值。

形状上更「胖」、更加「扁平」，即：每个节点能容纳更多的数据， 这样就能降低树的高度，同时让逻辑上相邻的数据都能尽量存储在物理上也相邻的硬盘空间上，减少磁盘读写。B 树特别适合具有缓慢、大量数据访问的存储系统，例如硬盘驱动器、闪存和 CD-ROM。

- **查找算法:**
    - 从根节点开始，递归向下遍历。
    - 对于每个访问过的非叶节点，
        - 如果节点值与查找值相等，直接返回该节点即可。
        - 否则，我们递归到该节点的适当子节点（位于第一个更大键之前的子节点）。
    - 如果我们到达叶节点并且在叶节点中没有找到 k，则返回 NULL。
    
    ```cpp
    struct Node {
        int n;
        int key[MAX_KEYS];
        Node* child[MAX_CHILDREN];
        bool leaf;
    };
     
    Node* BtreeSearch(Node* x, int k) {
        int i = 0;
        while (i < x->n && k >= x->key[i]) {
            i++;
        }
        if (i < x->n && k == x->key[i]) {
            return x;
        }
        if (x->leaf) {
            return nullptr;
        }
        return BtreeSearch(x->child[i], k);
    }
    ```
    

#### 平衡树: B+树

^68ecec

 B+ Tree 以索引值进行排列, 通过非叶子节点存储子树的的索引范围, 叶子节点存储所有被管理的数据, 实现树结构的的平衡性，并且能够通过叶子之间的构成的双向链表实现顺序访问, 来提高范围查询的性能。通过数据结构来排序，高速查找
1. 每个**节点最多**有 m 个子节点。
2. 除根节点外，**其他所有节点**最少有 $\frac{m}{2}$ 个子节点。
3. 如果**根节点不是叶子节点**，那么它至少有两个子节点。
4. 所有的**非叶子节点**可以看成是索引部分，节点中仅含有其子树中节点的最大（或最小）可比较值。
5. 有 k 个子节点的非叶子节点中含有 k-1 个可比较值, 升序排列，满足 $k[i] < k[i+1]$, 这些可比较值所划分的数值区域刚好对应 k 棵子树以及子树中所包含的可比较值的取值范围）。
6. 所有**叶子节点**应包含有所有被管理的可比较值和数据，且叶子节点本身依可比较值的大小自小而大**顺序双向或单向链接**。
7. 每个节点至多包含 $2k-1$ 个键。
8. 所有的叶子节点都在同一层。

进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。

插入删除操作记录会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个**分裂、合并、旋转等操作来维护平衡性。**

![Untitled](软件工程师.assets/Untitled%2072.png)

为了减少磁盘 I/O，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的旋转时间，因此速度会非常快。

操作系统一般将内存和磁盘分割成固态大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点，并且可以利用预读特性，相邻的节点也能够被预先载入。

#### B+Tree 与 B Tree的比较

- B-tree中非叶子节点可以存值；但是B+tree非叶子节点不可以存值，只能存key，值只存在叶子节点中。
- B-tree中叶子节点没有用指针连接起来；而B+tree中的叶子节点用指针连接起来，所以B+tree的查询很快，当定位到叶子节点后，只需要遍历叶子节点即可。B+树相比于B树能够更加方便的遍历。
- B+树简单的说就是变成了一个索引一样的东西。 B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），B+树的性能相当于是给叶子节点做一次二分查找。
- B+树的查找算法：当B+树进行查找的时候，你首先一定需要记住，就是B+树的非叶子节点中并不储存节点，只存一个键值方便后续的操作，所以非叶子节点就是索引部分，所有的叶子节点是在同一层上，包含了全部的关键值和对应数据所在的地址指针。这样其实，进行 B+树的查找的时候，只需要在叶子节点中进行查找就可以了。

1. B树只适合随机检索，而B+树同时支持随机检索和顺序检索
2. B+树空间利用率更高，可减少I/O次数，磁盘读写代价更低。
    
    一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗。
    
    B+树的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素。
    
3. B+树的查询效率更加稳定
    
    B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。
    
    而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。
    
4. B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。
    
    B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历，而B树不支持这样的操作。
    
5. 增删文件（节点）时，B+树效率更高。
    
    因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。
    

#### **B+ 树与 hash 索引的比较**

1. hash 索引进行等值查询更快，但是却无法进行范围查询，且等值查询不稳定，性能不可预测
    
    当某个键值存在且大量重复的时候，发生hash碰撞，此次hash索引效率可能极差
    
    b+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低
    
2. hash索引不支持使用索引进行排序
3. hash索引不支持模糊查询以及多列索引的最左前缀匹配
4. hash索引任何时候都避免不了回表查询，而B+树在符合某些条件的时候可以只通过索引完成查询

#### 其他结构

- B* 树
- **多叉树**
- **最大堆**
- 最小堆
- **并查集**
- **字典树（Trie）**

### 非线性结构: Hash 表

基于 **Hash** 函数将键映射到值的数据结构，用于快速的数据检索和存储。通常支持常数时间的平均查找复杂度。

在哈希表中，不管是寻找、删除、增加一个新元素，时间复杂度都是O(1)。

哈希表使用哈希函数来对键进行哈希处理，生成的哈希值可以指示相应值的存储位置。这个存储位置可能一个抽象桶，也可能是直接的数组位置，从中可以找到所需的值。

- **哈希函数（Hash Function）原理：**任意数对2的N次方取模时，等同于其和2的N次方-1作位于运算。`k % 2^n = k & (2^n - 1)`
    1. [直接定址法](https://zh.wikipedia.org/w/index.php?title=%E7%9B%B4%E6%8E%A5%E5%AE%9A%E5%9D%80%E6%B3%95&action=edit&redlink=1)：取关键字或关键字的某个线性函数值为散列地址。即hash(k) = k 或hash(k)=ak+b，其中a,b为常数（这种散列函数叫做自身函数）
    2. [数字分析法](https://zh.wikipedia.org/w/index.php?title=%E6%95%B0%E5%AD%97%E5%88%86%E6%9E%90%E6%B3%95&action=edit&redlink=1)：假设关键字是以*r*为基的数，并且哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干数位组成哈希地址。
    3. [平方取中法](https://zh.wikipedia.org/wiki/%E5%B9%B3%E6%96%B9%E5%8F%96%E4%B8%AD%E6%B3%95)：取关键字平方后的中间几位为哈希地址。通常在选定哈希函数时不一定能知道关键字的全部情况，取其中的哪几位也不一定合适，而一个数平方后的中间几位数和数的每一位都相关，由此使随机分布的关键字得到的哈希地址也是随机的。取的位数由表长决定。
    4. [折叠法](https://zh.wikipedia.org/w/index.php?title=%E6%8A%98%E5%8F%A0%E6%B3%95&action=edit&redlink=1)：将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位）作为哈希地址。
    5. [随机数法](https://zh.wikipedia.org/w/index.php?title=%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%B3%95&action=edit&redlink=1)
    6. [除留余数法](https://zh.wikipedia.org/w/index.php?title=%E9%99%A4%E7%95%99%E4%BD%99%E6%95%B0%E6%B3%95&action=edit&redlink=1)：取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。即, 。不仅可以对关键字直接取模，也可在[折叠法](https://zh.wikipedia.org/w/index.php?title=%E6%8A%98%E5%8F%A0%E6%B3%95&action=edit&redlink=1)、[平方取中法](https://zh.wikipedia.org/wiki/%E5%B9%B3%E6%96%B9%E5%8F%96%E4%B8%AD%E6%B3%95)等运算之后取模。对p的选择很重要，一般取素数或m，若p选择不好，容易产生冲突。
- **负载系数：**哈希表的重要参数，其定义为：哈希表中占用的条目数目与哈希表长度（桶数量）的比值。由于表长是定值，而表中元素的个数越大，表中空余位置就会更少，发生碰撞的可能性也会进一步增大。哈希表的扩容策略依赖于负载因子阈值，高于指定阈值时就进行扩容（**重散列**）。
    
    重复插入会导致哈希表中的条目数量增加，从而增加负载因子，降低查找和插入性能。此时需要动态调整哈希表的大小，并将表中的项目重新哈希到新哈希表的存储桶中。
    
    通常，会私下分配一个大小为原始哈希表两倍的新哈希表，并通过计算各项的哈希值，然后进行插入操作，将原始哈希表中的每个项目移动到新分配的哈希表中。尽管重新散列很简单，但计算量却很大。
    

#### 哈希值冲突怎么解决**

常用的解决方案有散列法和拉链法。

- **链地址法：**为每个 Hash 值建立一个带有键值对的单链表，当发生冲突时，将记录插入到链表中。然后使用唯一的搜索键遍历该链表以查找和访问该项目。
    
    如果键是有序的，那么可以使用自平衡二叉搜索树，将理论上最坏的情况降低到 O(\log {n})。
    
    也可以使用二级哈希的概念，通过完美哈希处理哈希值冲突。缺点是占用内存高，因为有固定大小的哈希长度。
    
- **开放定址法：**要求表长度要大于等于所需要存放的元素数量。当哈希冲突发生时，从发生冲突的那个单元起，按照一定的次序，从哈希表中寻找一个空闲的单元，然后把发生冲突的元素存入到该单元。查找时，如果探查到空白单元，即表中无待查的关键字，则查找失败。
    
    线性探测：以线性间隔去探测空白单元
    
    二次探测：以呈二次增加的间隔去探测空白单元
    
    双重散列：以另一个哈希函数计算的值去探测空白单元
    
1. **Cuckoo Hashing**：
    - 使用多个哈希函数，每个元素有两个哈希位置。如果插入元素时发生冲突，就尝试将冲突元素放到其它哈希位置上。
2. **Robin Hood Hashing**：
    - 一种基于线性探测的优化算法，尝试通过重新排列元素来减少冲突的次数，使得最长探测路径变短，从而提高查找效率。
    

### **非线性结构: 图**

由顶点和连接这些顶点的边组成。

- 无向图
- 有向图
- 带权图
- 邻接矩阵和邻接表表示法

## **算法**

### 排序算法(冒泡,插入,归并,计数,桶,基数 | 选择,希尔,快速,堆):

![Untitled](软件工程师.assets/Untitled%2073.png)

 上图**存在错误**：

1. 插入排序的最好时间复杂度为 O(n) 而不是 O(n^2) 。
2. 希尔排序的平均时间复杂度为 O(nlogn)

#### 冒泡排序 (Bubble Sort)

冒泡排序是一种简单的排序算法。它重复地遍历要排序的序列，依次比较两个元素，如果它们的顺序错误就把它们交换过来。遍历序列的工作是重复地进行直到没有再需要交换为止，此时说明该序列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢 “浮” 到数列的顶端。

**算法步骤**

1. 比较相邻的元素。如果第一个比第二个大，就交换它们两个；
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
3. 针对所有的元素重复以上的步骤，除了最后一个；
4. 重复步骤 1~3，直到排序完成。

**算法优化**

此处对代码做了一个小优化，加入了 `is_sorted` Flag，目的是将算法的最佳时间复杂度优化为 `O(n)`，即当原输入序列就是排序好的情况下，该算法的时间复杂度就是 `O(n)`。

```cpp
/**
 * 冒泡排序
 * @param arr
 * @return arr
 */
public static int[] bubbleSort(int[] arr) {
    for (int i = 1; i < arr.length; i++) {
        // Set a flag, if true, that means the loop has not been swapped,
        // that is, the sequence has been ordered, the sorting has been completed.
        boolean flag = true;
        for (int j = 0; j < arr.length - i; j++) {
            if (arr[j] > arr[j + 1]) {
                int tmp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = tmp;
       // Change flag
                flag = false;
            }
        }
        if (flag) {
            break;
        }
    }
    return arr;
}
```
    

#### 选择排序 (Selection Sort)

选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

**算法步骤**

1. 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置
2. 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
3. 重复第 2 步，直到所有元素均排序完毕。

```cpp
/**
 * 选择排序
 * @param arr
 * @return arr
 */
public static int[] selectionSort(int[] arr) {
    for (int i = 0; i < arr.length - 1; i++) {
        int minIndex = i;
        for (int j = i + 1; j < arr.length; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        if (minIndex != i) {
            int tmp = arr[i];
            arr[i] = arr[minIndex];
            arr[minIndex] = tmp;
        }
    }
    return arr;
}
```

#### 快速排序 (Quick Sort)

快速排序用到了分治思想，同样的还有归并排序。乍看起来快速排序和归并排序非常相似，都是将问题变小，先排序子串，最后合并。不同的是快速排序在划分子问题的时候经过多一步处理，将划分的两组数据划分为一大一小，这样在最后合并的时候就不必像归并排序那样再进行比较。但也正因为如此，划分的不定性使得快速排序的时间复杂度并不稳定。

基本思想：通过一趟排序将待排序列分隔成独立的两部分，其中一部分记录的元素均比另一部分的元素小，则可分别对这两部分子序列继续进行排序，以达到整个序列有序。

**算法步骤**

- 从序列中**随机**挑出一个元素，做为 “基准”(`pivot`)；
- 重新排列序列，将所有比基准值小的元素摆放在基准前面，所有比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个操作结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
- 递归地把小于基准值元素的子序列和大于基准值元素的子序列进行快速排序。

```cpp
public static int partition(int[] array, int low, int high) {
    int pivot = array[high];
    int pointer = low;
    for (int i = low; i < high; i++) {
        if (array[i] <= pivot) {
            int temp = array[i];
            array[i] = array[pointer];
            array[pointer] = temp;
            pointer++;
        }
        System.out.println(Arrays.toString(array));
    }
    int temp = array[pointer];
    array[pointer] = array[high];
    array[high] = temp;
    return pointer;
}
public static void quickSort(int[] array, int low, int high) {
    if (low < high) {
        int position = partition(array, low, high);
        quickSort(array, low, position - 1);
        quickSort(array, position + 1, high);
    }
}
```
    

#### 插入排序 (Insertion Sort)

插入排序是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用 in-place 排序（即只需用到 O(1) 的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。

插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。

**算法步骤**

- 从第一个元素开始，该元素可以认为已经被排序；
- 取出下一个元素，在已经排序的元素序列中从后向前扫描；
- 如果该元素（已排序）大于新元素，将该元素移到下一位置；
- 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；
- 将新元素插入到该位置后；
- 重复步骤 2~5。

```cpp
/**
 * 插入排序
 * @param arr
 * @return arr
 */
public static int[] insertionSort(int[] arr) {
    for (int i = 1; i < arr.length; i++) {
        int preIndex = i - 1;
        int current = arr[i];
        while (preIndex >= 0 && current < arr[preIndex]) {
            arr[preIndex + 1] = arr[preIndex];
            preIndex -= 1;
        }
        arr[preIndex + 1] = current;
    }
    return arr;
}
```

#### 希尔排序 (Shell Sort)

    
希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为递减增量排序算法，同时该算法是冲破 O(n²) 的第一批算法之一。希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录 “基本有序” 时，再对全体记录进行依次直接插入排序。

**算法步骤**

在此我们选择增量 gap=length/2，缩小增量继续以 gap = gap/2 的方式，这种增量选择我们可以用一个序列来表示，{n/2, (n/2)/2, ..., 1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。

先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：

- 选择一个增量序列 `{t1, t2, …, tk}`，其中 `(ti>tj, i<j, tk=1)`；
- 按增量序列个数 k，对序列进行 k 趟排序；
- 每趟排序，根据对应的增量 `t`，将待排序列分割成若干长度为 `m` 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

```cpp
/**
 * 希尔排序
 *
 * @param arr
 * @return arr
 */
public static int[] shellSort(int[] arr) {
    int n = arr.length;
    int gap = n / 2;
    while (gap > 0) {
        for (int i = gap; i < n; i++) {
            int current = arr[i];
            int preIndex = i - gap;
            // Insertion sort
            while (preIndex >= 0 && arr[preIndex] > current) {
                arr[preIndex + gap] = arr[preIndex];
                preIndex -= gap;
            }
            arr[preIndex + gap] = current;

        }
        gap /= 2;
    }
    return arr;
}
```

#### 归并排序 (Merge Sort)

归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法 (Divide and Conquer) 的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为 2 - 路归并。

归并排序的具体工作原理可以通过以下步骤进行描述：

1. **分解**：
    - 不断将当前数组一分为二，直到每个子数组的长度为1。
2. **排序并合并**：
    - 从最小的子数组开始，将两个有序子数组合并成一个有序数组。
    - 重复这一过程，直到合并到原始数组大小。

**算法步骤**

- 如果输入内只有一个元素，则直接返回，否则将长度为 `n` 的输入序列分成两个长度为 `n/2` 的子序列；
- 分别对这两个子序列进行归并排序，使子序列变为有序状态；
- 设定两个指针，分别指向两个已经排序子序列的起始位置；
- 比较两个指针所指向的元素，选择相对小的元素放入到合并空间（用于存放排序结果），并移动指针到下一位置；
- 重复步骤 3 ~4 直到某一指针达到序列尾；
- 将另一序列剩下的所有元素直接复制到合并序列尾。

```cpp
/**
 * 归并排序
 *
 * @param arr
 * @return arr
 */
public static int[] mergeSort(int[] arr) {
    if (arr.length <= 1) {
        return arr;
    }
    int middle = arr.length / 2;
    int[] arr_1 = Arrays.copyOfRange(arr, 0, middle);
    int[] arr_2 = Arrays.copyOfRange(arr, middle, arr.length);
    return merge(mergeSort(arr_1), mergeSort(arr_2));
}

/**
 * Merge two sorted arrays
 *
 * @param arr_1
 * @param arr_2
 * @return sorted_arr
 */
public static int[] merge(int[] arr_1, int[] arr_2) {
    int[] sorted_arr = new int[arr_1.length + arr_2.length];
    int idx = 0, idx_1 = 0, idx_2 = 0;
    while (idx_1 < arr_1.length && idx_2 < arr_2.length) {
        if (arr_1[idx_1] < arr_2[idx_2]) {
            sorted_arr[idx] = arr_1[idx_1];
            idx_1 += 1;
        } else {
            sorted_arr[idx] = arr_2[idx_2];
            idx_2 += 1;
        }
        idx += 1;
    }
    if (idx_1 < arr_1.length) {
        while (idx_1 < arr_1.length) {
            sorted_arr[idx] = arr_1[idx_1];
            idx_1 += 1;
            idx += 1;
        }
    } else {
        while (idx_2 < arr_2.length) {
            sorted_arr[idx] = arr_2[idx_2];
            idx_2 += 1;
            idx += 1;
        }
    }
    return sorted_arr;
}
```

#### 堆排序 (Heap Sort)

堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆的性质：即子结点的值总是小于（或者大于）它的父节点。

**算法步骤**

- 将初始待排序列 `(R1, R2, ……, Rn)` 构建成大顶堆，此堆为初始的无序区；
- 将堆顶元素 `R[1]` 与最后一个元素 `R[n]` 交换，此时得到新的无序区 `(R1, R2, ……, Rn-1)` 和新的有序区 (Rn), 且满足 `R[1, 2, ……, n-1]<=R[n]`；
- 由于交换后新的堆顶 `R[1]` 可能违反堆的性质，因此需要对当前无序区 `(R1, R2, ……, Rn-1)` 调整为新堆，然后再次将 R [1] 与无序区最后一个元素交换，得到新的无序区 `(R1, R2, ……, Rn-2)` 和新的有序区 `(Rn-1, Rn)`。不断重复此过程直到有序区的元素个数为 `n-1`，则整个排序过程完成。

```cpp
// Global variable that records the length of an array;
static int heapLen;

/**
 * Swap the two elements of an array
 * @param arr
 * @param i
 * @param j
 */
private static void swap(int[] arr, int i, int j) {
    int tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

/**
 * Build Max Heap
 * @param arr
 */
private static void buildMaxHeap(int[] arr) {
    for (int i = arr.length / 2 - 1; i >= 0; i--) {
        heapify(arr, i);
    }
}

/**
 * Adjust it to the maximum heap
 * @param arr
 * @param i
 */
private static void heapify(int[] arr, int i) {
    int left = 2 * i + 1;
    int right = 2 * i + 2;
    int largest = i;
    if (right < heapLen && arr[right] > arr[largest]) {
        largest = right;
    }
    if (left < heapLen && arr[left] > arr[largest]) {
        largest = left;
    }
    if (largest != i) {
        swap(arr, largest, i);
        heapify(arr, largest);
    }
}

/**
 * Heap Sort
 * @param arr
 * @return
 */
public static int[] heapSort(int[] arr) {
    // index at the end of the heap
    heapLen = arr.length;
    // build MaxHeap
    buildMaxHeap(arr);
    for (int i = arr.length - 1; i > 0; i--) {
        // Move the top of the heap to the tail of the heap in turn
        swap(arr, 0, i);
        heapLen -= 1;
        heapify(arr, 0);
    }
    return arr;
}
```

#### 计数排序 (Counting Sort)**

计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。计数排序 (Counting sort) 是一种稳定的排序算法。

计数排序使用一个额外的数组 C，其中第 i 个元素是待排序数组 A 中值等于 i 的元素的个数。然后根据数组 C 来将 A 中的元素排到正确的位置。它只能对整数进行排序。

**算法步骤**

- 找出数组中的最大值 `max`、最小值 `min`；
- 创建一个新数组 `C`，其长度是 `max-min+1`，其元素默认值都为 0；
- 遍历原数组 `A` 中的元素 `A[i]`，以 `A[i]-min` 作为 `C` 数组的索引，以 `A[i]` 的值在 `A` 中元素出现次数作为 `C[A[i]-min]` 的值；
- 对 `C` 数组变形，**新元素的值是该元素与前一个元素值的和**，即当 `i>1` 时 `C[i] = C[i] + C[i-1]`；
- 创建结果数组 `R`，长度和原始数组一样。
- **从后向前**遍历原始数组 `A` 中的元素 `A[i]`，使用 `A[i]` 减去最小值 `min` 作为索引，在计数数组 `C` 中找到对应的值 `C[A[i]-min]`，`C[A[i]-min]-1` 就是 `A[i]` 在结果数组 `R` 中的位置，做完上述这些操作，将 `count[A[i]-min]` 减小 1。

当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 O(n+k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组 C 的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上 1），这使得计数排序对于数据范围很大的数组，需要大量额外内存空间。

```cpp
/**
 * Gets the maximum and minimum values in the array
 *
 * @param arr
 * @return
 */
private static int[] getMinAndMax(int[] arr) {
    int maxValue = arr[0];
    int minValue = arr[0];
    for (int i = 0; i < arr.length; i++) {
        if (arr[i] > maxValue) {
            maxValue = arr[i];
        } else if (arr[i] < minValue) {
            minValue = arr[i];
        }
    }
    return new int[] { minValue, maxValue };
}

/**
 * Counting Sort
 *
 * @param arr
 * @return
 */
public static int[] countingSort(int[] arr) {
    if (arr.length < 2) {
        return arr;
    }
    int[] extremum = getMinAndMax(arr);
    int minValue = extremum[0];
    int maxValue = extremum[1];
    int[] countArr = new int[maxValue - minValue + 1];
    int[] result = new int[arr.length];

    for (int i = 0; i < arr.length; i++) {
        countArr[arr[i] - minValue] += 1;
    }
    for (int i = 1; i < countArr.length; i++) {
        countArr[i] += countArr[i - 1];
    }
    for (int i = arr.length - 1; i >= 0; i--) {
        int idx = countArr[arr[i] - minValue] - 1;
        result[idx] = arr[i];
        countArr[arr[i] - minValue] -= 1;
    }
    return result;
}
```

#### 桶排序 (Bucket Sort)

桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：

- 在额外空间充足的情况下，尽量增大桶的数量
- 使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中

桶排序的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行。

**算法步骤**

- 设置一个 BucketSize，作为每个桶所能放置多少个不同数值；
- 遍历输入数据，并且把数据依次映射到对应的桶里去；
- 对每个非空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序；
- 从非空桶里把排好序的数据拼接起来。

```cpp
/**
 * Gets the maximum and minimum values in the array
 * @param arr
 * @return
 */
private static int[] getMinAndMax(List<Integer> arr) {
    int maxValue = arr.get(0);
    int minValue = arr.get(0);
    for (int i : arr) {
        if (i > maxValue) {
            maxValue = i;
        } else if (i < minValue) {
            minValue = i;
        }
    }
    return new int[] { minValue, maxValue };
}

/**
 * Bucket Sort
 * @param arr
 * @return
 */
public static List<Integer> bucketSort(List<Integer> arr, int bucket_size) {
    if (arr.size() < 2 || bucket_size == 0) {
        return arr;
    }
    int[] extremum = getMinAndMax(arr);
    int minValue = extremum[0];
    int maxValue = extremum[1];
    int bucket_cnt = (maxValue - minValue) / bucket_size + 1;
    List<List<Integer>> buckets = new ArrayList<>();
    for (int i = 0; i < bucket_cnt; i++) {
        buckets.add(new ArrayList<Integer>());
    }
    for (int element : arr) {
        int idx = (element - minValue) / bucket_size;
        buckets.get(idx).add(element);
    }
    for (int i = 0; i < buckets.size(); i++) {
        if (buckets.get(i).size() > 1) {
            buckets.set(i, sort(buckets.get(i), bucket_size / 2));
        }
    }
    ArrayList<Integer> result = new ArrayList<>();
    for (List<Integer> bucket : buckets) {
        for (int element : bucket) {
            result.add(element);
        }
    }
    return result;
}
```
    

#### 基数排序 (Radix Sort)

基数排序也是非比较的排序算法，对元素中的每一位数字进行排序，从最低位开始排序，复杂度为 O(n×k)，n 为数组长度，k 为数组中元素的最大的位数；

基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。

**算法步骤**

1. 取得数组中的最大数，并取得位数，即为迭代次数 `N`（例如：数组中最大数值为 1000，则 `N=4`）；
2. `A` 为原始数组，从最低位开始取每个位组成 `radix` 数组；
3. 对 `radix` 进行计数排序（利用计数排序适用于小范围数的特点）；
4. 将 `radix` 依次赋值给原数组；
5. 重复 2~4 步骤 `N` 次

```cpp
/**
 * Radix Sort
 *
 * @param arr
 * @return
 */
public static int[] radixSort(int[] arr) {
    if (arr.length < 2) {
        return arr;
    }
    int N = 1;
    int maxValue = arr[0];
    for (int element : arr) {
        if (element > maxValue) {
            maxValue = element;
        }
    }
    while (maxValue / 10 != 0) {
        maxValue = maxValue / 10;
        N += 1;
    }
    for (int i = 0; i < N; i++) {
        List<List<Integer>> radix = new ArrayList<>();
        for (int k = 0; k < 10; k++) {
            radix.add(new ArrayList<Integer>());
        }
        for (int element : arr) {
            int idx = (element / (int) Math.pow(10, i)) % 10;
            radix.get(idx).add(element);
        }
        int idx = 0;
        for (List<Integer> l : radix) {
            for (int n : l) {
                arr[idx++] = n;
            }
        }
    }
    return arr;
}
```

### 贪心算法和动态规划有什么区别

最优子结构性质：问题的最优解由相关子问题的最优解组合而成，而这些子问题可以独立求解。

**动态规划**应用于**子问题重叠**的情况，即不同的子问题具有公共的子子问题。此时，动态规划对每个子子问题只会求解一次，并在表中保存，可以避免不必要的重复计算。

1. 刻画一个最优解的结构特征，即最优子结构特征。
2. 递归地定义最优解的值，得到状态转移方程（递归表达式）。
3. 计算最优解的值，通常有两种方法：带备忘的自顶向下法(top-down with memoization)和自底向上法(bottom-up method)。
4. 利用计算出来的信息构造一个最优解。

**贪心算法**在求解的每一步都做出局部的贪心选择，寄希望这样的选择能够产生全局最优解。但是贪心算法并不保证得到最优解。

1. 将最优化问题转化为这样的形式：对其做出一次选择后，只剩下一个子问题需要求解。
2. 证明做出最优选择后，原问题总是存在最优解，即贪心选择总是安全的。
3. 证明做出贪心选择后，剩余的子问题满足性质：其最优解与贪心选择组合即可得到原问题的最优解，这样就得到了最优子结构。

贪心：如果把所有的子问题看成一棵树的话，贪心从根出发，每次向下遍历最优子树即可；这样的话，就不需要知道一个节点的所有子树情况，于是构不成一棵完整的树；

动态规划：动态规划则自底向上，从叶子向根，构造子问题的解，对每一个子树的根，求出下面每一个叶子的值，最后得到一棵完整的树，并且最终选择其中的最优值作为自身的值，得到答案

3.根据以上两条可以知道，贪心不能保证求得的最后解是最佳的，一般复杂度低；

而动态规划本质是穷举法，可以保证结果是最佳的，复杂度高。

### **基本有序的数组 用什么排序算法最好**

如果基本有序的数组需要进行排序，那么可以考虑使用插入排序算法。

插入排序算法的思想是将数组分为已排序区间和未排序区间，每次将未排序区间的第一个元素插入到已排序区间中的合适位置。对于基本有序的数组，已排序区间较大，因此插入排序的时间复杂度可以达到O(n)级别。

### 给你一些元素，怎么判断用什么排序更优？

**根据数据集大小来选择**

- 对于小型数据集（一般小于100个元素），简单的排序算法如插入排序或冒泡排序通常足够快，并且它们的常数因子较低。
- 对于大型数据集，更复杂的算法，如快速排序、归并排序或堆排序，通常更快，因为它们的时间复杂度为O(n log n)。

**根据数据的分布来选择**

- 如果数据已经部分有序，插入排序可能表现更好。
- 如果数据分布均匀，快速排序通常表现良好。
- 如果数据有大量重复值，计数排序或桶排序可能是更好的选择。

**考虑是否有稳定性要求**

- 如果需要保持相等元素的相对顺序不变，你应该选择稳定的排序算法，如归并排序或冒泡排序。
- 如果相对顺序无关紧要，那么可以选择不稳定的排序算法，如快速排序。

考虑内存限制问题:

- 对于内存受限的情况，归并排序通常比快速排序更适合，因为归并排序可以使用外部排序技术来处理大型数据集。
- 如果内存非常有限，可以考虑使用插入排序，因为它的内存开销最小。

## linux

### 常见的 linux 命令有哪些？

- 文件和目录操作： `ls -lhR` , `cd` , `pwd` , `mkdir` , `rm` , `cp (-r)` , `mv` , `touch` `du -sh` , `find` , `locate` , `whereis`
- 文件查看和编辑： `cat` , `more` , `less` , `head` , `tail` , `nano` , `vi`
- 系统信息和状态： `top` , `ps` , `df` , `free` , `uname`
- 网络操作： `ping` , `ifconfig` , `wget` , `curl` , `ssh` , `netstat`
- 权限和用户管理： `chmod` , `chown` , `useradd` , `userdel` , `passwd`
- 包管理和软件安装： `apt` , `yum`
- 进程管理： `kill` , `ps` , `top` , `htop`
- 压缩和解压缩： `tar -xzvf` , `gzip d` , `gunzip` , `zip` `unzip`

说几种免密连接的方法: **SSH 公私钥认证 | 类似脚本的方法使其自动输入密码**

### 硬链接和软链接的区别:

1. **定义不同**
    
    软链接又叫符号链接，这个文件包含了另一个文件的路径名。可以是任意文件或目录，可以链接不同文件系统的文件。
    
    硬链接就是一个文件的一个或多个文件名。把文件名和计算机文件系统使用的节点号链接起来。因此我们可以用多个文件名与同一个文件进行链接，这些文件名可以在同一目录或不同目录。
    
2. **限制不同**
    
    硬链接只能对已存在的文件进行创建，不能交叉文件系统进行硬链接的创建；
    
    软链接可对不存在的文件或目录创建软链接；可交叉文件系统；
    
3. **创建方式不同**
    
    硬链接不能对目录进行创建，只可对文件创建；
    
    软链接可对文件或目录创建；
    
4. **影响不同**
    
    删除一个硬链接文件并不影响其他有相同 inode 号的文件。
    
    删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。
    

硬链接只能在同一个文件系统内创建, 软链接可以跨越不同文件系统使用, 如(FAT32, NTFS等文件系统).

硬链接直接指向为文件元数据, 软链接本身就是个特殊文件, 其中包含了目标文件的路径信息.

通过硬链接可以直接修改文件内容, 修改软链接只是在修改其自身, 对指向的目标文件无效.

### Linux 具体使用范例

#### 文件类: **查看日志文件**

- 查看系**统文件树状结构**的指令: `tree -l -p -L 2 /path`
- **查看当前文件夹下的文件数量**: `ls -p | grep -v / | wc -l`
- 查看**文件大小**的指令: `ls -lhR /path` `du -sh`
- 实时查看末尾内容 `tail -f /path`
- 分页查看内容`less /path`
- 搜索指定内容**`grep "" /path`**
- 直接查看所有内容 `cat /path`
- 查看头部内容 `head /path` **查看 100~200 行**: `head -n 200 filename | tail -n 101`
- 图形化查看器 `vim, nano`
- 文件中查找一个字符出现的初次出现 **`grep -m 1 5"要查找的字符" 文件名`**
- 查找包含某一字段的**日志记录，输出文件后50行**`grep "某一字段" /path/to/your/logfile | tail -n 50`
- 实时**打印日志文件**包含关键字 error 和exception`tail -f /a/b/c/test.log | grep --line-buffered --color -E 'error|exception'`
- 两台 Linux 服务器之间如何进行文件的拷贝

#### 系统类

- 查看**内存使用**情况: `free -h`
- 查看**系统资源使用情况** `top`
- 根据进程名称查看**进程是否存活**(PID): **`ps aux | grep -v grep | grep"example_process"`**
- 已知进程 PID 查看**运行路径(程序名)**: `pwdx <PID>` 或 `lsof -p <PID> | grep "cwd"` 或 `ps -p <pid> -o comm=`
- 已知端口查看是否被进程监听: **`netstat -tuln | grep 8080`**  `lsof -i :<port>`
- 已知**端口查看相关进程**: `netstat -nap | grep port`
- **kill 和 kill-9** 有什么区别: **`kill`** 向进程发送 **TERM 信**号, 希望其正常退出. **`kill -9`** 向进程发送 **KILL 信号, 希望其强制退出.**
- **pid 和 ppid是什么:** PID 是当前进程的唯一标识符，而 PPID 就是当前进程的父进程的 PID。
- Linux 上自己的**程序怎么捕获其他主机发过来的信号**？
- 定义信号处理函数, 函数的参数通常是信号的编号，例如**`SIGINT`**表示中断信号，**`SIGTERM`**表示终止信号等。在信号处理函数中定义在接收信号时执行的操作。

`Signal     Value     Comment
─────────────────────────────
SIGHUP        1      终端退出时，此终端内的进程都将被终止
SIGINT        2      中断进程，可被捕捉和忽略，几乎等同于sigterm，所以也会尽可能的释放执行clean-up，释放资源，保存状态等(CTRL+C)
SIGQUIT       3      从键盘发出杀死(终止)进程的信号

SIGKILL       9      强制杀死进程，该信号不可被捕捉和忽略，进程收到该信号后不会执行任何clean-up行为，所以资源不会释放，状态不会保存
SIGTERM      15      杀死(终止)进程，可被捕捉和忽略，几乎等同于sigint信号，会尽可能的释放执行clean-up，释放资源，保存状态等
SIGCHLD      17      当子进程中断或退出时，发送该信号告知父进程自己已完成，父进程收到信号将告知内核清理进程列表。所以该信号可以解除僵尸进
                     程，也可以让非正常退出的进程工作得以正常的clean-up，释放资源，保存状态等。
 
SIGSTOP      19      该信号是不可被捕捉和忽略的进程停止信息，收到信号后会进入stopped状态
SIGTSTP      20      该信号是可被忽略的进程停止信号(CTRL+Z)
SIGCONT      18      发送此信号使得stopped进程进入running，该信号主要用于jobs，例如bg & fg 都会发送该信号。
                     可以直接发送此信号给stopped进程使其运行起来    
SIGUSR1      10      用户自定义信号1
SIGUSR2      12      用户自定义信号2`

- 在**`main`**函数中注册信号处理函数：您需要使用**`signal`**函数将您定义的信号处理函数与特定信号相关联。例如，要捕获**`SIGINT`**信号，可以这样做：

#### 权限设置:

- 文件权限: 自己可以读写，而其他用户只能读 `chmod 644 文件名` 读取（r）、写入（w）和执行（x）| 文件所有者、文件所属组、其他用户
- 如何以root权限运行某个程序。`sudo chown root app（文件名）`  或 `sudo chmod u+s app（文件名）`

#### 查询某一时间之后新增的数据：

`grep "your_timestamp" /path/to/log/file | awk '$1 >= "your_timestamp"'`

## 数据库

### 关系型数据库和非关系型数据库的区别?

1. 关系型数据库有(MySQL、PostgreSQL、Oracle、SQL Server); 非关系型数据库有(MongoDB、Cassandra、Redis、Couchbase、Neo4j)
2. 数据存储结构不同：关系型数据库使用**表格结构(**行记录列字段)，非关系型数据库使用多种数据模型(**键值**, 图, 文档等)。
3. 数据库操纵方法不同：关系型数据库使用结构化查询语言（SQL）进行查询、插入、更新和删除，非关系型数据库通常使用自定义的查询语言或API。
4. 数据一致性：关系型数据库通常支持**ACID事务**，非关系型数据库根据类型可以选择性地支持不同级别的一致性, 更灵活。
5. 适用场景：关系型数据库适合复杂的数据关系和数据完整性要求，非关系型数据库适合大规模分布式环境和强调更容易可扩展性的应用。

### Mysql 数据库**客户端连接**

默认情况下，每个客户端连接都会在服务器进程中拥有一个线程，该连接的查询只会在这
个单独的线程中执行，该线程驻留在一个内核或者CPU上。服务器维护了一个缓存区，用
于存放已就绪的线程，因此不需要为每个新的连接创建或者销毁线程。

当客户端（应用）连接到MySQL服务器时，服务器需要对其进行身份验证。身份验证基
于用户名、发起的主机名和密码。如果以跨传输层安全（TLS）的方式连接，还可以使用
X.509证书认证。客户端连接成功后，服务器会继续验证该客户端是否具有其发出的每个
查询的权限（例如，是否允许客户端对world数据库中的Country表执行SELECT语句）。

### MySQL 的**核心功能(语句，函数， 锁，事务， Schema** 对象(如：**模式， 表， 数据类型， 索引， 视图**)**)**

#### 基本的 **SQL 语句**(查询解析)

- 基本命令
    
    ```sql
    -- 创建新的数据库表
    CREATE TABLE Customers (
        CustomerID INT PRIMARY KEY,
        FirstName VARCHAR(50),
        LastName VARCHAR(50),
        Email VARCHAR(100),
        Age INT
    );
    CREATE TABLE Orders (
        OrderID INT PRIMARY KEY,
        CustomerID INT,
        OrderDate DATE,
        TotalAmount DECIMAL(10, 2)
    );
    -- 修改现有的数据库表结构
    ALTER TABLE Customers ADD Age datatype;
    -- 删除数据库表
    DROP TABLE Customers;
    
    -- 将多行新数据插入数据库表
    INSERT INTO Customers (CustomerID, FirstName, LastName, Email, Age)
    VALUES
        (1, 'John', 'Doe', 'john@example.com', 30),
        (2, 'Jane', 'Smith', 'jane@example.com', 28),
        (3, 'Michael', 'Johnson', 'michael@example.com', 35),
        (4, 'Emily', 'Brown', 'emily@example.com', 22),
        (5, 'David', 'Williams', 'david@example.com', 40);
    INSERT INTO Orders (OrderID, CustomerID, OrderDate, TotalAmount)
    VALUES
        (101, 1, '2023-08-01', 150.00),
        (102, 2, '2023-08-02', 200.00),
        (103, 1, '2023-08-03', 75.50),
        (104, 3, '2023-08-04', 300.00),
        (105, 4, '2023-08-05', 50.00);
    
    -- 更新数据库表中的现有数据
    UPDATE table_name SET column1 = value1, column2 = value2 WHERE condition;
    
    -- 从数据库表中删除数据
    DELETE FROM table_name WHERE condition;
    -- 删除数据库所有数据
    TRUNCATE TABLE table_name;
    DELETE FROM table_name WHERE 1 = 1;
    -- 授予或撤销用户和角色的数据库权限
    GRANT permission ON object TO user;
    REVOKE permission ON object FROM user;
    
    -- 显示数据库、表和列的信息。
    SHOW DATABASES;
    SHOW TABLES;
    DESCRIBE table_name;
    
    -- 创建索引以加快查询速度
    CREATE INDEX index_name ON table_name (column_name);
    
    -- 
    SELECT -- 从数据库中检索数据
        DISTINCT Orders.CustomerID AS CustomerID, SUM(Orders.TotalAmount) as TotalAmount 
    		-- DISTINCT: 结果列检索选项，消除重复项
    		-- AS 为结果列取别名
    		-- 为指定列执行数值计算或替换操作, 如果分组则只在每组内操作
    FROM Orders RIGHT JOIN  Customers ON Customers.CustomerID = Orders.CustomerID
    -- JOIN: 用于连接多个表中的数据
    -- 连接类型 RIGHT 可替换为 INNER、LEFT、RIGHT、FULL
    -- ON: 连接条件
    WHERE Age > 18 -- 原始列筛选条件
    GROUP BY Customers.CustomerID -- 按原始列值进行分组
    HAVING SUM(Orders.TotalAmount)> 10 -- 分组后的原始列筛选条件
    
    ORDER BY TotalAmount DESC, CustomerID ASC -- 按结果列值排序
    LIMIT 10 OFFSET 0 -- 结果列限制返回的行数并分页查询
    
    -- 结果列的数值计算或替换操作
    SELECT SUM(column1),AVG(column1),MIN(column1),MAX(column1),NULLIF(column1, 0) FROM table_name;
    -- WHERE 子句中进行模糊匹配
    SELECT column1 FROM table_name WHERE column1 LIKE 'abc%';
    -- WHERE 子句中匹配多个值
    SELECT column1 FROM table_name WHERE column2 IN (value1, value2, value3);
    -- WHERE 子句中匹配范围内的值
    SELECT column1 FROM table_name WHERE column2 BETWEEN value1 AND value2;
    -- WHERE 子句中匹配 NULL 值
    SELECT column1 FROM table_name WHERE column2 IS NULL;
    -- 计算满足条件的子表行数
    SELECT COUNT(*) FROM table_name WHERE condition;
    -- 用于给列或计算的结果指定别名
    SELECT column1 AS alias_name FROM table_name;
    -- 合并多个 SELECT 查询的结果集
    SELECT column1 FROM table1
    UNION
    SELECT column1 FROM table2;
    -- 检查子查询是否返回结果
    SELECT column1 FROM table_name WHERE EXISTS (SELECT * FROM another_table WHERE condition);
    
    # 执行条件语句并返回不同的值
    SELECT column1,
        CASE
            WHEN condition1 THEN value1
            WHEN condition2 THEN value2
            ELSE value3
        END
    FROM table_name;
    ```
    
- SQL的连接语句 **INNER、LEFT、RIGHT、FULL JION**
    
    ![Untitled](软件工程师.assets/Untitled%2074.png)
    
    1. **inner join（内连接），在两张表进行连接查询时，只保留两张表中完全匹配的结果集。**
    2. **left join,在两张表进行连接查询时，会返回左表所有的行，即使在右表中没有匹配的记录。**
    3. **right join,在两张表进行连接查询时，会返回右表所有的行，即使在左表中没有匹配的记录。**
    4. f**ull join,在两张表进行连接查询时，返回左表和右表中所有没有匹配的行（oracle里面有full join,但是在 mysql 中没有full join）**
    
- 要从一个海量数据库中读取数据，进行计算,避免内存限制问题.
    
    使用数据库查询限制：在执行SQL查询时，使用LIMIT和OFFSET来限制一次从数据库中检索的行数。这可以帮助你分批次地获取数据，而不是一次性获取全部数据。
    
    ```sql
    SELECT * FROM your_table LIMIT 1000 OFFSET 0;
    SELECT * FROM your_table LIMIT 1000 OFFSET 1000;
    ```
    
    使用游标 CURSOR  逐行或逐批地获取数据。
    
    ```sql
    DECLARE cur CURSOR FOR SELECT * FROM your_table;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;
    
    OPEN cur;
    SET done = 0;
    
    -- 逐行处理数据
    WHILE done = 0 DO
      FETCH NEXT FROM cur INTO @var1, @var2, ...; -- 指定所需列
      -- 在这里进行数据处理
    END WHILE;
    
    CLOSE cur;
    ```
    

#### 执行一条 SQL 查询语句，期间发生了什么？

- **Client层**：接收用户输入的SQL，显示响应的结果
- **Server层**：对SQL进行格式的校验、语言分析、优化和执行，并对执行结果进行返回
- 连接器：用户的认证和授权，对接口进行链接
- 缓存：对查询结果进行缓存，并在对缓存进行查询时返回命中结果
- 分析器：SQL的词法分析和语法分析
- 优化器：生成SQL执行计划，操作索引进行数据的查询
- 执行器：操作引擎，利用文件系统返回查询结果
- **文件系统层**：对数据进行持久化

#### MySQL 的 **Schema** 对象(如：**模式， 表， 数据类型， 索引， 视图**)

一个仓库(**database**), 其中有很多房间(s**chema**), 每个房间有自己的负责人(**user**), 内部通过储物柜(**table**)存放物品(**数据**). 

- **表:** 由行（**row**）和列(**column**)组成，是一个二维的网格结构，每个列都是一个字段。字段由**字段名称**和字段的**数据类型**以及一些约束条件组成. 表中至少要有一列，可以有多行或0行，表名要唯一.
- **数据类型**
    
    整数类型: `TINYINT`(8), `SMALLINT`(16), `MEDIUMINT`(24), `INT`(32), `BIGINT`(64),  属性: `UNSIGNED`
    
    实数类型: `FLOAT`(4), `DOUBLE`(8), `DECIMAL`(?)
    
    字符串类型: `VARCHAR`(可变长度, 额外占用字符记录长度), `CHAR`(固定长度, 自动删除尾部空格, 比较时以空格填充), `TEXT`, `BINARY`(二进制字符, 以\0自动填充), `VARBINARY`(), `BLOBTINYTEXTSMALLTEXTMEDIUMTEXTLONGTEXT`()；二进制类型是 `TINYBLOB`(), 
    `SMALLBLOBMEDIUMBLOBLONGBLOBBIT`(自定义位数, 可以存储二进制数, 正常处理视为字符串,数字上下文检索则转换为十进制数字)
    
    枚举类型:  `ENUM`(存储一组预定义的字符串值, 实际存储用整数代替, 减小存储空间, 不易修改)
    
    日期和时间类型: `YEAR`(), `DATEDATETIME`(8, YYYYMMDDHHMMSS格式, 与时区无关), `TIMESTAMP`(4, 存储从1970年1月1日午夜到指定时间经过的秒数, 最终计算值与系统时区有关, 默认设置为当前设置时的事件) 
    
    JSON 数据类型: `JSON`(能提供便利性, 但是存储空间更大, 查询速度更慢)
    
- **索引:** 一种有序的数据结构, 由底层的存储引擎来实现，来协助快速查询、更新数据库表中数据。当进行查询时, MySQL 先在索引结构上按值进行查找，然后返回所有符合条件的记录。索引需要占用额外的存储空间, 并且在对表进行插入、更新和删除操作时，索引结构需要维护，可能会影响性能。**B+树**
    - **索引失效情况:**
        - 当我们使用左或者左右**模糊匹配**的时候，也就是 `like %xx` 或者 `like %xx%`这两种方式都会造成索引失效；
        - 当我们在查询条件中对索引列使用函数，就会导致索引失效。
        - 当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。
        - MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。
        - 联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。
        - 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。
    - **普通索引:** 一张表可以创建多个普通索引，一个普通索引可以包含多个字段，允许数据重复，允许 NULL 值插入；
        
        ```sql
        CREATE INDEX IndexName 
        ON TableName (column1 [ASC|DESC], column2 [ASC|DESC], ...);
        # 或者
        ALTER TABLE TableName ADD INDEX IndexName(column1 [ASC|DESC], column2 [ASC|DESC], ...);
        ```
        
    - **唯一键(唯一键索引):** 值可以为空, 非空值是唯一的, 一个表可以有多个唯一键。
        
        ```sql
        CREATE UNIQUE INDEX IndexName 
        ON TableName (column1 [ASC|DESC], column2 [ASC|DESC], ...);
        # 或者
        ALTER TABLE TableName ADD UNIQUE [IndexName] (column1, column2, ...);
        ```
        
    - **主键(主键索引):** 值不能为空, 必须是唯一的, 每个表只能有一个主键索引. 在  InnoDB 存储引擎中, 如果没有显式地定义主键, 则会生成一个主键
        
        `ALTER TABLE TableName ADD PRIMARY **KEY(**column_list**);**`
        
        首先判断表中是否有非空的**唯一索引**，如果有，则该列即为主键。并在表中有多个非空唯一索引时，ImnoDB 存储引擎会选择建表时第一个定义的非空唯一索引为主键。注意, 是定义索引的顺序，而不是建表时列的顺序。
        
        如果不符合上述条件，InnoDB 存储引擎自动创建一个 6 字节大小的指针。
        
    - **外键(普通索引):** 是表中的一列，用于表⽰其他表的主键，允许重复，可以是空值，用于与其他表建立关联关系。
    - **聚簇索引（clustered index）:** 不只是一种索引类型，还是一种数据存储方式。聚簇索引可以理解为将行数据的逻辑存储与索引顺序结合在了一起，数据表中数据的实际物理存储的逻辑顺序与指定索引的顺序相同, 一般是按照主键索引来排序。同时, 根据**主键索引**构造一棵索引树, 树的**叶子节点存放的都是表的行记录数据(其实一般是表页数据)**。每个表只能有一个**聚簇索引**，因为数据行本身只能按一个顺序存储。
        
        **聚簇索引默认是主键**，如果表中没有定义主键，一般会选择一个**唯一的非空索引**代替。如果没有这样的索引，一般会**隐式定义一个自增的主键**来作为聚簇索引。对于自增的id，对应的数据一定也是相邻地存放在磁盘上的，插入时的写入性能比较高。
        
        **优点**
        
        - 数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快
        - 聚簇索引对于主键的排序查找和范围查找速度非常快
        
        **缺点**
        
        - 插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键（主键列不要选没有意义的自增列，选经常查询的条件列才好，不然无法体现其主键索引性能）
        - .更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。
        - 二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。
    - **非聚簇索引:** 同样是一种数据存储方式, 可以作为辅助索引或者主键索引来使用, 与数据表中数据的逻辑存储顺序无关.作为辅助索引时, 一般是在叶子节点存放对应的**聚簇索引的主键值或直接指向对应的数据行的指针。**作为主键索引时, 一般直接包含**指向对应的数据行的指针。非聚簇索引之间一般是独立的.**
- **视图**

#### SQL 语句解析 和  SQL语句优化

##### 优化速度

- 数据库响应慢，有哪些可能原因: **查询操作太发杂, 缺乏索引或索引失效, 数据量过大, 硬件资源不足, 大量并发连接, 锁竞争等待, 错误的数据库配置, 慢查询, 网络延迟,** 
- 数据库优化效果：数据库表结构>系统配置>硬件
- 数据库优化成本：硬件>系统配置>数据库表结构
    
**最大化利用索引**
- 优先考虑为 where、order by 使用到的字段建立索引。
**`CREATE INDEX idx_salary ON employees(salary); SELECT * FROM employees WHERE salary > 50000;`**   
- 尽量使⽤整数或者枚举替代字符串类型
- 尽量使⽤TINYINT，SMALLINT，MEDIUM_INT替代INT类型，如果是⾮负则加上UNSIGNED
- 用varchar/nvarchar 代替 char/nchar
- VARCHAR的长度只分配真正需要的空间
- 时间类型尽量使⽤TIMESTAMP⽽⾮DATETIME
- 尽量少使⽤ NULL，很难查询优化⽽且占⽤额外索引空间
    通常情况下最好指定列为NOT NULL，除非明确需要存储NULL值。如果查询中包含可为NULL的列，对MySQL来说更难优化，因为可为NULL的列使得索引、索引统计和值比较都更复杂。
- 使用索引列作为条件进行查询时，尽量避免使用 <> 或者 ≠ 等判断条件
- 避免因为隐式类型转换造成不能使用索引（索引对列类型为 varchar `select col1 from table where col_varchar=123;`
- 同时使用 where 和其他排序条件时，如 order by 等条件要与 where 中条件一致，否则 order by 不会利用索引进行排序 `SELECT * FROM t where age > 0 order by age;`  不走 age 索引：  `SELECT * FROM t order by age; 
- 正确使用 hint 优化语句

**尽可能避免全表扫描**

- 尽量避免在字段开头就使用模糊查询，会导致数据库引擎放弃索引进行全表扫描。`SELECT * FROM t WHERE username LIKE '陈%'`  而不是 `SELECT * FROM t WHERE username LIKE '%陈%'`
- 尽量避免使用 in 和 not in，会导致数据库引擎进行全表扫描
- 对于连续数值使用`SELECT * FROM t WHERE id BETWEEN 2 AND 3` **  而不是** `SELECT * FROM t WHERE id` ** ** `IN (2,3)``**
- 尽量避免使用 or，会导致数据库引擎放弃索引进行全表扫描（用 union 代替 or）`SELECT * FROM t WHERE id = 1 UNION SELECT * FROM t WHERE id = 3`  而不是 `SELECT * FROM t WHERE id = 1 OR id = 3`
- 尽量避免进行 null 值的判断，会导致数据库引擎放弃索引进行全表扫描`SELECT * FROM t WHERE score = 0` 而不是 `SELECT * FROM t WHERE score IS NULL`
- 尽量避免在 where 条件中等号的左侧进行表达式、函数操作，会导致数据库引擎放弃索引进行全表扫描。 `SELECT * FROM T WHERE score = 10*9` 而不是`SELECT * FROM T WHERE score/10 = 9` 

- 当数据量大时，避免使用where 1=1的条件。`SELECT username, age, sex FROM T WHERE 1=1`

**减少无效数据的查询**

- 避免出现 select *，指定需要的列名
- 避免使用出现随机结果的函数，导致主库与从库相应的数据不一致。
- 多表关联查询时，小表在前，大表在后。
- 使用表的别名，减少解析的时间并减少哪些友列名歧义引起的语法错误。
- 用 where 字句替换 HAVING字句，避免在检索出所有记录之后才对结果集进行过滤，而是在Join 前先过滤数据，减少后续开销。
- 调整Where字句中的连接顺序，将过滤数据多的条件往前放，最快速度缩小结果集。
- 优化 group by 语句, 取消默认的值排序。`SELECT col1, col2, COUNT(*) FROM table GROUP BY col1, col2 ORDER BY NULL ;`
- 多表时，使用 join 语句优化部分子查询工作速度，避免在内存中创建临时表`SELECT col1 FROM customerinfo LEFT JOIN salesinfoON customerinfo.CustomerID=salesinfo.CustomerID WHERE salesinfo.CustomerID IS NULL`  而不是 `SELECT col1 FROM customerinfo WHERE CustomerID NOT in (SELECT CustomerID FROM salesinfo )`
- 除非确实要消除重复的行，否则使用 union all，避免给临时表加上 distinct 选项，导致对整个临时表的数据做唯一性校验。`SELECT COL1, COL2, COL3 FROM TABLE WHERE COL1 = 10 UNION ALL SELECT COL1, COL2, COL3 FROM TABLE WHERE COL3= 'TEST';`  而不是  `SELECT COL1, COL2, COL3 FROM TABLE WHERE COL1 = 10 UNION SELECT COL1, COL2, COL3 FROM TABLE WHERE COL3= 'TEST';`
- 在单表时，使用合理的分页方式以提高分页效率，避免一次性获取全部数据造成性能问题和资源浪费。
- 直接分页（翻到后面执行效率）：`select * from t where thread_id = 10000 and deleted = 0`  `order by gmt_create asc limit 0, 15;`   利用索引列分页： `select t.* from (select id from t where thread_id = 10000 and deleted = 0 order by gmt_create asc limit 0, 15) a, t where a.id = t.id;` 

**增删改数据优化**

- 大批量插入数据时，使用插入多个值的 INSERT 语句`Insert into T values(1,2),(1,3),(1,4);`
- 适当使用commit，释放事务占用的资源（undo数据块，redo log中记录的数据块，减少锁争用影响性能）而减少消耗
- 避免在更新数据后，重复查询杠更新的数据。
- 使用变量预存数据：** `Update t1 set time=now () where col1=1 and @now: = now (); Select @now;` **  
- 查询优先还是更新（insert、update、delete）优先

##### 优化读写冲突

**使用事务：** 事务是一组数据库操作，它们被视为一个单一的操作单元。在事务中，你可以执行多个读取和写入操作，并且只有在事务成功提交之后，所有的更改才会生效。如果发生冲突，事务可以回滚到之前的状态。使用事务可以确保数据的一致性和隔离性，防止并发冲突。

**使用锁机制：** 数据库锁是一种控制并发访问的机制，它可以防止同时对同一数据进行读写操作。通过合理使用锁，可以防止数据冲突和数据竞争。但需要注意的是，过度使用锁可能会影响性能，因此需要权衡。

**乐观并发控制：** 在乐观并发控制中，操作首先进行读取，然后在执行写入之前再次检查数据是否发生变化。如果在读取和写入之间有其他操作修改了数据，系统会检测到并拒绝写入。这可以避免阻塞，但需要处理写入被拒绝的情况。

**悲观并发控制：** 悲观并发控制通过在访问数据时进行加锁，防止其他操作修改数据。虽然这可以有效地避免并发冲突，但可能导致性能问题和阻塞。

**分布式数据库和缓存：** 在分布式环境中，使用分布式数据库或缓存可以帮助管理并发冲突。这些系统通常具有内置的并发控制机制。

**定时任务和队列：** 如果冲突可能会在未来的时间点发生（例如，定时任务或批处理作业），可以使用队列和定时任务来串行执行操作，以避免冲突。
    

##### 优化多表冲突

**使用事务：** 事务是一组数据库操作，它们被视为一个单一的操作单元。在事务中，你可以执行多个读取和写入操作，并且只有在事务成功提交之后，所有的更改才会生效。如果发生冲突，事务可以回滚到之前的状态。使用事务可以确保数据的一致性和隔离性，防止并发冲突。

**使用锁机制：** 数据库锁是一种控制并发访问的机制，它可以防止同时对同一数据进行读写操作。通过合理使用锁，可以防止数据冲突和数据竞争。但需要注意的是，过度使用锁可能会影响性能，因此需要权衡。

**观并发控制：** 在乐观并发控制中，操作首先进行读取，然后在执行写入之前再次检查数据是否发生变化。如果在读取和写入之间有其他操作修改了数据，系统会检测到并拒绝写入。这可以避免阻塞，但需要处理写入被拒绝的情况。

**悲观并发控制：** 悲观并发控制通过在访问数据时进行加锁，防止其他操作修改数据。虽然这可以有效地避免并发冲突，但可能导致性能问题和阻塞。

**分布式数据库和缓存：** 在分布式环境中，使用分布式数据库或缓存可以帮助管理并发冲突。这些系统通常具有内置的并发控制机制。

**定时任务和队列：** 如果冲突可能会在未来的时间点发生（例如，定时任务或批处理作业），可以使用队列和定时任务来串行执行操作，以避免冲突。

#### MySQL **内置函数**

- `COUNT()`：计算查询结果集中行的数量。
- `SUM()`：计算列的总和。
- `AVG()`：计算列的平均值。
- `MIN()`：返回列的最小值。
- `MAX()`：返回列的最大值。
- `CONCAT()`：将两个或多个字符串合并成一个字符串。
- `SUBSTRING()`：返回字符串的子串。
- `LOWER()`：将字符串转换为小写。
- `UPPER()`：将字符串转换为大写。
- `LEFT()`：返回字符串左边的字符。
- `RIGHT()`：返回字符串右边的字符。
- `LENGTH()`：返回字符串的长度。
- `TRIM()`：去除字符串两侧的空格。
- `ROUND()`：将数值四舍五入为指定的小数位数。
- `NOW()`：返回当前日期和时间。
- `DATE_FORMAT()`：将日期按照指定的格式进行格式化。
- `IF()`：如果条件成立则返回一个值，否则返回另一个值。

#### 并发控制: 锁(共享锁,排他锁|乐观锁,悲观锁|表锁,行级锁,页锁)

**共享锁(读):** 多个客户端可以同时读取同一个资源而互不干扰。
**排他锁(写):** 一个写锁既会阻塞读锁也会阻塞其他的写锁. 从而确保在特定的时间点只有一个客户端能执行写入，并防止其他客户端读取正在写入的资
源。

```sql
-- 共享锁示例
START TRANSACTION;
SELECT * FROM table_name WHERE id = 1 LOCK IN SHARE MODE;

-- 排他锁示例
START TRANSACTION;
SELECT * FROM table_name WHERE id = 1 FOR UPDATE;
```

**悲观锁/排他锁(并发写): 在读取数据前就获取写锁，以防止其他事务对数据进行修改。**

```sql
-- 开始事务
START TRANSACTION;
-- 查询并锁定某一行数据，以防止其他事务修改
SELECT * FROM your_table WHERE id = 1 FOR UPDATE;
-- 对获取的行进行操作
-- 提交事务
COMMIT;

-- 开始事务
START TRANSACTION;
-- 锁定整个表
LOCK TABLE your_table WRITE;
-- 对表进行操作
-- 提交事务
COMMIT;
-- 解锁表
UNLOCK TABLE;

-- 开启事务
START TRANSACTION;
-- 锁定特定行（共享锁）
SELECT * FROM your_table WHERE id = 1 LOCK IN SHARE MODE;
-- 对获取的行进行操作
-- 提交事务
COMMIT;
```

**乐观锁(并发读): 允许多个事务同时访问数据，但在更新数据时会检查数据是否被其他事务修改过。如果检测到冲突，乐观锁会阻止数据的更新操作。**

```sql
-- 开始事务
START TRANSACTION;
-- 获取数据并记录版本号
SELECT data, version FROM your_table WHERE id = 1;
-- 记录获取的版本号（或时间戳）

-- 在更新数据时检查版本号，如果版本号不匹配，则表示数据已被其他事务修改，不进行更新
UPDATE your_table SET data = 'new data', version = version + 1 WHERE id = 1 AND version = <record_version>;

-- 在事务完成后，通过提交或回滚来释放锁
COMMIT;
```

根据锁的粒度可分为(**表锁, 行级锁, 页锁**): 尽量只锁定包含需要修改的部分数据，而不是所有的资源。

**表锁（table lock）** 是 MySQL 中最基本也是开销最小的锁策略。表锁非常类似于前文描述的电子表格的锁机制：它会锁定整张表。当客户端想对表进行写操作（插入、删除、更新等）时，需要先获得一个写锁，这会阻塞其他客户端对该表的所有读写操作。只有没有人执行写操作时，其他读取的客户端才能获得读锁，读锁之间不会相互阻塞。表锁有一些变体，可以在特定情况下提高性能。例如，READ LOCAL 表锁支持某些类型的并发写操作。写锁队列和读锁队列是分开的，但写锁队列的优先级绝对高于读队列。

**行级锁（row lock）** 可以最大程度地支持并发处理（也带来了最大的锁开销）。回到电子表格的类比，行级锁等同于锁定电子表格中的某一行。这种策略允许多人同时编辑不同的行，而不会阻塞彼此。这使得服务器可以执行更多的并发写操作，带来的代价则是需要承担更多开销，以跟踪谁拥有这些行级锁、已经锁定了多长时间、行级锁的类型，以及何时该清理不再需要的行级锁。行级锁是在存储引擎而不是服务器中实现的。服务器通常不清楚存储引擎中锁的实现方式。

**页锁：** 粒度介于行级锁和表级锁中间的一种锁，表示对页进行加锁。

##### 实现锁的具体原理

1. 锁的存储：MySQL使用内存中的数据结构来存储锁的信息。每个数据对象（行、表等）都有一个与之关联的锁信息，用于记录当前持有锁的事务以及锁的类型。
2. 锁的获取：当一个事务需要获取锁时，它会向MySQL的锁管理器发送请求。锁管理器会检查当前锁的状态，如果锁可用，则将锁授权给请求的事务，事务成为锁的持有者。如果锁不可用，则请求的事务进入等待状态，直到锁可用或超时。
3. 锁的冲突处理：当一个事务请求获取锁时，锁管理器会检查该锁与其他已存在的锁之间是否存在冲突。如果存在冲突（如共享锁与排他锁冲突），则根据锁的类型和事务的隔离级别来确定是否允许获取锁。如果允许获取锁，则锁授予请求的事务；如果不允许获取锁，则请求事务进入等待状态。
4. 锁的释放：当事务完成对数据的操作后，它会显式或隐式地释放持有的锁。锁管理器将解除事务对锁的持有，并将锁标记为可用，以供其他事务获取。

#### 并发控制: **事务**

**事务**可看作是对数据库操作的基本执行单元，其中包含一个或者多个SQL语句. 提供了**提交**(将事务执行结果写入数据库)和**回滚**(回滚所有已经执行的语句，返回修改之前的数据。)操作.

##### 事物特性: MySQL的事务具有ACID特性, 原子性, 一致性, 隔离性, 持久性.

- 持久性：事务完成后，对数据库数据的修改被持久化存储
- 隔离性：如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离
- 一致性：事务完成后, 必须满足一定的条件. 这种一致性是一种需要管理员去定义的规则。管理员如何指定规则，数据库就严格按照这种规则去处理数据。
- 原子性：事务的所有SQL操作作为原子工作单元执行，要么全部执行，要么全部不执行

##### 事物实现原理(日志实现原子性和持久性,锁实现隔离性)

1. **日志（Log）**：MySQL使用日志来记录事务的操作，以实现事务的原子性和持久性。在事务执行过程中，MySQL将所有的操作记录到事务日志（Transaction Log）中，包括对数据的修改和索引的更新。这样，即使在系统崩溃或故障后，MySQL可以通过回放事务日志来恢复到事务执行前的状态，保证事务的原子性和持久性。
2. **锁（Lock）**：MySQL使用锁来实现事务的隔离性。通过对数据对象（行、表等）进行锁定，MySQL确保每个事务的操作在同一时间只能由一个事务执行，避免了并发操作的冲突。锁的类型包括共享锁（Shared Lock）和排他锁（Exclusive Lock），用于控制读写操作的并发访问。

##### 事务的隔离级别隔离级别: 未提交读 | 提交读 | 可重复读 | 可串行化

**READ UNCOMMITTED（未提交读）:** 事务中可以查看其他事务中还没有提交的修改。读取未提交的数据，也称为**脏读（dirty read）**。

**READ COMMITTED（提交读）:** 大多数其他数据库系统的默认隔离级别. 一个事务可以看到其他事务在它开始之后提交的修改，但在该事务提交之前，其所做的任何修改对其他事务都是不可见的。这个级别仍然允许不可重复读（nonrepeatable read），这意味着同一事务中两次执行相同语句，可能会看到不同的数据结果。

**REPEATABLE READ（可重复读）:** MySQL默认的事务隔离级别, 解决了可重复读问题, 保证了在同一个事务中多次读取相同行数据的结果是一样的。但是没解决幻读（phantom read）的问题. **幻读，**指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行（phantom row）。

**SERIALIZABLE（可串行化）:** 最高的隔离级别。该级别通过强制事务按序执行，使不同事务之间不可能产生冲突，从而解决了前面说的幻读问题。简单来说，SERIALIZABLE会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。

**脏读**：当前事务中读到其他事务未提交的数据，也就是脏数据。

**不可重复读**：在事务A中先后两次读取同一个数据，但是两次读取的结果不一样。脏读与不可重复读的区别在于：前者读到的是其他事务未提交的数据，后者读到的是其他事务已提交的数据。

**幻读**：在事务 A 中按照某个条件先后两次查询数据库，两次查询结果的行数不同，这种现象称为幻读。不可重复读与幻读的区别可以通俗的理解为：前者是数据变了，后者5是数据的行数变了。

##### **死锁:** 两个或多个事务相互持有和请求相同资源上的锁，产生了循环依赖。

- 当多个事务试图以不同的顺序锁定资源时会导致死锁。事物1锁住A去访问B; 事物2锁住B去访问A.
- 当多个事务锁定相同的资源时，也可能会发生死锁。事物1和事物2同时去锁住A.
- 一旦发生死锁，如果不回滚其中一个事务（部分或全部），就无法打破死锁。对于事务型的系统，这是无法避免的，所以应用程序在设计时必须考虑如何处理死锁。大多数情况下只需要重新从头开始执行被回滚的事务即可，除非又遇到另一个死锁。
    

### MySQL 的**日志文件（错误日志，慢查询日志，查询日志，二进制日志，重做回滚日志）**

#### 错误日志

对 MySQL 的启动、运行、关闭过程进行了记录。MySQL DBA在遇到问题时应该首先查看该文件以便定位问题。该文件不仅记录了所有的错误信息，也记录一些警告信息或正确的信息。用户可以通过命令 `SHOW VARIABLES LIKE 'log_error'` 来定位该文件.
    
当出现MySQL数据库不能正常启动时，第一个必须查找的文件应该就是错误日志文件，该文件记录了错误信息，能很好地指导用户发现问题。
    

#### 慢查询日志:

(slow log)可帮助定位可能存在问题的SQL语句，从而进行SOL语句层面的优化。例如，可以在 MySQL 启动时设一个值，将运行时间超过该值的所有 SOL 语句都记录到慢查询日志文件中。该值可以通过参数 `long_query_time` 来设置，默认值为 10，代表10秒 `SHOW VARIABLES LIKE long_query_time'\G;` 。

#### 查询日志:

记录了所有对 MySOL 数据库请求的信息，无论这些请求是否得到了正确的执行。默认文件名为: `主机名.log` 。

#### 二进制日志:

(binary log)记录了对 MySQL 数据库可能执行更改的所有操作，但是不包括 SELECT 和 SHOW 这类操作，因为这类操作对数据本身并没有修改。
    

##### 二进制日志主要有以下几种作用:**

- **恢复 (recovery):** 某些数据的恢复需要二进制日志，例如，在一个数据库全备文件恢复后，用户可以通过二进制日志进行 point-in-time的恢复。
- **复制(replication):** 其原理与恢复类似，通过复制和执行二进制日志使一台远程的MySQL数据库(一般称为 slave 或standby)与一台MySQL数据库(一般称为master或primary)进行实时同步。
- **审计(audit):** 用户可以通过二进制日志中的信息来进行审计，判断是否有对数据库进行注入的攻击。

#### 表结构定义文件:

以 frm 为后缀名的文件, MySQL 存储的每个数据表都会有此文件, 其中记录了该表的表结构定义, 视图的定义.

#### 存储引擎文件 - 表空间文件

用于存储表数据, 如数据, 索引, 插入缓冲 BITMAP 等信息, 可以通过 `innodb_data_file_path` 设置多个表空间文件, 用于磁盘的负载均衡; 通过 `innodb_file_per_table` 设置为单独生成独立表空间文件.

#### 存储引擎文件 - 重做日志文件:

记录了对于InoDB存储引警的事务日志。例如，数据库由于所在主机掉电导致实例失败，InnoDB 存储引擎会使用重做日志恢复到掉电前的时刻，以此来保证数据的完整性。

事务日志有助于提高事务的效率。存储引擎只需要更改内存中的数据副本，而不用每次修改磁盘中的表，这会非常快。然后再把更改的记录写入事务日志中，事务日志会被持久化保存在硬盘上。因为事务日志采用的是追加写操作，是在硬盘中一小块区域内的顺序I/O，而不是需要写多个地方的随机I/O，所以写入事务日志是一种相对较快的操作。最后会有一个后台进程在某个时间去更新硬盘中的表。

如果修改操作已经写入事务日志，那么即使系统在数据本身写入硬盘之前发生崩溃，存储引擎仍可在重新启动时恢复更改。具体的恢复方法则因存储引擎而异。
    

#### 存储引擎文件 - 回滚日志文件:

#### 重做日志文件和二进制日志文件有什么区别?

    
首先，二进制日志会记录所有与 MySQL数据库有关的日志记录，包括 InoDBMyISAM、Heap 等其他存储引擎的日志。而 InnoDB 存储引擎的重做日志只记录有关该存储引擎本身的事务日志。

其次，记录的内容不同，无论用户将二进制日志文件记录的格式设为 STATEMENT 还是 ROW，又或者是 MIXED，其记录的都是关于一个事务的具体操作内容，即该日志是逻辑日志。而 InnoDB 存储引擎的重做日志文件记录的是关于每个页 (Page)的更改的物理情况。

此外，写入的时间也不同，二进制日志文件仅在事务提交前进行提交，即只写磁盘一次，不论这时该事务多大。而在事务进行的过程中，却不断有重做日志条目 (redoentry) 被写入到重做日志文件中。

### MySQL 存储引擎层（索引组织结构，InnoDB，MyISM ）

#### 索引组织结构: B+ 树

##### 为什么 MySQL 数据库要用 B+ 树存储索引?

树的话，无非就是前中后序遍历、二叉树、二叉搜索树(二叉排序树)、平衡二叉树，更高级一点的有 [红黑树](#^c3449d)、[B树](#^79488e)、[B+树](#^68ecec)，还有之前你教我的字典树。

对于基础的二叉排序树来说, 只需要保证左边比根节点小,  右边比根节点大即可.

考虑到极端情况下, 后续插入的值如果都比根节点大或小,二叉排序树就会退化成了序列或链表. 因此为了解决这个问题, 提出了 [平衡二叉树](#^8f3141) 在插入的时候同时调整树的分布, 使得任一节点对应的两棵子树的最大高度差为1. 对于另一种平衡二叉树吗红黑树来说, 红黑树相对于AVL树，牺牲了部分平衡性以换取插入和删除操作时少量的旋转操作，整体来说性能要优于AVL树。

因为对于数据库来说, 索引数据存储在硬盘中, 因此每次进入节点都相当于一次 IO操作, 比内存中慢很多. 所以要优化树的高度, 来减少 IO操作次数, 因此提出了多路搜索树, B树.  B树 是一种多路搜索树，它的每个节点可以拥有多于两个子节点。M 路的 B树 最多能拥有 M 个子节点。M 应该设置为合适的值, 并不是越大越好, 如果太大了, 会逐渐退化为有序数组或有序链表, 导致数据无法一次性加载到内存中. B树的多路, 是通过每次加载B树的一个节点, 一步步往下找的.

因为数据库通常要涉及范围查询, 体现在树的索引结构上来看, 就是说在查找时需要进行跨层访问. 即, 对于B树来说, 需要做局部遍历. 所以提出了 B+树来解决此问题. B+树是在B树的基础上进行改造，它的数据都存储在叶子结点，同时叶子结点之间还加了指针形成链表。B+ 树由于所有数据都在叶子结点，不用跨层，同时由于有链表结构，只需要找到首尾，通过链表就能把所有数据取出来了。
    

#### 索引组织结构: 哈希表

MyIsam 只支持表锁，而 InnoDB 同时支持表锁和行锁，且出于性能考虑，绝大多数情况下使用的都是行锁。

- InnoDB
- **逻辑存储结构(索引组织表, 表空间, 段, 区, 页, 行):**
    
     InnoDB 存储引擎中，**[表](https://www.notion.so/f51ddacaf59e418798c51469a4c4b2e3?pvs=21)**都是根据主键顺序组织存放的(**聚簇索引模式**)，这种存储方式的表称为索引组织表。
    
    在 InnoDB 存储引擎表中，每张表都有个**[主键](https://www.notion.so/f51ddacaf59e418798c51469a4c4b2e3?pvs=21)**，如果在创建表时没有显式地定义主键，则 InnoDB 存储引擎会按照一定方式选择或生成主键.
    
    - **行(row):** 表数据按行进行存放.
        - **行格式** `REDUNDANT` : 为了与旧版本兼容的格式.
            
            存储方式：
            
            ![Untitled](软件工程师.assets/Untitled%2075.png)
            
            - **字段长度偏移列表**
                
                首部是一个**所有字段的长度偏移列表**，记录所有字段的长度偏移，包括隐藏列。偏移就是，第一个字段长度为 a，第二个字段长度为 b，那么列表中第一个字段就是 a，第二个字段就是 a + b。所有字段的偏移长度按照逆序存储。这样可以采用两个相邻数值的差值来计算各个字段的长度。
                
                每个**字段的长度存储大小**用一个字节还是两个字节，在记录头信息里面有标记：
                
                - 如果整行长度小于 128，则每个字段的长度用一字节存储.
                - 如果大于等于 128，则每个字段的长度用两个字节存储.
                
                **对 NULL 值的处理**
                
                - 对于一字节存储，**最高位标记字段是否为 NULL**，如果为 NULL，则最高位为1，否则为0. 剩下的 7 位用来存储长度，所以最多是 127.
                - 对于两字节存储，**最高位还是标记字段是否为NULL**。**第二位标记这条记录是否还有溢出**，如果有则为0，如果没有则为1。剩下的 14 位表示长度，所以最多是 16383.
            - **记录头信息**占用 6 字节，48个二进制位。
                
                ![Untitled](软件工程师.assets/Untitled%2076.png)
                
                `n_fields` 值代表一行中列的数量，占用10位，这也说明了 Redundant 行格式一行最多支持1023列。
                
                `1byte_offs_flags` 值表示偏移列表占用 1 字节还是 2 字节。
                
            
        - **行格式** `COMPACT` :
            
            存储方式：
            
            ![Untitled](软件工程师.assets/Untitled%2077.png)
            
            - 非 NULL **变长的字段长度偏移列表**
                
                首部是一个字段长度偏移列表，记录所有字段的长度偏移，包括隐藏列、NULL值列。
                
                每个**字段的长度存储大小**用一个字节还是两个字节，：
                
                - 若列的长度小于 255 字节，用 1 字节表示;
                - 若大于 255 个字节，用 2 字节表示。
            - **NULL 标记位:** 指示该行数据中是否有 NULL 值，有则用 1 表示。
                
                每个列对应一个二进制位, 二进制位按照列的顺序逆序排列。
                
                - 二进制位的值为`1`时，代表该列的值为NULL。
                - 二进制位的值为`0`时，代表该列的值不为NULL。
                
                NULL值列表必须用整数个字节的位表示（1字节8位），如果使用的二进制位个数不足整数个字节，则在字节的高位补`0`。
                
            - **记录头信息**占用 5 字节，40 个二进制位。
                
                ![Untitled](软件工程师.assets/Untitled%2078.png)
                
                与 Redundant 格式相比，少了 `n_fields`,  `1byte_offs_flag` 两个属性，多了 `record_type` 属性。
                
            - **记录真实数据**
                
                最后的部分就是实际存储每个列的数据。注意 NULL 不占该部分任何空间，即 NULL 除了占有NULL值列表的标志位，实际存储不占有任何空间。
                
                每行数据除了用户定义的列外，在开头还有两个隐藏列，`事务ID列（DB_TRX_ID）`和`回滚指针列（DB_ROLL_PTR）`，分别为`6字节`和`7字节`的大小。若InnoDB表没有定义主键，每行还会增加一个`6字节`的`行ID列（DB_ROW_ID）`。
                
                为这个 row_id 隐藏列赋值的方式如下：
                
                - 服务器会在内存中维护一个全局变量，每当向某个包含隐藏的`row_id`列的表中插入一条记录时，就会把该变量的值当作新记录的`row_id`列的值，并且把该变量自增`1`。
                - 每当这个变量的值为`256`的倍数时，就会将该变量的值刷新到`系统表空间`的页号为`7`的页面中一个`Max Row ID`的属性处。
                - 当系统启动时，会将页中的`Max Row ID`属性加载到内存中，并将该值加上`256`之后赋值给全局变量，因为在上次关机时该全局变量的值可能大于页中`Max Row ID`属性值。
        - **行格式** `DYNAMIC` :
        - **行格式** `COMPRESSED` :
        如果行字段的值发生了溢出, 即存放了长度很大的可变长数据, 则会将多出的数据存放到其他区域(溢出页)中, 并保存其所在地址. `COMPACT` 和 `REDUNDANT` 会分两部分保存(前768字节+指向溢出部分的指针); `DYNAMIC` 和 `COMPRESSED` 则会将数据全部存放在溢出区域, 只保存(指向溢出部分的指针).

    - 页 (page): 每个表实际存储时, 将数据分割为页来管理, 页也是InnoDB 存储引擎磁盘管理的最小单位. 同时由于页的特殊结构, 可以通过 B+ 树的方式来管理页.

        每个页**默认大小**为16KB, 即每个页最多允许存放16KB/2-200，即 7992 行记录。可以通过参数 innodb_page_size 将页的大小设置为4K、8K、16K。若设置完成，则所有表中页的大小都为 innodb_page_size，不可以再次对其进行修改，除非通过 mysqldump 导入和导出操作来产生新的库。
        
        在 InnoDB 中的设计中，页与页之间是通过一个**双向链表**连接起来。而存储在页中的一行一行的数据则是通过**单链表**连接起来的。并通过**最大**和**最小**的记录指示当前页中存储的行记录的区域范围. 最后通过一个**目录槽**实现对页内行数据的粗略二分查找.
        
        InnoDB 数据页一般由以下 7 个部分组成:
        
        - File Header (文件头, 38 字节), 记录当前页的头信息(一致性校验, 上下页指针, 页偏移值等)
            
            ![Untitled](软件工程师.assets/Untitled%2079.png)
            
            页类型有如下几种:
            
            ![Untitled](软件工程师.assets/Untitled%2080.png)
            
        - Page Header (页头, 56 字节), 记录数据页的状态信息.
            
            ![Untitled](软件工程师.assets/Untitled%2081.png)
            
            ![Untitled](软件工程师.assets/Untitled%2082.png)
            
        - Infimun 和 Supremum Records, 用于存储数据页中主键值最小的值和最大的值.
        - User Records (用户记录，即行记录, 单链表存储), 实际存储的行格式数据.
        - Free Space (空闲空间), 当一条行记录被删除后, 其空间被加入到空闲链表中.
        - Page Directory (页目录), 一个稀疏目录, 存储了部分行记录的页相对位置, 用于提供粗略的二叉查找.
            
            
        - File Trailer (文件结尾信息, 8 字节), 用于检测该页的完整性.
            - 前 4 字节代表该页的 checksum值
            - 最后 4 字节和 File Header 中的 FIL PAGE LSN 相同。
            
            将这两个值与 File Header 中的 FIL PAGE SPACE OR CHKSUM 和 FIL PAGE LSN 值进行比较，看是否一致，以此来保证页的完整性。
            
            在默认配置下，InnoDB 存储引擎每次从磁盘读取一个页就会测该页的完整性，即页是否发生 Corrupt，这就是通过 File Trailer 部分进行检测，而该部分的检测会有一定的开销。
            
        
        为了检测页是否已经完整地写入磁盘(如可能发生的写人过程中磁盘损坏、机器关机等)，InnoDB 存储引擎的页中设置了 File Trailer 部分。
        
    - **区 (extent):** 由连续页组成的空间，在任何情况下每个区的大小都为1MB。为了保证区中页的连续性，InonoDB 存储引擎一次从磁盘申请4-5个区。
        
        
    - **段 (segment): 表空间是由各个段组成的，常见的段有数据段、索引段、回滚段等。**
        
        数据段即为 B+ 树的叶子节点
        
        索引段即为 B+ 树的非索引节点
        
        回滚段
        
    - **表空间:** 表的所有数据都被逻辑地存放在一个空间中，称之为表空间(tablespace)
        
        在默认情况下，InnoDB存储引擎都有一个共享表空间ibdata1，即所有数据都存放在这个表空间内。如果用户启用了参数innodb_file_per_table，则每张表内的数据可以单独放到一个表空间内。
        
        如果启用了innodb_file_per_table参数，也需要注意，每张表的表空间存放的只是数据、索引和插入缓冲Bitmap页，其它类的数据，如回滚(undo)信息，插入缓冲索引页、系统事务信息，二次写缓冲等还是存放在原来的共享表空间内。

    **内存结构: Buffer Pool** 用于加速数据的访问和修改，通过将热点数据缓存在内存的方法，当需要查询或修改数据时，InnoDB 首先会检查 Buffer Pool 中是否已经有相关的数据页。如果存在，它将直接从内存中获取数据，而不必从磁盘读取, 最大限度地减少磁盘 IO，加速热点数据的读和写。
    
    **内存结构: Change Buffer** 用于加速非热点数据中二级索引的写入操作。由于二级索引数据的不连续性，导致修改二级索引时需要进行频繁的磁盘 IO 消耗大量性能，Change Buffer 会暂时缓冲对二级索引的修改操作，同时将写操作录入 redo log 中，在缓冲到一定量或系统较空闲时进行 `ibuf merge` 操作将修改写入磁盘中。Change Buffer 在系统表空间中有相应的持久化区域。
    
    **内存结构: Adaptive Hash Index** 用于实现对于热数据页的一次查询性能。使用聚簇索引进行数据页定位的时候需要根据索引树的高度从根节点走到叶子节点，通常需要 3 到 4 次查询才能定位数据。InnoDB 根据对索引使用情况的分析和索引字段的分析，通过自调优 Self-tuning 的方式为索引页建立或者删除哈希索引。
    
    **内存结构: Log Buffer** 用于暂时缓冲日志文件的写入操作。考虑到, 对于任何修改操作，mysql 都会将其录入到诸如 redo log 与 undo log 这样的日志文件中，并且这种对日志文件的写入操作非常频繁, 这些文件也都存储在磁盘中，将引发大量的磁盘 IO。Log Buffer 将分散的写入操作放在内存中，通过定期批量写入磁盘的方式提高日志写入效率和减少磁盘 IO。
    
    **磁盘结构: 表空间** 在磁盘中，InnoDB 将所有数据(表数据, 索引, 插入缓冲 Bitmap 页等)都逻辑地存放在一个空间中，称为表空间（Tablespace）。表空间由段（Segment）、区（extent）、页（Page）组成。每个表都有一个或多个表空间。
    
    **后台线程: Master Thread**  主要的任务是把缓冲池中的数据异步刷新到磁盘中，保证数据的一致性，包括脏页的刷新、合并插入缓存（insert buffer）、回滚页（undo）的回收等。
    
    **后台线程: IO Thread** 在InnoDB中大量使用了AIO（Async IO）来处理写IO请求，这样可以极大提高数据库的性能。而IO Thread的工作主要负责这些IO请求的回调（call back）处理. 
    
    **后台线程: Purge Thread** 事务被提交后，其所使用的undo log可能不再需要，因此需要Purge Thread来回收已经使用并分配的undo页. 
    
    **后台线程: Page Cleaner Thread** 其作用是将之前版本中脏页的刷新操作都放入到单独的线程中来完成。而其目的是为了减轻原Master Thread的工作及对于用户查询线程的阻塞，进一步提高InnoDB存储引擎的性能
    
- **InnoDB** 使用的是聚簇索引，将主键组织到一棵B+树中，而**行数据就储存在叶子节点**上，若使用"where id = 14"这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。若对Name列**进行条件搜索**，则需要两个步骤：**第一步**在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。**第二步**使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。（重点在于通过其他键需要建立辅助索引）
    
    1. 由于**行数据和叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，已经把页加载到了Buffer中，再次访问的时候，会在内存中完成访问**，不必访问磁盘。这样**主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回**了，**如果按照主键Id来组织数据，获得数据更快**。
    1. **辅助索引使用主键作为"指针"而不是使用地址值作为指针的好处**是，**减少了当出现行移动或者数据页分裂时辅助索引的维护工作**，**使用主键值当作指针会让辅助索引占用更多的空间，换来的好处是InnoDB在移动行时无须更新辅助索引中的这个"指针"**。**也就是说行的位置（实现中通过16K的Page来定位）会随着[数据库](https://cloud.tencent.com/solution/database?from_column=20065&from=20065)里数据的修改而发生变化（前面的B+树节点分裂以及Page的分裂），使用聚簇索引就可以保证不管这个主键B+树的节点如何变化，辅助索引树都不受影响**。
    2. 聚簇索引适合用在排序的场合，非聚簇索引不适合
    3. 取出一定范围数据的时候，使用用聚簇索引
    4. 二级索引需要两次索引查找，而不是一次才能取到数据，因为存储引擎第一次需要通过二级索引找到索引的叶子节点，从而找到数据的主键，然后在聚簇索引中用主键再次查找索引，再找到数据
    5. 可以把**相关数据保存在一起**。例如实现电子邮箱时，可以根据用户 ID 来聚集数据，这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件。如果没有使用聚簇索引，则每封邮件都可能导致一次磁盘 I/O。
    

**MyISM** 使用的是非聚簇索引，非聚簇索引的两棵B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点**存储了主键**，辅助键索引B+树**存储了辅助键**。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个**地址指向真正的表数据**，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。

### **数据库主从复制:**

一个数据库被指定为主数据库（Master），而其他数据库被指定为从数据库（Slave）。主数据库用于处理写操作和更新数据，而从数据库用于复制主数据库的数据副本，并处理读操作。

### **MySQL 具体使用范例**，

- 学生表、课程表
    
    ```sql
    # Students:
    # StudentID | StudentName | Gender | Age | Class
    # Scores:
    # StudentID | Course | Score
    
    # 查询每个班级有多少学生:
    SELECT Class, COUNT(*) AS StudentCount
    FROM Students
    GROUP BY Class;
    
    # 计算每个课程有多少学生:
    SELECT Course, COUNT(*) AS StudentCount
    FROM Scores
    GROUP BY Course;
    
    # 计算每个课程的平均分:
    SELECT Course, AVG(Score) AS AverageScore
    FROM Scores
    GROUP BY Course;
    
    # 计算每个学生的平均分:
    SELECT score
    FROM Scores
    WHERE student_id = (SELECT student_id FROM Students WHERE name = 'A')
      AND subject = '某一科';
    
    # 计算每个学生的平均分
    SELECT s.StudentID, s.StudentName, AVG(sc.Score) AS AverageScore
    FROM Students s
    JOIN Scores sc ON s.StudentID = sc.StudentID
    GROUP BY s.StudentID, s.StudentName;
    
    # 计算有成绩不及格的学生的数量
    SELECT COUNT(DISTINCT StudentID) AS FailingStudentCount
    FROM Scores
    WHERE Score < 60;
    
    # 求学生姓名为 A 的语文课程的成绩;
    SELECT s.StudentName, sc.Score
    FROM Students s
    JOIN Scores sc ON s.StudentID = sc.StudentID
    WHERE s.StudentName = 'A' AND sc.Course = '语文';
    
    # 查询语文成绩排名前十的同学的姓名;
    SELECT s.StudentName
    FROM Students s
    JOIN Scores sc ON s.StudentID = sc.StudentID
    WHERE sc.Course = '语文'
    ORDER BY sc.Score DESC
    LIMIT 10;
    
    # 计算平均分低于80的同学的姓名
    SELECT s.name
    FROM Students s
    LEFT JOIN Scores sc ON s.student_id = sc.student_id
    GROUP BY s.student_id, s.name
    HAVING AVG(sc.score) < 80;
    
    # 查询学生姓名为 A 的挂科数量;
    SELECT s.StudentName, COUNT(*) AS FailingCount
    FROM Students s
    JOIN Scores sc ON s.StudentID = sc.StudentID
    WHERE s.StudentName = 'A' AND sc.Score < 60
    GROUP BY s.StudentName;
    
    # 计算平均分低于 80 的同学的姓名;
    SELECT s.StudentName
    FROM Students s
    JOIN Scores sc ON s.StudentID = sc.StudentID
    GROUP BY s.StudentName
    HAVING AVG(sc.Score) < 80;
    
    # 查询成绩第一、第二的同学姓名;
    WITH RankedScores AS (
        SELECT
            s.StudentName,
            sc.Score,
            sc.Course,
            DENSE_RANK() OVER(PARTITION BY sc.Course ORDER BY sc.Score DESC) AS Rank
        FROM Students s
        JOIN Scores sc ON s.StudentID = sc.StudentID
    )
    SELECT StudentName, Score, Course
    FROM RankedScores
    WHERE Rank <= 2;
    
    # 求出数学平均分最高的班级;
    SELECT s.Class
    FROM Students s
    JOIN Scores sc ON s.StudentID = sc.StudentID
    WHERE sc.Course = '数学'
    GROUP BY s.Class
    ORDER BY AVG(sc.Score) DESC
    LIMIT 1;
    
    # 删除平均分大于60的同学;
    DELETE FROM Students
    WHERE StudentID IN (
        SELECT s.StudentID
        FROM Students s
        JOIN Scores sc ON s.StudentID = sc.StudentID
        GROUP BY s.StudentID
        HAVING AVG(sc.Score) > 60
    );
    ```
    

#### 100 行 A 表 JOIN 10 行 B 表，数据范围是怎么样的？

    
- INNER JOIN：结果可能包含最多 10 行
- LEFT JOIN：结果行数最多为左表行数，左表所有行和右表中匹配条件的行。
- RIGHT JOIN：结果行数最多为右表行数，右表所有行和左表中匹配条件的行。

#### 分析 SQL 查询语句是否使用了索引以及查询的执行计划。

```sql
EXPLAIN SELECT * FROM your_table WHERE your_condition;

type | others...
- type: 显示了查询的访问类型, 根据 type 列的值，您可以决定是否需要调整查询、优化索引或进行其他性能优化操作。
- - system(只有一行数据，通常与常数表（例如 system 表）有关)
- - const(使用唯一索引查找时的常数条件)
- - eq_ref(使用唯一索引查找时的等值条件)
- - ref(非唯一索引查找时的等值条件)
- - range(使用索引范围查找时)
- - index(扫描整个索引)
- - all(全表扫描)
- others: 提供了关于查询优化器的详细信息，包括使用的索引、可能的联接方式、表的访问顺序等。
```
    

#### 手写了一个sql题，具体是从一个表中找出出现次数最多的字段

```sql
SELECT your_column, COUNT(*) AS occurrence
FROM your_table
GROUP BY your_column
ORDER BY occurrence DESC
LIMIT 1;
```

### **如果 MySQL 出现延迟或性能问题， 怎么定位问题所在？**

1. **慢查询日志**：MySQL 的慢查询日志可以记录执行时间超过指定阈值的查询。通过查看这些日志，你可以找出那些需要优化的查询。
2. **`SHOW PROCESSLIST;`**：这个命令可以显示当前MySQL服务器上的活动进程，包括正在执行的查询。如果有查询长时间处于 "Locked" 状态，那么可能存在表锁问题。
3. **系统资源监控**：
    - **CPU使用率**：持续高的CPU使用率可能意味着数据库正在处理大量的查询或复杂的计算。
    - **内存使用率**：如果MySQL使用的内存超过了配置的上限，那么它可能会开始使用磁盘交换，这会大大降低性能。
    - **磁盘I/O**：频繁的磁盘读写可能导致性能问题。
4. **索引优化**：没有正确索引的查询可能会导致全表扫描，从而增加I/O和CPU使用率。使用 **`EXPLAIN`** 命令可以查看查询的执行计划，并确定是否可以通过添加或修改索引来优化。
5. **配置优化**：查看 **`my.cnf`** 或 **`my.ini`** 文件中的MySQL配置，确保如 **`innodb_buffer_pool_size`**、**`max_connections`**、**`query_cache_size`** 等关键配置项已经根据服务器的硬件资源进行了适当的调整。
6. **硬件问题**：如果服务器的硬件有问题，例如磁盘损坏，它可能会影响MySQL的性能。使用系统工具，如 **`iostat`** 或 **`vmstat`**，来检查硬件性能。
7. **InnoDB监控工具**：如果你使用的是InnoDB存储引擎，可以使用 **`SHOW ENGINE INNODB STATUS;`** 来获取有关其性能的详细信息。
8. **第三方工具**：工具如 **`Percona Toolkit`**、**`MySQLTuner`** 或 **`Performance Schema`** 可以帮助分析性能问题并提供优化建议。
9. **连接数**：过多的并发连接可能导致资源争抢。查看当前的连接数和配置的最大连接数，考虑是否需要调整。
10. **其他可能的问题**：如网络延迟、数据碎片、磁盘空间不足等都可能导致MySQL运行缓慢。

### Redis 相关问题

#### Redis 和 MySQL 的区别

Redis和MySQL在本质上是两种不同类型的数据库系统，主要的区别体现在以下方面：

- **存储方式**：Redis是一个键值存储系统，数据通常存储在内存中，这使得它的读写速度非常快。MySQL是一个关系型数据库，数据存储在磁盘上，支持复杂的查询语言（SQL）。
- **数据结构**：Redis支持字符串、列表、集合、有序集合等数据类型，而MySQL以表格形式存储，支持行和列的结构。
- **持久性**：MySQL以持久化为主，能保证数据的持久存储。Redis虽然也支持持久化，但其主要设计目的是提供高性能的内存访问。
- **用途**：Redis常用作缓存系统或存储临时数据，而MySQL更适合作为主数据库，处理事务和复杂查询。

#### Redis 在项目中如何应用

- **缓存**：减少数据库的访问压力，提高应用响应速度。

大多数传统数据库如MySQL、PostgreSQL等都是基于磁盘的存储系统。磁盘的I/O操作相比内存访问要慢得多。

并且当数据集很大，不能完全加载到内存中时，数据库频繁进行磁盘读写操作，尤其是复杂的查询（如多表连接、大量的排序和聚合）会显著增加I/O操作的时间

Redis是基于内存的数据存储系统，相比于磁盘，内存的访问速度快得多。使用Redis作为缓存层， 通过将高频访问的数据存储在Redis缓存中，可以直接从内存中迅速读取数据，而不需要每次都查询数据库。Redis的数据结构简单直观（如字符串、列表、集合等），开发者可以很容易地实现如计数器、队列等功能。

**实现方式**：

- 读取缓存：在查询数据前，应用先从Redis中尝试获取数据。如果缓存命中，直接返回缓存数据。
- 写入缓存：当数据更新时，例如添加新的用户信息或产品详情，同时更新Redis缓存。
- 缓存失效：设置合理的过期时间（TTL）来自动清除旧数据，或在数据更新时手动清除相关缓存。
- 会话存储：在Web应用中，使用Redis存储用户的会话信息。

在用户登录到网站后，需要管理用户的会话信息。传统的做法是在服务器内存中存储会话信息，但这不利于扩展和维护。

**实现方式**：

- 使用Redis存储会话信息，每个会话分配一个唯一的会话ID（通常是一个随机生成的字符串），并将此ID用作Redis中的键。
- 将用户的会话信息存储为Redis键的值，可以是字符串（JSON序列化的对象）或哈希表。
- 设置会话的过期时间，以自动删除不活跃的会话。
- 消息队列系统：利用Redis的发布订阅（Pub/Sub）功能，实现消息通信机制。

在需要处理实时消息或进行异步任务处理的系统中，可以使用Redis的发布订阅模式来实现消息通信。

**实现方式**：

- 发布者：应用或服务端可以发布消息到Redis的一个频道（channel）。
- 订阅者：其他应用或服务端订阅这个频道，以便接收到发布者发出的消息。
- 使用`PUBLISH`命令发送消息，使用`SUBSCRIBE`命令订阅频道。**
- 对于复杂的任务队列，可以利用Redis的列表数据结构，使用`LPUSH`和`RPOP`命令来实现生产者-消费者模型。**
- 实时计数器：如计数网站访问量，或社交媒体的点赞数。

在需要实时监控或统计某些数值的应用中，如网站的访问计数、商品的浏览量或社交媒体的点赞数。

**实现方式**：

- 使用Redis的原子操作，如`INCR`和`DECR`，来增加或减少数值。这些操作是原子性的，保证了在并发环境中数据的一致性。**
- 可以为每个需要计数的对象分配一个键，如一个网页或商品的唯一标识符。
- 可以设置计数器的过期时间，或者根据应用需求永久存储。

#### Redis常用的数据类型，项目中最常用哪个

- 字符串（Strings）
- 列表（Lists）
- 集合（Sets）
- 有序集合（Sorted Sets，ZSets）
- 哈希表（Hashes）

#### Redis为什么是单线程的

    
Redis设计为单线程主要是为了避免多线程带来的复杂性，如并发控制和状态同步。由于Redis主要存储在内存中，单线程已足以充分利用现代多核处理器的高内存带宽，以及I/O多路复用技术，从而实现极高的性能。

#### Redis 命令有哪些

- **键管理：**`SET`, `GET`, `DEL`, `EXISTS`
- **数据结构操作：** `LPUSH` , ** `LPOP` （列表）； `SADD` , ** `SMEMBERS` （集合）； `ZADD` , ** `ZRANGE` （有序集合）； `HSET` , ** `HGET` （哈希表）
- **控制命令：**`AUTH`, `PING`, `SELECT`
- **持久化与备份：**`BGSAVE`, `SAVE**********`**

#### Redis为什么适合做缓存

- **高性能和低延迟**：内存存储确保了快速的数据访问。
- **数据结构多样性**：支持多种数据结构，适应各种需求。
- **持久化存储支持**：可以将内存中的数据保存到磁盘，防止数据丢失。
- **支持分布式存储**：可以扩展到多个节点，提高可用性和容量。
- **资源消耗少**：内存和CPU的高效利用。
    

#### Redis的底层模型

    
Redis的底层基于非阻塞的I/O多路复用模型。这使得Redis可以同时处理多个客户端请求，而不需为每个连接分配独立的线程或进程，从而极大地提高了资源的使用效率。Redis内部使用单个事件循环，这个循环负责接收命令、处理命令及返回结果。
    

#### Redis和数据库的缓存不一致问题

当缓存层与数据库层之间数据不同步时，会出现缓存不一致的问题。解决方案包括：

- **缓存失效策略**：当数据更新时，立即删除缓存中的旧数据。
- **使用消息队列**：更新操作通过消息队列异步更新数据库和缓存，保证顺序性。
- **读取时重建缓存**：如果缓存失效或数据不一致，从数据库读取并更新缓存。
    

#### Redis缓存穿透，如何解决

缓存穿透指查询不存在的数据，导致请求直接访问数据库。解决方法包括：

- **布隆过滤器**：使用布隆过滤器预先过滤掉可能不存在的数据请求。
- **空值缓存**：对查询不到的键进行短时间的空结果缓存。
    

#### Redis中Zset的结构是怎么样的，ZADD命令时间复杂度是多少？

Redis的有序集合（Zset）是通过分数来维持数据的排序，内部实现为一种称为跳跃表（skiplist）的数据结构，同时结合哈希表确保数据的唯一性。`ZADD`命令的时间复杂度大致为O(log N)，其中N是集合中的元素数量。
    

#### Redis的集群架构是怎么样的？

Redis集群通过将数据分片存储在多个Redis节点上来提供自动的分区功能。每个Redis节点都存储整个数据集的一部分。Redis集群支持无缝地添加或删除节点，同时客户端无需使用特定的集群客户端库来访问。
    

#### 了解Redis吗？关于Redis的命中率

    
Redis的命中率指的是缓存命中次数与总请求次数的比率，是衡量缓存效率的重要指标。理想情况下，命中率应尽可能高，表示大多数数据请求都通过缓存解决，减少了数据库的访问压力。提高命中率的策略包括优化数据缓存策略和合理设置缓存过期时间。

## 安卓

- [Activity](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#activity)
    - [生命周期](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F)
    - [启动模式](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F)
    - [启动过程](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B)
- [Fragment](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#fragment)
    - [特点](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#%E7%89%B9%E7%82%B9)
    - [生命周期](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-1)
    - [与Activity通信](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#%E4%B8%8Eactivity%E9%80%9A%E4%BF%A1)
- [Service](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#service)
    - [启动过程](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B-1)
    - [绑定过程](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#%E7%BB%91%E5%AE%9A%E8%BF%87%E7%A8%8B)
    - [生命周期](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-2)
    - [启用前台服务](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#%E5%90%AF%E7%94%A8%E5%89%8D%E5%8F%B0%E6%9C%8D%E5%8A%A1)
- [BroadcastReceiver](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#broadcastreceiver)
    - [注册过程](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#%E6%B3%A8%E5%86%8C%E8%BF%87%E7%A8%8B)
- [ContentProvider](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#contentprovider)
    - [基本使用](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8)
- [View](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#view)
    - [MeasureSpec](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#measurespec)
    - [MotionEvent](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#motionevent)
    - [VelocityTracker](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#velocitytracker)
    - [GestureDetector](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#gesturedetector)
    - [Scroller](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#scroller)
    - [View 的滑动](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#view-%E7%9A%84%E6%BB%91%E5%8A%A8)
    - [View 的事件分发](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#view-%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91)
    - [在 Activity 中获取某个 View 的宽高](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#%E5%9C%A8-activity-%E4%B8%AD%E8%8E%B7%E5%8F%96%E6%9F%90%E4%B8%AA-view-%E7%9A%84%E5%AE%BD%E9%AB%98)
    - [Draw 的基本流程](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#draw-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B)
    - [自定义 View](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#%E8%87%AA%E5%AE%9A%E4%B9%89-view)
- [Parcelable 接口](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#parcelable-%E6%8E%A5%E5%8F%A3)
    - [使用示例](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B)
    - [方法说明](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#%E6%96%B9%E6%B3%95%E8%AF%B4%E6%98%8E)
    - [Parcelable 与 Serializable 对比](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#parcelable-%E4%B8%8E-serializable-%E5%AF%B9%E6%AF%94)
- [IPC](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#ipc)
    - [IPC方式](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#ipc%E6%96%B9%E5%BC%8F)
    - [Binder](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#binder)
        - [流程](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#%E6%B5%81%E7%A8%8B)
    - [AIDL 通信](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#aidl-%E9%80%9A%E4%BF%A1)
    - [Messenger](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#messenger)
- [Window / WindowManager](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#window--windowmanager)
    - [Window 概念与分类](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#window-%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%88%86%E7%B1%BB)
    - [Window 的内部机制](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#window-%E7%9A%84%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6)
    - [Window 的创建过程](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#window-%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B)
        - [Activity 的 Window 创建过程](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#activity-%E7%9A%84-window-%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B)
        - [Dialog 的 Window 创建过程](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#dialog-%E7%9A%84-window-%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B)
        - [Toast 的 Window 创建过程](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#toast-%E7%9A%84-window-%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B)
- [Bitmap](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#bitmap)
    - [配置信息与压缩方式](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%8E%8B%E7%BC%A9%E6%96%B9%E5%BC%8F)
    - [常用操作](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C)
        - [裁剪、缩放、旋转、移动](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#%E8%A3%81%E5%89%AA%E7%BC%A9%E6%94%BE%E6%97%8B%E8%BD%AC%E7%A7%BB%E5%8A%A8)
        - [保存与释放](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#%E4%BF%9D%E5%AD%98%E4%B8%8E%E9%87%8A%E6%94%BE)
        - [图片压缩](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9)
    - [BitmapFactory](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#bitmapfactory)
        - [Bitmap创建流程](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#bitmap%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B)
        - [Option类](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#option%E7%B1%BB)
        - [基本使用](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-1)
    - [内存回收](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6)
- [屏幕适配](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D)
    - [单位](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#%E5%8D%95%E4%BD%8D)
    - [头条适配方案](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#%E5%A4%B4%E6%9D%A1%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88)
    - [刘海屏适配](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#%E5%88%98%E6%B5%B7%E5%B1%8F%E9%80%82%E9%85%8D)
- [Context](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#context)
- [SharedPreferences](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#sharedpreferences)
    - [获取方式](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F)
        - [getPreferences](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#getpreferences)
        - [getDefaultSharedPreferences](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#getdefaultsharedpreferences)
        - [getSharedPreferences](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#getsharedpreferences)
    - [架构](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#%E6%9E%B6%E6%9E%84)
    - [apply / commit](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#apply--commit)
    - [注意](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#%E6%B3%A8%E6%84%8F)
- [消息机制](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6)
    - [Handler 机制](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#handler-%E6%9C%BA%E5%88%B6)
    - [工作原理](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86)
        - [ThreadLocal](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#threadlocal)
        - [MessageQueue](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#messagequeue)
        - [Looper](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#looper)
        - [Handler](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#handler)
- [线程异步](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#%E7%BA%BF%E7%A8%8B%E5%BC%82%E6%AD%A5)
    - [AsyncTask](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#asynctask)
        - [基本使用](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-2)
        - [工作原理](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-1)
    - [HandlerThread](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#handlerthread)
    - [IntentService](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#intentservice)
    - [线程池](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#%E7%BA%BF%E7%A8%8B%E6%B1%A0)
- [RecyclerView 优化](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#recyclerview-%E4%BC%98%E5%8C%96)
- [Webview](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#webview)
    - [基本使用](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-3)
        - [WebView](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#webview-1)
        - [WebSettings](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#websettings)
        - [WebViewClient](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#webviewclient)
        - [WebChromeClient](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#webchromeclient)
    - [Webview 加载优化](https://github.com/BlackZhangJX/Android-Notes/blob/master/Docs/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.md#webview-%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96)

## Android 系统

### Android 系统架构

> [!cite] Android 系统架构图
> [系统启动之BootLoader 简介及内核启动](https://crazymo.blog.csdn.net/article/details/114768692)
> [Android启动过程](https://medium.com/@khetanrajesh/android-boot-up-process-init-c05371c4f976)
> [Linux进程Fork详解](https://juejin.cn/post/7022470737617223717)
> [Android启动过程-万字长文(Android14)](https://www.cnblogs.com/anywherego/p/18221943)
> [Android 进阶——系统启动之Android init进程的创建和启动](https://blog.csdn.net/CrazyMo_/article/details/114769424)
> [Android 操作系统架构开篇](https://gityuan.com/android/)

![架构图](https://source.android.com/static/images/android-stack.svg?hl=zh-cn)

应用层:  包括用户界面、应用程序逻辑和数据存储等.
应用框架层: 提供应用程序开发的 API(System API, Android API, Android framework).
系统运行库: 提供系统服务(System services)和安卓运行时环境(Android runtime (ART))
硬件抽象层: 包括 Hardware abstraction layer (HAL) 和 Native daemons and libraries.
内核层: 包括 Android kernel 和 Linux Kernel, 共同构成GKI(前身 ACK)

### Android 系统启动

1. 设备上电: 产生复位时序信号, 启动硬件(IO, 内存等)复位和初始化, 最后复位 CPU(避免寄存器状态不准), 执行引导加载程序(U-Boot 或fastboot).

2. 引导加载程序 (Bootloader): 存储在设备的只读存储器中, 启动时会根据*启动时验证*流程验证设备, 确定要启动的系统内核和启动模式, 然后加载启动映像.

    - 启动时验证可以确保执行的代码是可信的(包括硬件->Bootloader->内核->分区), 占用内存小的代码直接哈希验证, 占用内存大的使用 dm-verity 验证, 要求是哈希树的根哈希值必须可信. 同时防止系统降级和传递启动状态到内核.
    - 系统内核和启动模式和选择受 A/B 更新影响(非A/B 更新, A/B 更新, 虚拟 A/B 更新), 
    - 启动映像: 包括 Linux 内核和 ramdisk 映像

3. 内核初始化: 内核自解压, 启动内核, 初始化设备驱动程序.

    - Linux 内核: 会创建 0 号进程(swapper), 运行在内核空间, 同时初始化硬件驱动, 中断处理程序, 进程调度程序, 内存管理, 基于内存的文件系统等.
    - ramdisk: 包含了一些初始化脚本, 用于挂载基于内存的根文件系统.

4. init 进程启动: 由内核启动, 1 号进程, 运行在用户空间, 加载系统配置文件(如 init.rc), 负责启动原生服务 和 Zygote.

    - init.rc: 用于配置系统属性, 如系统语言, 时区, 屏幕密度等.
    - 原生服务(native service): 由 init 进程启动, 用于提供系统服务, 如 bootanim(开机动画), vold(存储设备事件),  servicemanager(内核层Binder服务管理者), installd(安装 APP), lmkd(低内存守护进程), adbd(调试), logcatd(日志)等, 不依赖于 Java 虚拟机环境, 一般通过 socket 通信.

5. 系统服务启动: 由 init 进程首先启动 Zygote 进程, 然后启动其他重要系统服务进程.

    - Zygote 进程: fork 自 init 进程, 独立的用户空间, 执行文件名(/system/bin/app_process), 用于预先加载系统的核心类库(如安卓运行环境 ART, )和安卓系统服务, 然后进入循环, 等待新 Android 应用程序进程创建请求, 期间通过 socket 与其他进程通信, 基于 fork 创建应用程序进程.
        - 创建虚拟机, 注册JNI方法, 通过 JNI 调用 ZygoteInit.main().
        - 预加载系统常用的类、各种资源和核心库.
        - 启动系统服务进程.
    - 系统服务进程均 fork 自 Zygote, 同时通过反射调用 main() 方法进行自定义初始化, 并通过 Binder 机制进行进程间通信. 常见的有 ActivityManagerService, ActivityTaskManagerService, RootWindowContainer, PackageManagerService, PowerManagerService, WindowManagerService, BatteryService, BatteryStatsService, DreamManagerService, DropBoxManagerService, SamplingProfilerService, 等系统服务进程, 进程创建失败时将会重启zygote进程.

6. 桌面程序启动: 通过 ActivityManagerService 和 RootWindowContainer 在所有显示器上通过 Intent 和 startHomeActivity 方法启动了当前用户的桌面程序, 显示用户界面.
    - 桌面程序是通过 Zygote 进程 fork 出的桌面程序进程, 启动时会进行初步初始化, 如构造 Looper, Handler等, 然后绑定到 AMS 中, 由其进行调度.
    - 桌面页面通常是 Launcher, 一个 Activity 类型对象, 可以是其他定制的桌面程序, 包含工作区(搜索框, 桌面, 壁纸, Hotseat等), 应用程序列表, Widget等.

### Android 通信机制

### Android 系统服务

#### ActivityManagerService(AMS)

负责系统内四大组件的生命周期以及应用程序的管理进程.

#### ActivityTaskManagerService(ATMS)

AMS的辅助类, 负责处理 Activity 及其相关容器(如活动栈(Task), 活动栈组(Stack), 屏幕(Display)等)的管理.

#### PackageManagerService(PMS)

负责扫描和监控应用程序的安装和卸载, 管理应用程序的权限, 提供应用程序的信息, 管理应用程序的数据等.

#### PowerManagerService

管理设备的电源管理.

#### WindowManagerService

管理窗口的显示和布局, 其中 RootWindowContainer 为管理所有窗口的容器.

#### SurfaceFlinger

负责显示系统的窗口, 通过 OpenGL 渲染窗口, 并将渲染结果显示到屏幕上.

### Socket

#### Binder

> [为什么 Android 要采用 Binder 作为 IPC 机制？](https://www.zhihu.com/question/39440766/answer/89210950)

#### Handler

Handler消息机制由 MessageQueue、Message、Looper、Handler 共同组成, 用于在不同线程之间传递消息, 实现线程间的通信.

### Android Runtime(ART, 兼容前身 Dalvik) 应用程序运行环境

支持预先 (AOT) 编译和即时 (JIT) 编译, 用于将 DEX 字节码转换为本机机器代码, 以提高应用程序的性能和效率.

- JIT 及时编译: 在应用程序运行时将字节码编译为本机机器代码, 编译速度快, 但影响应用启动速度.
- AOT 预先编译: 在应用程序安装时, 使用设备自带的 *dex2oat* 工具来编译应用将字节码编译为本机机器代码, 安装速度慢, 但提高应用启动速度.

## Android 应用程序组成

### 清单文件 `AndroidManifest.xml`

安卓操作系统与安卓应用程序之间由清单文件 `AndroidManifest.xml` 进行连接, 该清单文件位于应用程序的根目录下, 用于告知系统应用程序的基本信息, 如应用程序的名称、图标、版本号、权限以及各种组件等. 

以下是一个简单的清单文件示例及其内容解析:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <!-- 应用程序信息 -->
    <application
        android:name=".MyApplication"
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.MyApplication3"
        tools:targetApi="31">

        <!-- 活动声明 -->
        <activity
            android:name=".MainActivity"
            android:launchMode="singleTop"
            android:taskAffinity=""
            android:allowTaskReparenting="true"
            android:exported="true"
            android:label="@string/title_activity_main"
            android:permission="com.example.MY_PERMISSION"
            >
        <intent-filter>
            <action android:name="android.intent.action.MAIN" />
            <category android:name="android.intent.category.LAUNCHER" />
        </intent-filter>
        </activity>

        <activity
            android:name=".SecondActivity"
            android:exported="true"
            android:label="@string/title_activity_second">
        <intent-filter>
            <action android:name="com.example.SECOND" />
            <category android:name="android.intent.category.DEFAULT" />
        </intent-filter>
        </activity>

        <!-- 服务声明 -->
        <service
            android:name=".MyService"
            android:exported="true">
            <intent-filter>
                <action android:name="com.example.MY_SERVICE" />
            </intent-filter>
        </service>

        <!-- 广播接收器声明 -->
        <receiver
            android:name=".MyReceiver"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.BOOT_COMPLETED" />
            </intent-filter>
        </receiver>

        <!-- 内容提供程序声明 -->
        <provider
            android:name=".MyProvider"
            android:authorities="com.example.myprovider"
            android:exported="true"
            android:grantUriPermissions="true">
            <grant-uri-permission android:pathPattern="/myprovider/*" />
            </provider>
    </application>

    <!-- 权限声明 -->
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission android:name="android.permission.CAMERA" />
    <uses-permission android:name="android.permission.RECORD_AUDIO" />
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />

    <!-- 使用特性 -->
    <uses-feature android:name="android.hardware.camera" />
    <uses-feature android:name="android.hardware.microphone" />
    <uses-feature android:name="android.hardware.location.gps" />

</manifest>
```

顶部声明

- `<?xml version="1.0" encoding="utf-8"?>`：声明 XML 文件的版本和编码方式.
- `<manifest>`：根元素, 包含应用的所有配置.
    - `xmlns:android="http://schemas.android.com/apk/res/android"`：定义 `android` 命名空间, 用于引用安卓系统提供的属性.
    - `xmlns:tools="http://schemas.android.com/tools"`：定义 `tools` 命名空间, 用于引用开发工具 (如 Android Studio) 提供的一些自定义属性.  

- `<application>` 元素

包含应用级别的配置信息, 定义应用的全局属性和组件.

- `android:name=".MyApplication"`: 指定应用的自定义 `Application` 类.
- `android:allowBackup="true"`: 允许用户备份和恢复应用的数据.
- `android:dataExtractionRules="@xml/data_extraction_rules"`: 指定数据提取规则, 通常用于自动备份功能.
- `android:fullBackupContent="@xml/backup_rules"`: 指定完整备份内容的规则.
- `android:icon="@mipmap/ic_launcher"`: 指向用于标识应用的图标的资源
- `android:label="@string/app_name"`: 指定应用的显示名称.
- `android:roundIcon="@mipmap/ic_launcher_round"`: 指定圆形应用图标 (通常用于圆形图标需求的设备).
- `android:supportsRtl="true"`: 指定应用是否支持从右到左 (RTL) 的布局方向.
- `android:theme="@style/Theme.MyApplication3"`: 指定应用的主题.
- `tools:targetApi="31"`: 指定目标 API 级别, 主要用于开发工具进行静态代码检查, 不影响实际运行时的行为.

**`<activity>`元素**

定义一个活动 (Activity), 是应用的一个主要组件, 代表一个用户界面.

- `android:name=".MainActivity"`: 指定活动的类名, `.MainActivity` 表示该活动在应用包名下.
- `android:launchMode="singleTop"`: 指定活动的启动模式. 这里是 `singleTop`, 表示如果活动已经在栈顶, 不会重新创建新的实例.
- `android:taskAffinity=""`: 指定活动的任务亲和性, 控制活动创建时所在的任务栈. 默认会在当前任务栈, 如果设置了亲和值, 则会寻找具有相同亲和值的任务栈, 如果没有则创建新的任务栈.
- `android:allowTaskReparenting="true"`: 指定当活动所在任务栈进入前台时, 是否可以将活动移动到其他具有相同亲和性的任务栈.
- `android:clearTaskOnLaunch="true"`: 每当用户离开该任务并再次返回时, 任务栈中的所有活动都会被清除, 仅保留根活动.
- `android:alwaysRetainTaskState="true"`: 拒绝系统在用户长时间离开任务栈时清除除了根活动之外的所有活动.
- `android:finsihOnTaskLaunch="true"`: 指定活动是否在任务启动时结束.
- `android:exported="true"`: 指定活动是否可以由应用之外的组件启动. `true` 表示可以被其他应用访问.
- `android:label="@string/title_activity_main"`: 指定活动的显示名称.
- `android:permission="com.example.MY_PERMISSION"`: 指定活动自身被调用时需要的权限.
- `<intent-filter>`: 定义了活动能够响应的意图 (Intent) , 通常用于配置应用的启动活动和处理特定的动作.

    - `<action>`: 定义意图的动作.

        - `android:name="android.intent.action.MAIN"`: 表示该活动是应用的主入口点, 会为其创建程序图标.
        - `android:name="com.example.SECOND"`: 自定义的动作名称.

    - `<category>`: 定义意图的类别.

        - `android:name="android.intent.category.LAUNCHER"`: 表示该活动会出现在应用启动器中, 作为应用的启动活动.
        - `android:name="android.intent.category.DEFAULT"`: 默认的意图类别.

**`<service>`**元素**

定义一个服务 (Service) , 是一个后台运行的组件, 用于执行长时间运行的操作.

- `android:name=".MyService"`: 指定服务的类名.
- `android:exported="true"`: 指定服务是否可以被其他应用访问.
- `<intent-filter>`: 定义了服务能够响应的意图.

    - `<action>`: 定义意图的动作.

        - `android:name="com.example.MY_SERVICE"`: 自定义的动作名称.

**`<receiver>` 元素**

定义一个广播接收器 (Broadcast Receiver) , 用于接收系统广播事件.

- `android:name=".MyReceiver"`: 指定广播接收器的类名.
- `android:exported="true"`: 指定广播接收器是否可以被其他应用访问.
- `<intent-filter>`: 定义了广播接收器能够响应的意图.

    - `<action>`: 定义意图的动作.

        - `android:name="android.intent.action.BOOT_COMPLETED"`: 表示系统启动完成后发送的广播.

**`<provider>` 元素**

定义一个内容提供程序 (Content Provider) , 用于管理应用程序的数据集.

- `android:name=".MyProvider"`: 指定内容提供程序的类名.
- `android:authorities="com.example.myprovider"`: 指定内容提供程序的权限.
- `android:exported="true"`: 指定内容提供程序是否可以被其他应用访问.
- `android:grantUriPermissions="true"`: 指定内容提供程序是否授予 URI 权限.
- `<grant-uri-permission>`: 定义了内容提供程序授予的 URI 权限.

    - `android:pathPattern="/myprovider/*"`: 匹配 URI 的路径模式.

**`<uses-permission>` 元素**

定义应用程序需要的权限.

- `android:name="android.permission.INTERNET"`: 访问互联网的权限.
- `android:name="android.permission.ACCESS_NETWORK_STATE"`: 访问网络状态的权限.
- `android:name="android.permission.CAMERA"`: 使用摄像头的权限.
- `android:name="android.permission.RECORD_AUDIO"`: 录制音频的权限.
- `android:name="android.permission.ACCESS_FINE_LOCATION"`: 访问精确位置的权限.

**`<uses-feature>` 元素**

定义应用程序需要的硬件功能.

- `android:name="android.hardware.camera"`: 摄像头硬件功能.
- `android:name="android.hardware.microphone"`: 麦克风硬件功能.
- `android:name="android.hardware.location.gps"`: GPS 定位硬件功能.

### 应用程序安装和启动

1. 应用程序安装: 通过 Google Play 商店、应用商店、APK 文件等方式安装应用程序, 安装时

    - 系统会解析 APK 文件, 提取清单文件 `AndroidManifest.xml` 中的信息, 包括应用程序的名称、图标、版本号、权限以及各种组件等.
    - 系统桌面启动器 (Launcher) 会在设备上安装应用程序时, 读取 app 的清单文件 `AndroidManifest.xml`, 并为其创建一个程序图标.

2. 应用程序启动: 点击应用程序图标, 当前所在程序(一般是桌面)通过 `Intent` 利用内部的 `startActivity()` 方法或 `LauncherApps` 提供的方法启动对应应用程序的主 `Activity`, 或其他快捷方式、通知栏、桌面小部件等功能, 启动时依然是通过 `ActivityManagerService` 等服务实现.
    - 应用程序是通过 Zygote 进程 fork 出的进程, 启动时会绑定到 AMS 中, 同时进入主线程(UI 线程: ActivityThread)进行应用程序的初始化过程, 包括但不限于构造 Looper,  Handler等, 最后进入消息循环, 等待 AMS 的调度.
    - 等待 AMS 发起 bindApplication() 和 ATMS 发起 attachApplication(), 会在主线程内部产生一个 BIND_APPLICATION 类型的 Message 发起包括但不限于 , Instrumentation(用于监控和管理应用行为), Application, ContentProvider, Activity, Service, BroadcastReceiver 等组件的初始化.
    - 等待 AMS 发起 app.scheduleReceiver(), 会在主线程内部产生一个 RECEIVER 类型的 Message 进行广播接收器的 handle.

### 应用程序组件: Instrumentation

> [Android Instrumentation 框架简单说明 · 测试之家]{https://testerhome.com/topics/6592}

### 应用程序组件: Application

应用程序的基础是 `Application` 类, 一个单例类, 每个应用程序都有一个 `Application` 实例, 它是整个应用程序的入口点, 负责应用程序的初始化和全局状态的管理, 可以通过 `getApplication()` 方法获取.

- 在应用程序启动时初始化一些全局的资源或配置, 例如第三方库 (如分析工具、数据库库等).
- 在应用程序的生命周期中管理全局状态, 例如用户登录状态、网络连接状态等.
- 监控整个应用程序的生命周期, 处理一些全局的状态变化.

    - `onCreate()`: 应用程序创建时调用.
    - `onLowMemory()`: 系统内存不足时调用.
    - `onTrimMemory()`: 系统内存不足时调用, 用于释放资源.
    - `onConfigurationChanged()`: 配置发生变化时调用, 如屏幕旋转.
    - `onTerminate()`: 应用程序终止时调用.
    - `registerActivityLifecycleCallbacks()`: 注册活动生命周期回调.

```kotlin
class MyApplication : Application() {
    override fun onCreate() {
        super.onCreate()
        // 初始化Firebase
        FirebaseApp.initializeApp(this)
        // 初始化Crashlytics
        Fabric.with(this, Crashlytics())
        // 初始化数据库
        Realm.init(this)
        // 初始化全局数据
        someGlobalData = "This is some global data"
    }
}
```

### 应用程序四大组件: 活动、服务、广播接收器、内容提供程序

Android 应用程序由四个主要组件组成:

- 活动 (Activity): 用户与应用程序进行交互的主要入口点, 通常表示一个具有用户界面的屏幕
- 服务 (Service): 在后台执行长时间运行的操作或远程处理
- 广播接收器 (Broadcast Receiver): 在系统广播事件发生时接收系统广播
- 内容提供程序 (Content Provider): 管理应用程序的数据集

活动可以启动服务来执行后台任务; 注册广播接收器来接收系统或应用的广播以更新 UI; 使用内容提供程序来访问和管理数据; 启动其他活动, 并传递数据.

广播接收器被动接收系统或应用的广播事件, 然后可以启动服务来执行后台任务, 也可以通过内容提供程序来访问和管理数据.

服务通常是由活动或广播接收器启动, 可以通过内容提供程序来访问和管理数据.

内容提供程序为程序提供标准的数据管理接口, 包括查询、插入、更新和删除.

此外还有些附加组件:

- 片段 (Fragment): 可重用的 UI 组件
- 意图 (Intent): 用于在组件之间传递消息
- 视图 (View): 用户界面的构建块
- 布局 (Layout): 定义视图的结构和外观
- 资源 (Resource): 应用程序的非代码资源, 如图像、字符串和布局文件

#### 活动 (Activity)

每个活动都是一个类, 继承自 `Activity` 类或其子类, 用于表示 Android 应用程序用户界面的一个屏幕. Android 应用启动时, 会首先进入设置的主 `Activity` 的初始化过程. 此外, 每个应用程序可以包含多个活动, 所有活动必须在清单文件 `AndroidManifest.xml` 中进行声明, 当一个应用调用另一个应用时, 发起调用的应用可以调用另一个应用中的其他 `activity`. 例如, 浏览器应用可能会启动社交媒体应用的分享 `activity`.

每个活动都有一个生命周期, 包括以下主要状态:

- `onCreate(Bundle savedInstanceState)`: 活动创建时调用
- `onStart()`: 活动开始时调用, 初始化的资源应在 `onStop` 释放
- `onResume()`: 活动恢复时调用(可见且在前台 ) <-----|
- `onPause()`: 活动暂停时调用(可见但不在前台) ----->| 不建议释放与 ui 相关的资源和耗时操作
- `onStop()`: 活动停止时调用(不可见), 系统会自动保存组件状态, 即使活动被销毁.
- `onRestart()`: 活动重新启动时调用
- `onDestroy()`: 活动销毁时调用

辅助方法:

- `onSaveInstanceState(Bundle outState)`: 保存活动除布局或视图之外的自定义状态, 以便在活动重新创建时恢复, 缺点是只能保存少量数据, 因为要在主线程进行序列化操作.
- `onRestoreInstanceState(Bundle savedInstanceState)`: 恢复保存的状态, 与 `onSaveInstanceState` 配合使用, 一般使用 `onCreate` 方法就足够了.
- `startActivity(Intent intent, Bundle options)`: 启动另一个活动
- `startActivityForResult(Intent intent, int requestCode)`: 启动另一个活动并获取结果, 结果通过 `onActivityResult` 方法返回
- `setResult(int resultCode, Intent data)`: 当被其他活动启动时, 设置返回结果.
- `onActivityResult(int requestCode, int resultCode, Intent data)`: 当其他活动响应了 `Intent` 后, 并通过 `setResult` 设置了返回结果, 会调用此方法.

自定义默认启动活动模式

- `launchMode.standard`: 标准模式, 每次启动都会创建新的实例, 并将启动时的 `Intent` 传递给新的实例. 比如新闻应用中每次点击文章链接都会创建新的文章页面实例.
- `launchMode.singleTop`: 栈顶复用模式, 如果活动已经在栈顶, 不会重新创建新的实例, 而是调用 `onNewIntent` 方法来处理新的 `Intent`. 如果活动不在栈顶, 会创建新的实例. 比如点击消息通知栏的消息进入消息详情页面, 如果在消息通知栏消失前点击多次, 不会创建新的实例, 而是复用当前页面.
- `launchMode.singleTask`: 栈内复用模式, 如果活动已经在栈中, 会将该活动上面的所有活动出栈, 并调用 `onNewIntent` 方法来处理新的 `Intent`. 如果活动不在栈中, 会创建新的实例. 比如点击应用图标或导航栏的主页面, 我的页面等进入页面, 如果页面已经在栈中, 会将页面上面的所有活动出栈`.
- `launchMode.singleInstance`: 单实例模式, 如果没有包含此活动的任务栈, 则创建一个单独的任务栈管理此活动, 并且该活动独占任务栈, 不会与其他活动共享任务栈. 如果已经有包含此活动的任务栈, 则直接把此任务栈置于前台展示, 不会创建新的实例. 比如播放视频的全屏模式, 独立登录页面等, 会创建一个新的任务栈, 并且独占任务栈.
- `launchMode.singleInstancePerTask`: 单示例和栈内复用模式, 如果没有包含此活动的任务栈, 则创建一个单独的任务栈管理此活动, 此活动会置于栈底, 后续启动的活动也会在此任务栈中. 如果已经有包含此活动的任务栈, 则直接把此任务栈置于前台展示, 不会创建新的实例, 同时将此活动顶部的其他活动出栈.

```kotlin
class MainActivity : AppCompatActivity() {
    lateinit var textView: TextView
    var gameState: String? = null
    var currentScore = 0
    var currentLevel = 0
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        if (savedInstanceState != null) {
            with(savedInstanceState) {
                gameState = getString(GAME_STATE_KEY)
                textView.text = getString(TEXT_VIEW_KEY)
                currentScore = getInt(STATE_SCORE)
                currentLevel = getInt(STATE_LEVEL)
            }
        }
        setContentView(R.layout.activity_main)
        textView = findViewById(R.id.text_view)
    }

    override fun onStart() {
        super.onStart()
        Log.d(TAG, "onStart")
    }

    override fun onResume() {
        super.onResume()
        Log.d(TAG, "onResume")
    }

    override fun onPause() {
        super.onPause()
        Log.d(TAG, "onPause")
    }

    override fun onStop() {
        super.onStop()
        Log.d(TAG, "onStop")
    }

    override fun onSaveInstanceState(outState: Bundle?) {
        outState?.run {
            putString(GAME_STATE_KEY, gameState)
            putString(TEXT_VIEW_KEY, textView.text.toString())
            putInt(STATE_SCORE, currentScore)
            putInt(STATE_LEVEL, currentLevel)
        }
        // Call superclass to save any view hierarchy.
        super.onSaveInstanceState(outState)
    }
}
```

活动之间可以通过意图 (Intent) 进行通信, 意图可以用于启动活动、启动服务、发送广播等.

#### 服务 (Service)

服务是可以在后台执行长时间运行操作或远程处理(下载文件、播放音乐、更新数据等)的组件, 不提供用户界面, 即使应用程序处于后台或被销毁, 服务仍然可以继续运行. 每个服务都是一个类, 继承自 `Service` 类或其子类. 服务必须在清单文件 `AndroidManifest.xml` 中进行声明.

服务可以通过活动的 `startService()` 或 `bindService()` 方法启动, 通过 `stopService()` 或 `unbindService()` 方法停止. 区别在于 `startService()` 启动的服务会一直运行, 直到调用 `stopService()` 停止, 而 `bindService()` 是在其他 app 或系统组件中绑定服务, 绑定后服务会一直运行直到所有绑定的组件都解绑.

每个服务也有一个生命周期, 包括以下主要状态:

- `onStartCommand()`: 服务启动时调用
- `onCreate()`: 服务创建时调用
- `onBind()`: 服务绑定时调用
- `onUnbind()`: 服务解绑时调用
- `onRebind()`: 服务重新绑定时调用
- `onDestroy()`: 服务销毁时调用

#### 广播接收器 (Broadcast Receiver)

广播接收器是用于接收系统或应用的广播事件的组件, 当特定事件发生时, 广播接收器会接收并处理广播消息. 每个广播接收器都是一个类, 继承自 `BroadcastReceiver` 类或其子类. 广播接收器必须在清单文件 `AndroidManifest.xml` 中进行声明.

广播接收器可以通过 `registerReceiver()` 方法注册, 通过 `unregisterReceiver()` 方法注销. 也可以通过清单文件声明静态注册, 这样即使应用程序未运行, 也可以接收广播.

广播接收器可以接收系统广播事件, 常见的系统广播事件包括:

- `android.intent.action.BOOT_COMPLETED`: 系统启动完成时发送的广播
- `android.intent.action.SCREEN_ON`: 屏幕开启时发送的广播
- `android.intent.action.SCREEN_OFF`: 屏幕关闭时发送的广播
- `android.intent.action.ACTION_POWER_CONNECTED`: 充电器连接时发送的广播
- `android.intent.action.ACTION_POWER_DISCONNECTED`: 充电器断开时发送的广播
- `android.intent.action.BATTERY_LOW`: 电池电量低时发送的广播
- `android.intent.action.BATTERY_OKAY`: 电池电量恢复正常时发送的广播

广播接收器也可以通过活动的 `sendBroadcast()` 方法发送自定义的广播事件.

#### 内容提供程序 (Content Provider)

内容提供程序是用于管理应用程序的数据集的组件, 提供包括查询、插入、更新和删除等数据接口, 支持跨应用程序访问数据. 存储方式包括数据库, 文件, 网络等.

每个内容提供程序都是一个类, 继承自 `ContentProvider` 类或其子类. 内容提供程序必须在清单文件 `AndroidManifest.xml` 中进行声明.

内容提供程序可以通过查询, 插入, 更新和删除方法来操作数据. 想访问内容提供程序可以通过预定义的 URI (Uniform Resource Identifier) 来标识和访问数据集, URI 由以下部分组成:`<prefix>://<authority>/<data_type>/<id>`

`ContentProvider` 类中的方法:

- `query()`: 查询数据
- `insert()`: 插入数据
- `update()`: 更新数据
- `delete()`: 删除数据
- `getType()`: 获取数据类型
- `onCreate()`: 当提供者被启动时调用

#### 意图 (Intent)

意图是一种异步消息传递机制,

意图是用于在组件之间异步传递消息的对象, 用于在将组件绑定, 同时在组件之间传递消息, 如启动活动、启动服务、发送广播等.

- 显式意图 (Explicit Intent): 指定要启动的组件的类名, 如告诉系统在 Gmail 应用程序中启动发送电子邮件的 `Activity`. 启动时可以修改组件的启动模式.
- 隐式意图 (Implicit Intent): 指定要执行的操作, 由系统根据意图的动作和数据类型选择合适的组件, 然后系统 UI 询问用户选择哪个应用程序来处理该意图, 如在任何可以完成发送电子邮件工作的活动中启动发送电子邮件的 `Activity`.

标志:

- `FLAG_ACTIVITY_NEW_TASK`: 对应 `launchMode` 的 `singleTask`
- `FLAG_ACTIVITY_SINGLE_TOP`: 对应 `launchMode` 的 `singleTop`
- `FLAG_ACTIVITY_CLEAR_TOP`: 如果正在启动的活动已经在当前任务中运行, 那么系统将销毁其上的所有其他活动, 而不是启动该活动的新实例.
- `FLAG_ACTIVITY_CLEAR_TOP` + `FLAG_ACTIVITY_NEW_TASK`: 如果正在启动的活动已经在当前任务中运行, 那么系统将销毁其上的所有其他活动, 并将此活动置于新任务的顶部.

```xml
<uses-permission android:name="com.example.MY_PERMISSION" /> <!-- 调用其他活动需要申请对应活动定义的权限 -->

<activity android:name=".ExampleActivity">
    <intent-filter>
        <action android:name="com.example.EXAMPLE_ACTION" /> <!-- 自定义的动作名称 -->
        <category android:name="android.intent.category.DEFAULT" /> <!-- 默认的意图类别, 表示该活动可以接收启动意图 -->
        <data android:mimeType="text/plain" /> <!-- 可以发送的数据类型 -->
    </intent-filter>
</activity>
```

```kotlin
// 调用意图
val intent = Intent(this, ExampleActivity::class.java)
intent.action = "com.example.EXAMPLE_ACTION"
intent.type = "text/plain"
intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
startActivity(intent)
```

## 项目架构

### 架构原则

原则:

- 组件分离

    - 单一职责
    - 高内聚低耦合

        - 不要将 `ViewModel` 传入 `RecyclerView` 等视图的适配器(Adapter), 而是通过适配器或视图状态的 Callback 接口实现 ViewModel 的访问.

- 通过数据模型驱动界面

    - 尽量持久化存储

- 单一数据源

    - 分配单一的数据持有者
    - 只有持有者可以修改或转变数据, 修改尽量通过提供接口来实现

### 架构结构

UI Layer(界面层, 唯一职责是使用和显示界面状态)

- 界面(UI): 唯一职责是使用 `View` 或 `Jetpack Compose` 等构建视图元素来使用和显示界面状态.

    - 界面会向状态容器发送用户事件通知, 状态容器会处理事件对应的逻辑并更新界面状态.
    - 界面通过使用适当的生命周期感知型协程构建器从状态容器收集最新的界面状态(View: `repeatOnLifecycle`, Compose: `collectAsStateWithLifecycle`). (循环往复)
    - 如果界面不可见或未处于活动状态, 除非明确要求, 否则状态生成和收集的过程可以暂停, 防止消耗任何资源. (生命周期感知型协程构建器会自动控制)
    - 不要替换 activity 或 fragment 的生命周期方法, 可以改为使用 `LifecycleObserver` 监听生命周期事件. 或是通过 `repeatOnLifecycle` 来监听生命周期状态事件(`CREATED`、`DESTROYED`、`INITIALIZED`、`RESUMED`、`STARTED`).

- 界面状态(UI State): 由状态容器提供, 向界面提供数据(`_UiState`, 类似于 `Model`, 尽可能是不可变的.).

    - 一般包含要显示的数据, 控制是否要展示的状态, 控制是否要跳转的状态, 界面的回调函数, 界面的补充信息(突然要弹窗展示的信息)
    - 只有数据源或数据所有者才应负责更新他们公开的数据

- 状态容器(State holder): 负责存储和提供界面状态, 并且包含执行相应任务所必需的处理逻辑.

    - 状态容器分两种, 一种由普通的类实现(界面逻辑状态容器), 绑定到界面的生命周期, 存储不需要长期保留的界面状态和界面逻辑. 一个种由 `ViewModel` 实现(业务逻辑状态容器), 用于处理业务逻辑, 将数据从数据层或网域层转换为屏幕界面状态, 通过数据流向界面提供数据, 通过回调函数向界面提供事件处理逻辑.
    - `ViewModel` 不要放入容器视图的适配器中, 会增加耦合, 可以通过采用回调的方式(界面状态中放回调或适配器定义回调参数)进行.
    - 在 `ViewModel` 中应该立即处理事件, 并通过事件的处理结果引发状态更新, 而不能将来自 `ViewModel` 的事件发送到界面.
    - `ViewModel` 不要存储对任何与生命周期相关的类型的引用, 如 `Activity`, `Fragment`, `Context` 或 `Resources` 作为依赖项传递. 因为 `ViewModel` 生命周期长, 持有的引用在设备状态更改导致被销毁重建时, 旧实例无法被垃圾回收.
    - `ViewModel` 通过数据流(`StateFlow`, `LiveData`)向界面提供界面状态数据, 通过回调函数向界面提供事件处理逻辑.
    - `ViewModel` 通过内置的协程作用域 `viewModelScope` 来执行异步任务(`suspend` 函数), 如从数据源获取数据以及更新界面状态数据.
    - `ViewModel` 应该在屏幕级别的组件中使用, 如 `activity`, `fragment` 等屏幕级别的组件. 对于嵌套的 `fragment`, 如果与父级共享一个 `ViewModel`, 可以通过 `ViewModelProvider` 来获取父级 `fragment` 的 `ViewModel`.

- 界面事件(Event): 由界面发送给状态容器的事件, 用于触发状态容器中的逻辑处理.

    - 包括用户交互、本地资源状态改变、外部资源状态改变产生的事件等.
    - 如果事件需要执行界面逻辑 (与修改界面元素的状态相关, 如可展开项的状态) , 界面便可以直接处理这些事件.
    - 如果事件需要执行业务逻辑 (如刷新屏幕上的数据, 更新数据库数据) , 则应用由 `ViewModel` 处理此事件.

Domain Layer(网域层, 负责封装复杂的业务逻辑, 或者由多个 `ViewModel` 重复使用的简单业务逻辑)

- 合并数据层的多个存储库数据
- 存储可重复使用的简单业务逻辑, 相比于存放在 `Utils` 类中, 使得业务逻辑更加清晰, 便于维护.

Data Layer(数据层, 负责处理数据的获取和存储)

- 由多个存储库(`Repositories`)组成, 其中每个存储库都可以包含零到多个数据源(`Data Sources`).
- 存储库负责处理数据变化, 解决不同数据源冲突, 对数据源抽象化处理, 编码业务逻辑, 提供公开数据访问的函数接口.
- 每个数据源类仅负责处理一个数据源, 数据源可以是文件、网络来源或本地数据库(数据库、`DataStore`、`SharedPreferences`、Firebase API、GPS 位置信息提供程序、蓝牙数据提供程序、网络连接状态提供程序), 且只能由存储库访问.
- 多个存储库可以组合成一个 Manager 存储库, 以便在一个存储库中处理多个数据源.
- 数据源尽可能包含本地数据源和远程数据源, 以便在没有网络连接时使用本地数据源.
- 调用数据源或存储库时, 推荐通过协程(或多线程)来异步获取数据以及与保持数据在不同层之间的流动, 以避免阻塞主线程. 耗时长的操作可以通过 `WorkManager` 来执行. 比如在程序启动时在后台逐一初始化数据源, 以避免启动时的卡顿.
- 从网络数据源读取数据时, 可以通过指数退避算法需要处理网络连接失败、超时等异常情况.

#### 生命周期感知型组件

`Activity` 或 `Fragment` 通常会在其生命周期中执行一些操作, 如初始化数据、加载数据、释放资源等. 普通的生命周期方法在编写时会导致代码冗长, 比如初始化和释放资源的代码分散在了多个生命周期方法中, 使代码难以维护. 不同声明周期方法是异步执行的, 因为执行时间不同, 有时候可能会导致不同的生命周期方法之间的数据不一致.

生命周期感知型组件用于解决这些问题, 通过 `Lifecycle`(`LifecycleRegistry` 是其具体实现的类) 和 `LifecycleObserver`(`DefaultLifecycleObserver` 和 `LifecycleEventObserver` 是其具体实现的类) 来观察和响应具有生命周期变化的组件(如 `Activity` 或 `Fragment`等实现了 `LifecycleOwner` 接口的组件)的生命周期事件, 从而在生命周期状态发生变化时执行相应的操作.

- `Lifecycle`(`LifecycleRegistry`) 存储了具有生命周期变化的组件的生命周期状态, 并且可以在生命周期状态发生变化时通知所有注册的 `LifecycleObserver` 对象. 通过 `addObserver()` 方法来添加 `LifecycleObserver` 对象, 通过 `removeObserver()` 方法来移除 `LifecycleObserver` 对象.
- `DefaultLifecycleObserver` 是一个接口, 用于观察具有生命周期变化的组件的生命周期事件, 从而在生命周期状态发生变化时执行相应的操作. 通过实现 `LifecycleObserver` 接口并重写 `onCreate()`, `onStart()`, `onResume()`, `onPause()`, `onStop()`, `onDestroy()` 等方法来执行相应的操作.
- `LifecycleEventObserver` 是一个接口, 用于观察具有生命周期变化的组件的生命周期事件, 从而在生命周期状态发生变化时执行相应的操作. 通过实现 `LifecycleEventObserver` 接口并重写 `onStateChanged()` 方法来执行相应的操作. 如果同时实现了 `DefaultLifecycleObserver` 接口, 则 `DefaultLifecycleObserver` 的方法会优先执行.

注意事项:

- 当 `onSaveInstanceState()` 被调用时, Android 认为当前的 UI 状态应该被保存, 因此不建议在这之后再更改 UI. 然而, `onStop()` 通常在 `onSaveInstanceState()` 之后调用, 此时 `Lifecycle` 会从 `RESUMED` 变为 `CREATED`, 分发 `ON_STOP` 事件. 如果在 `onSaveInstanceState()` 和 `onStop()` 之间对 UI 进行更改, 可能导致应用导航状态不一致. [这是个问题](https://developer.android.com/topic/libraries/architecture/lifecycle?hl=zh-cn#onStop-and-savedState)!

```kotlin
class MyObserver : DefaultLifecycleObserver {
    override fun onCreate(owner: LifecycleOwner) {
        // 在 onCreate() 方法中执行初始化操作
    }

    override fun onDestroy(owner: LifecycleOwner) {
        // 在 onDestroy() 方法中执行释放资源操作
    }
}

class MyActivity : AppCompatActivity() {
    private val myObserver = MyObserver()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        lifecycle.addObserver(myObserver) // getLifecycle()
    }

    override fun onDestroy() {
        super.onDestroy()
        lifecycle.removeObserver(myObserver)
    }
}
```

每个 `LifecycleOwner` 对象都有一个协程作用域, 可以通过 `lifecycleScope` 属性来获取; 每一个 `ViewModel` 对象都有一个协程作用域, 可以通过 `viewModelScope` 属性来获取.  
生命周期感知型组件的协程作用域用于在生命周期范围内启动协程, 以便在生命周期状态发生变化时取消协程.

如果需要在 `LifecycleOwner` 对象只要进入到指定的生命周期状态就执行某个操作, 可以使用 `repeatOnLifecycle()` 函数, 该函数会在 `LifecycleOwner` 对象进入到指定的生命周期状态时执行指定的操作, 并且会在 `LifecycleOwner` 对象退出指定的生命周期状态时取消操作.

```kotlin
class MyActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        lifecycleScope.launch {

            // 随状态变化而反复执行
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                // 在 STARTED 状态下执行操作
            }

            // 单次长时间操作, 随状态变化可恢复运行直到运行完成
            whenStarted {
                // 在第一次 STARTED 状态下执行操作
            }

            whenResumed {
                // 在第一次 RESUMED 状态下执行操作
            }

            whenCreated {
                // 在第一次 CREATED 状态下执行操作
            }
        }
    }
}

class MyFragment : Fragment() {
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        viewLifecycleOwner.lifecycleScope.launch {
            viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {
                // 在 STARTED 状态下执行操作
            }
        }
    }
}

class MyViewModel : ViewModel() {
    init {
        viewModelScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                // 在 STARTED 状态下执行操作
            }
        }
    }
}
```

#### ViewModel(未完成)

`ViewModel` 是一个用于持久存储界面相关状态数据, 处理界面业务逻辑的类. 防止因为 `activity` 或 `fragment` 的重建而导致数据丢失. 同时, `ViewModel` 的作用域被限定为 `ViewModelStoreOwner` 的生命周期范围内, 通常是 `activity` 或 `fragment` 的生命周期范围内. 只有在 `activity` 或 `fragment` 在非配置更改的情况下被销毁时, `ViewModel` 才会被销毁, 比如调用 `finish()` 方法.

```kotlin
class MyViewModel : ViewModel() {
    private val _data = MutableStateFlow<String>()
    val data: StateFlow<String> = _data.asStateFlow()

    fun updateData(newData: String) {
        _data.value = newData
    }
}

class MyActivity : AppCompatActivity() {
    private val viewModel: MyViewModel by viewModels() // 使用 by viewModels() 代理属性来获取 ViewModel 实例, 这通常在 onCreate() 之前

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        viewModel = ViewModelProvider(this).get(SimpleViewModel::class.java) // 使用 ViewModelProvider 手动创建 ViewModel 实例


        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.data.collect { data ->
                    // 更新界面数据
                }
            }
        }
    }
}
```

因为 `ViewModelProvider` 只能通过默认的无参构造函数来创建 `ViewModel` 实例. 当 `ViewModel` 需要依赖外部组件时, 可以通过构造函数注入或 Hilt 库进行依赖注入, 并只能通过 `ViewModelProvider.Factory` 来创建 `ViewModel` 实例.

```kotlin
class MyViewModel @ViewModelInject constructor(
    private val repository: MyRepository
) : ViewModel() {
    private val _data = MutableStateFlow<String>()
    val data: StateFlow<String> = _data.asStateFlow()

    fun updateData(newData: String) {
        _data.value = newData
    }
}

class MyViewModelFactory @Inject constructor(
    private val repository: MyRepository
) : ViewModelProvider.Factory {
    override fun <T : ViewModel?> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(MyViewModel::class.java)) {
            return MyViewModel(repository) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}

class MyActivity : AppCompatActivity() {
    private val viewModel: MyViewModel by viewModels { MyViewModelFactory(repository) } // 使用 by viewModels() 代理属性来获取 ViewModel 实例, 这通常在 onCreate() 之前

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        var factory = MyViewModelFactory(repository)
        viewModel = ViewModelProvider(this, factory).get(SimpleViewModel::class.java) // 使用 ViewModelProvider 手动创建 ViewModel 实例

        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.data.collect { data ->
                    // 更新界面数据
                }
            }
        }
    }
}

```

可以通过 `SavedStateHandle` 在 `ViewModel` 中保存和恢复与界面状态相关的数据, 避免因为系统因内存不足等原因终止应用程序时导致的数据丢失, 从而在重启应用程序时恢复数据.

#### LiveData(未完成)

`LiveData` 是一种可观察的数据存储器类, 可以感知 `LifecycleOwner` 的生命周期状态, 并且只在 `LifecycleOwner` 处于活动状态时通知观察者.  
`MutableLiveData` 是 `LiveData` 的子类, 用于存储可变数据, 并且可以通过 `setValue()` 或 `postValue()` 方法来更新数据.

```kotlin
class MyViewModel : ViewModel() {
    private val _data = MutableLiveData<String>()
    val data: LiveData<String> = _data

    fun updateData(newData: String) {
        _data.value = newData
    }
}

class MyActivity : AppCompatActivity() {
    private val viewModel: MyViewModel by viewModels()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        val observer = Observer<String> { data ->
            // 更新界面数据

        }
        viewModel.data.observe(this, observer)
    }
}
```

[将协程与 LiveData 一起使用](<https://developer.android.com/topic/libraries/architecture/coroutines?hl=zh-cn#livedata:~:text=项> 浪费资源。-,将协程与 LiveData 一起使用,-使用 LiveData 时)

#### StateFlow

`StateFlow` 是一种可观察的数据存储器类, 可以感知 `LifecycleOwner` 的生命周期状态, 并且只在 `LifecycleOwner` 处于活动状态时通知观察者.  
`MutableStateFlow` 是 `StateFlow` 的子类, 用于存储可变数据, 并且可以通过 `value` 属性来更新数据.

```kotlin
class MyViewModel : ViewModel() {
    private val _data = MutableStateFlow<String>("")
    val data: StateFlow<String> = _data.asStateFlow()

    fun updateData(newData: String) {
        _data.value = newData
    }
}

class MyActivity : AppCompatActivity() {
    private val viewModel: MyViewModel by viewModels()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.data.collect { data ->
                    // 更新界面数据
                }
            }
        }
    }
}
```

#### DataStore

#### Room

#### WorkManager

### 依赖管理

- 通过构造函数注入或 Hilt 库进行依赖注入
- 依赖注入使类能够定义其依赖项而不构造它们. 在运行时, 另一个类负责提供这些依赖项.
- 服务定位器: 服务定位器模式提供了一个注册表, 类可以从中获取其依赖项而不构造它们.

Dagger&Hilt 中常见的注解及其功能的详细介绍:

- `@HiltAndroidApp`: 用于标记应用程序的 `Application` 类以在应用程序启动时触发 `Hilt` 的代码生成, 基于 Dagger 生成和管理依赖注入的必要组件.
- `@AndroidEntryPoint`: 用于标记 `Activity`, `Fragment`, `View`, `Service`, `BroadcastReceiver` 等 Android 组件, 使其成为的依赖注入的入口点, 表示他们需要被注入依赖项.
- `@HiltViewModel`: 用于标记 `ViewModel` 类, 以告知依赖注入框架为 `ViewModel` 类提供依赖注入.
- `@Inject`: 用于标记构造函数, 字段, 方法或属性, 表示它们是依赖注入的目标, 从而自动为这些目标注入所需的依赖项. (除了默认的一些依赖, 其他依赖项都需要通过 `@Module` 来告知如何提供)
- `@Module`: 标记一个 `object` 类为依赖注入模块, 模块中的方法可以通过 `@Provides` 注解告知依赖注入框架如何提供依赖项.
- `@InstallIn`: 用于标记 `@Module` 类, 以指定该模块的生命周期和作用域. 如 `ApplicationComponent`, `ActivityComponent`, `FragmentComponent`, `ServiceComponent`, `BroadcastReceiverComponent` 等.
- `@Provides`: 用于标记 `@Module` 类中的方法, 以告知依赖注入框架如何提供依赖项.
- `@Singleton`: 用于标记依赖项的作用域, 表示该依赖项在所在的依赖注入模块的整个生命周期中只会被创建一次.
- `@Binds`: 标记一个 `abstract` 抽象类为依赖注入模块, 模块中的抽象方法可以通过 `@Binds` 注解告知依赖注入框架如何将抽象接口方法的依赖项与具体实现绑定.
- `@Qualifier`: 标记一个 `annotation` 注解类来自定义依赖项类型注解, 以通过注解的形式告知依赖注入框架何区分相同类型的不同依赖项实现.
- `@Named`: 内置的用于标记依赖项的类型注解, 以通过注解的形式告知依赖注入框架何区分相同类型的不同依赖项实现.
- `@ViewModelInject`: 内置的用于标记 `ViewModel` 类的构造函数, 以告知依赖注入框架为 `ViewModel` 类提供依赖注入.
- `@EntryPoint`: 定义 Hilt 组件外部的依赖项的入口点. 可以让非 Hilt 管理的类也能获取依赖项.
- `@ApplicationContext`: 内置的用于标记 `Context` 类型的依赖项, 以告知依赖注入框架注入的是应用程序的 `Context` 对象.
- `@ActivityRetainedScoped`: 内置的用于定义依赖项的生命周期与 `Activity` 保持一致.

```kotlin
@HiltAndroidApp
class MyApplication : Application()

@Qualifier
@Retention(AnnotationRetention.BINARY)
annotation class MyQualifier

@Module
@InstallIn(SingletonComponent::class)
object MyModule {
    @Provides
    @Singleton
    fun provideMyDependency(): MyDependency {
        return MyDependency()
    }

    @Provides
    @Named("MyDependency")
    fun provideNamedDependency(): MyDependency {
        return MyDependency()
    }

    @Provides
    @MyQualifier
    fun provideQualifiedDependency(): MyDependency {
        return MyDependency()
    }
}

@Module
@InstallIn(ApplicationComponent::class)
abstract class MyAbstractModule {
    @Binds
    abstract fun bindMyDependency(impl: MyDependencyImpl): MyDependency
}

@AndroidEntryPoint
class MyActivity : AppCompatActivity() {
    @Inject
    @Named("MyDependency")
    lateinit var myDependency: MyDependency
}

@HiltViewModel
class MyViewModel @Inject constructor(
    @MyQualifier private val myDependency: MyDependency
) : ViewModel()

@EntryPoint
@InstallIn(ApplicationComponent::class)
interface MyEntryPoint {
    fun myDependency(): MyDependency
}

class MyService : Service() {
    private val myDependency: MyDependency by lazy {
        EntryPointAccessors.fromApplication(this, MyEntryPoint::class.java).myDependency()
    }
}
```

### 项目测试

> [!cite] > [Android 测试模块](https://developer.android.com/topic/modularization/patterns#test-modules) > [Android 测试](https://developer.android.com/training/testing?hl=zh-cn)

- 测试内容

    - 对 ViewModel (包括 Flow) 进行单元测试
    - 对数据层实体进行单元测试. 即对代码库和数据源进行单元测试
    - 进行界面导航测试 (可在持续集成环境中用作回归测试)
    - 测试 StateFlow 和 LiveData 的行为

        - 尽可能对 value 属性进行断言
        - 如果使用 WhileSubscribed, 您应该创建一个 collectJob

### 模块组织

- 项目模块化: 将应用程序拆分为多个模块, 以便更容易管理和维护, 以下是从高到低的模块组织结构:

    - 应用模块(app): 包含界面入口点, 依赖于功能模块, 支持产品变种(`productFlavors`), 编译为不同的二进制文件, 如不同设备或不同版本的 APK 文件, 以及不同的构建类型(`buildTypes`), 如调试和发布版本.
    - 功能模块(feature): 包含一系列相关的屏幕. 对于导航栏, 每个功能可能对应一个目的地. 依赖于数据模块和通用模块.
    - 通用模块(core): 包含应用程序中多个模块之间共享的代码, 如工具类、扩展函数、自定义视图等.
    - 数据模块(data): 包含存储库(`Repository`)、数据源(`DataSource`)和模型类(`Model`), 用于封装特定领域的所有数据和业务逻辑, 将存储库公开为外部 API.
    - 测试模块(test): 包含单元测试和 UI 测试, 用于测试应用程序的各个部分.

- 注意事项:

    - 模块间需要相互依赖并通信时, 可以通过将相关逻辑放在另一个中介模块中进行解耦, 以避免直接依赖. 同时此中介模块可以被其他任何需要此逻辑的模块复用.
    - 高级模块(业务逻辑)不应该直接依赖于低级模块的具体实现, 而是应该依赖于其抽象接口. 这样可以方便低级模块的替换, 扩展和测试. 具体项目中可以同时创建一个 `api` 模块和一个 `impl` 模块, `api` 模块定义接口, `impl` 模块实现接口.

()[![https://developer.android.com/static/topic/libraries/architecture/images/mad-arch-ui-udf-in-action.png?hl=zh-cn](https://developer.android.com/static/topic/libraries/architecture/images/mad-arch-ui-udf-in-action.png?hl=zh-cn)]

### 架构代码样例

```kotlin

data class Author(
    val id: String,
    val name: String,
)

data class LoginUiState(
    val isLoading: Boolean = false,
    val errorMessage: String? = null,
    val isUserLoggedIn: Boolean = false
)

class LoginViewModel : ViewModel() {
    private val _uiState = MutableStateFlow(LoginUiState())
    val uiState: StateFlow<LoginUiState> = _uiState.asStateFlow()
    /* ... */
}

class LoginActivity : AppCompatActivity() {
    private val viewModel: LoginViewModel by viewModels()

    override fun onCreate(savedInstanceState: Bundle?) {
        /* ... */

        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.uiState.collect { uiState ->
                    if (uiState.isUserLoggedIn) {
                        // Navigate to the Home screen.
                    }
                    ...
                }
            }
        }
    }
}

private const val DOB_VALIDATION_KEY = "dobValidationKey"

class DobValidationFragment : Fragment() {

    private var validationInProgress: Boolean = false
    private val viewModel: DobValidationViewModel by viewModels()

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        val binding = // ...
        validationInProgress = savedInstanceState?.getBoolean(DOB_VALIDATION_KEY) ?: false

        binding.continueButton.setOnClickListener {
            viewModel.validateDob()
            validationInProgress = true
        }

        viewLifecycleOwner.lifecycleScope.launch {
            viewModel.uiState
                .flowWithLifecycle(viewLifecycleOwner.lifecycle)
                .collect { uiState ->
                    // Update other parts of the UI ...

                    // If the input is valid and the user wants
                    // to navigate, navigate to the next screen
                    // and reset `validationInProgress` flag
                    if (uiState.isDobValid && validationInProgress) {
                        validationInProgress = false
                        navController.navigate(...) // Navigate to next screen
                    }
                }
        }

        return binding
    }

    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)
        outState.putBoolean(DOB_VALIDATION_KEY, validationInProgress)
    }
}



data class NewsItem(
    val title: String,
    val body: String,
    val bookmarked: Boolean = false,
    val publicationDate: String,
    val onBookmark: () -> Unit
)

data class Message(val id: Long, val message: String)
data class NewsUiState(
    val isSignedIn: Boolean = false, // 状态属性
    val isPremium: Boolean = false,
    val isFetchingArticles: Boolean = false, // 加载状态
    val newsItems: List<NewsItem> = listOf(), // 数据
    val userMessages: List<Message> = listOf() // 反馈信息
)
val NewsUiState.canBookmarkNews: Boolean get() = isSignedIn && isPremium // 其他属性的派生属性
interface NewsRepository{}

class NewsViewModel : ViewModel() {
    private val repository: NewsRepository
    private val formatDateUseCase: FormatDateUseCase,
    private val _uiState = MutableStateFlow(NewsUiState())
    val uiState: StateFlow<NewsUiState> = _uiState.asStateFlow()
    val newsListUiItems = repository.latestNews.map { news ->
        NewsItemUiState(
            title = news.title,
            body = news.body,
            bookmarked = news.bookmarked,
            publicationDate = formatDateUseCase(news.publicationDate),
            // Business logic is passed as a lambda function that the
            // UI calls on click events.
            onBookmark = {
                repository.addBookmark(news.id)
            }
        )
    }

    private var fetchJob: Job? = null

    fun fetchArticles(category: String) {
        fetchJob?.cancel()
        fetchJob = viewModelScope.launch {
            try {
                val newsItems = repository.newsItemsForCategory(category)
                _uiState.update {
                    it.copy(newsItems = newsItems)
                }
            } catch (ioe: IOException) {
                // Handle the error and notify the UI when appropriate.
                _uiState.update {
                    val messages = getMessagesFromThrowable(ioe)
                    it.copy(userMessages = messages)
                 }
            }
        }
    }

    fun refreshNews() {
        viewModelScope.launch {
            // If there isn't internet connection, show a new message on the screen.
            if (!internetConnection()) {
                _uiState.update { currentUiState ->
                    currentUiState.copy(userMessages = arrayOf(["No Internet connection"]))
                }
                return@launch
            }

            // Do something else.
        }
    }

    fun userMessageShown() {
        _uiState.update { currentUiState ->
            currentUiState.copy(userMessage = null)
        }
    }

}

class NewsActivity : AppCompatActivity() {
    private lateinit var binding2: ActivityLoginBinding
    private lateinit var binding: ActivityLatestNewsBinding
    private val viewModel: NewsViewModel by viewModels()

    override fun onCreate(savedInstanceState: Bundle?) {
        ...

        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                // 界面根据新数据, 更新要显示的数据
                viewModel.uiState
                    .map { it.isFetchingArticles }
                    .distinctUntilChanged()
                    .collect { progressBar.isVisible = it }
                // 根据状态的更改, 界面进行响应
                viewModel.uiState.collect { uiState ->
                    // 根据一些信息的更改, 界面进行一些通知
                    uiState.userMessage?.let {
                        // TODO: Show Snackbar with userMessage.

                        // Once the message is displayed and
                        // dismissed, notify the ViewModel.
                        viewModel.userMessageShown()
                    }
                }
            }
        }

        binding.expandButton.setOnClickListener {
            binding.expandedSection.visibility = View.VISIBLE
        }

        binding.refreshButton.setOnClickListener {
            viewModel.refreshNews()
        }

        binding2.helpButton.setOnClickListener {
            navController.navigate(...) // Open help screen
        }
    }
}

data class ArticleApiModel(
    val id: Long,
    val title: String,
    val content: String,
    val publicationDate: Date,
    val modifications: Array<ArticleApiModel>,
    val comments: Array<CommentApiModel>,
    val lastModificationDate: Date,
    val authorId: Long,
    val authorName: String,
    val authorDateOfBirth: Date,
    val readTimeMin: Int
)

data class Article(
    val id: Long,
    val title: String,
    val content: String,
    val publicationDate: Date,
    val authorName: String,
    val readTimeMin: Int
)

class NewsRemoteDataSource(
  private val newsApi: NewsApi,
  private val ioDispatcher: CoroutineDispatcher
) {
    /**
     * Fetches the latest news from the network and returns the result.
     * This executes on an IO-optimized thread pool, the function is main-safe.
     */
    suspend fun fetchLatestNews(): List<ArticleHeadline> =
        // Move the execution to an IO-optimized thread since the ApiService
        // doesn't support coroutines and makes synchronous requests.
        withContext(ioDispatcher) {
            newsApi.fetchLatestNews()
        }
    }

// Makes news-related network synchronous requests.
interface NewsApi {
    fun fetchLatestNews(): List<ArticleHeadline>
}

// NewsRepository is consumed from other layers of the hierarchy.
class NewsRepository(
    private val newsRemoteDataSource: NewsRemoteDataSource,
        // This could be CoroutineScope(SupervisorJob() + Dispatchers.Default).
    private val externalScope: CoroutineScope
) {
    suspend fun fetchLatestNews(): List<ArticleHeadline> =
        newsRemoteDataSource.fetchLatestNews()
    // Mutex to make writes to cached values thread-safe.
    private val latestNewsMutex = Mutex()

    // Cache of the latest news got from the network.
    private var latestNews: List<ArticleHeadline> = emptyList()

    suspend fun getLatestNews(refresh: Boolean = false): List<ArticleHeadline> {
        return if (refresh) {
            externalScope.async {
                newsRemoteDataSource.fetchLatestNews().also { networkResult ->
                    // Thread-safe write to latestNews.
                    latestNewsMutex.withLock {
                        latestNews = networkResult
                    }
                }
            }.await()
        } else {
            return latestNewsMutex.withLock { this.latestNews }
        }
    }
}

class RefreshLatestNewsWorker(
    private val newsRepository: NewsRepository,
    context: Context,
    params: WorkerParameters
) : CoroutineWorker(context, params) {

    override suspend fun doWork(): Result = try {
        newsRepository.refreshLatestNews()
        Result.success()
    } catch (error: Throwable) {
        Result.failure()
    }
}

private const val REFRESH_RATE_HOURS = 4L
private const val FETCH_LATEST_NEWS_TASK = "FetchLatestNewsTask"
private const val TAG_FETCH_LATEST_NEWS = "FetchLatestNewsTaskTag"

class NewsTasksDataSource(
    private val workManager: WorkManager
) {
    fun fetchNewsPeriodically() {
        val fetchNewsRequest = PeriodicWorkRequestBuilder<RefreshLatestNewsWorker>(
            REFRESH_RATE_HOURS, TimeUnit.HOURS
        ).setConstraints(
            Constraints.Builder()
                .setRequiredNetworkType(NetworkType.TEMPORARILY_UNMETERED)
                .setRequiresCharging(true)
                .build()
        )
            .addTag(TAG_FETCH_LATEST_NEWS)

        workManager.enqueueUniquePeriodicWork(
            FETCH_LATEST_NEWS_TASK,
            ExistingPeriodicWorkPolicy.KEEP,
            fetchNewsRequest.build()
        )
    }

    fun cancelFetchingNewsPeriodically() {
        workManager.cancelAllWorkByTag(TAG_FETCH_LATEST_NEWS)
    }
}

```

## UI

应用的界面 (UI) 就是您在屏幕上所看到的内容 (文本、图片、按钮和许多其他类型的元素) 及其在屏幕上的布局方式.

### 界面状态保存

### 临时存放

Jetpack Compose 可以使用在项目的  Android 自动生成的 `R`  类中通过资源 ID 访问 Android 项目中定义的资源.

- `painterResource()`  函数会加载可绘制图片资源, 并将资源 ID (在本例中为  `R.drawable.androidparty` ) 作为实参.
- `stringResource()`

`onCreate()`  函数中的  [setContent()](https://developer.android.com/reference/kotlin/androidx/compose/ui/platform/ComposeView?hl=zh-cn#setContent(kotlin.Function0))[setContent()](https://developer.android.com/reference/kotlin/androidx/compose/ui/platform/ComposeView?hl=zh-cn#setContent(kotlin.Function0))  函数用于通过可组合函数定义布局.

可组合函数 Jetpack Compose 是用于构建 Android 界面的新款工具包. 任何标有  `@Composable`  注解的函数都可通过  `setContent()`  函数或其他可组合函数进行调用. 该注解可告知 Kotlin 编译器 Jetpack Compose 使用的这个函数会生成 UI.

注解

```kotlin
@Composable
@Preview
```

修饰符 [Modifier](https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier?hl=zh-cn)[Modifier](https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier?hl=zh-cn)  用于扩充或修饰可组合项, 如修饰组件的布局.

- 内边距修饰符 (`Modifier.padding`) 在  `Text`  可组合项的周围添加空间.

```kotlin
Modifier.padding(
    start = 16.dp,
    top = 16.dp,
    end = 16.dp,
    bottom = 16.dp
)

Modifier
    .padding(16.dp)
    .align(alignment = Alignment.End)
```

- 背景颜色修饰符 `Modifier.background`

![_](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-add-images/img/df69881d07b064d0.gif?hl=zh-cn)

基本标准布局元素是  `Column`、`Row,`  和  `Box`.

- [Box](https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/package-summary?hl=zh-cn#Box(androidx.compose.ui.Modifier,androidx.compose.ui.Alignment,kotlin.Boolean,kotlin.Function1))[Box](https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/package-summary?hl=zh-cn#Box(androidx.compose.ui.Modifier,androidx.compose.ui.Alignment,kotlin.Boolean,kotlin.Function1))  布局是 Compose 中的标准布局元素之一. 使用  `Box`  布局可将元素堆叠在一起. `Box`  布局还可用于配置它所包含的元素的特定对齐方式.

应用在某些情况下可能会被翻译成其他语言, 一些固定的 `String`  数据类型可以提取到资源文件中进行管理, 避免硬编码导致无法进行翻译.

@JvmOverloads constructor 用于自动在 java 中生成各种重载的构造函数

[ConstraintLayout 之 ConstraintSet - enzo 的博客](https://enzowyf.github.io/constraintset.html)

// 设置控件尺寸  
// constrainWidth/constrainHeight  
// constrainDefaultWidth/constrainDefaultHeight  
// constrainMaxWidth/constrainMaxHeight  
// constrainMinWidth/constrainMinHeight

// 设置控件间直接约束关系

// 控件 start 的某边与 end 的某边对齐, margin 用于设置边与边中间间距  
// connect(int startID, int startSide, int endID, int endSide, int margin)  
// connect(int startID, int startSide, int endID, int endSide)

// 控件 center 置于另两个控件 first 和 second 之间, bias(0~1) 用于设置位置偏移比例  
// center(int centerID, int firstID, int firstSide, int firstMargin, int secondID, int secondSide, int secondMargin, float bias)  
// 控件 center 水平居中于另一个控件 centerID, leftId/rightId 用于设置左右边界控件  
// centerHorizontally(int centerID, int leftId, int leftSide, int leftMargin, int rightId, int rightSide, int rightMargin, float bias)

// 方向: ConstraintSet.TOP/BOTTOM/START/END/LEFT/RIGHT/BASELINE(TextView)

// 控件 viewId 与 toView 水平居中  
// centerHorizontally(int viewId, int toView)  
// 控件 viewId 与 toView 垂直居中  
// centerVertically(int viewId, int toView)

// 修改控件属性  
// setVisibility/setAlpha/setRotation  
// setRotationX/setRotationY  
// setScaleX/setScaleY/setTransformPivot/setTransformPivotX/setTransformPivotY  
// setTranslation/setTranslationX/setTranslationY/setTranslationZ  
// setElevation

RecyclerView ( `RecyclerView` 和 `RecyclerView.LayoutManager` )

- 数据驱动：需要一个数据源来提供要显示的数据, 见 `RecyclerView.Adapter` 和 `RecyclerView.ViewHolder`
- 可重用性：支持视图的重用机制, 通过重用池来减少内存开销, 见 `onCreateViewHolder` 和 `onBindViewHolder`
- 布局管理：支持多种布局, 通过不同的布局管理器来控制视图的显示方式 (如网格、列表等) , 见 `LinearLayoutManager` 、 `GridLayoutManager` 、 `StaggeredGridLayoutManager`
- 自定义单元格：允许自定义单元格, 以便显示复杂的内容. 创建自定义的 `ViewHolder` 子类, 然后在 `Adapter` 中使用这个 `ViewHolder`, 在 `onCreateViewHolder` 和 `onBindViewHolder` 方法中绑定 `ViewHolder`.

### 基础组件

`AbsListView` 是一个抽象类, 不能用作应用程序布局中的 `View` 元素, 尽管您可以将其用作 `Base Class` 来实现您自己的 `View`. 在  
`AbsoluteLayout` 要被弃用了. 允许您指定其子级的确切位置 (x/y 坐标) 的布局. 与没有绝对定位的其他类型的布局相比, 绝对布局不太灵活且更难以维护.  
`AbsSeekBar` 和 `AbsSpinner` 全是抽象类.  
`ActionMenuView`, 操作菜单视图, 支持接收菜单项单击事件的接口(看到有人当做底部菜单栏使用的).  
`Adapter` 适配器就像数据源和用户界面之间的桥梁. 它从各种数据源读取数据, 将其转换为 `View` 对象, 并将其提供给链接的 `Adapter` 视图以创建 UI 组件.  
`AdapterView` 适配器视图可用于以列表或网格等形式有效地显示由适配器提供的大量数据. `Adapter` 获取数据并根据该数据创建一个 `View , 然后将该`View `提供给`AdapterView `. 然后`AdapterView `以想要的方式显示数据.`AlphabetIndexer `实现`SectionIndexer `接口的适配器的辅助类. 如果适配器中的项目通过简单的基于字母的排序进行排序, 则此类提供了一种使用二分搜索对大型列表进行快速索引的方法. 在`ListView `或`RecyclerView `中, 可以使用`AlphabetIndexer `来为列表提供分节导航.`AnalogClock `被弃用了`BaseAdapter`

- `ArrayAdapter` 通过此类可以从数组获取 `AdapterView`,
- `CursorAdapter`
- `SimpleAdapter`
- `ResourceCursorAdapter`
- `SimpleCursorAdapter`

`AutoCompleteTextView` 可编辑的文本视图, 在用户键入时自动显示完成建议. 建议列表显示在下拉菜单中, 用户可以从中选择一个项目来替换编辑框的内容. 建议列表是从数据适配器获取的  
`CalendarView` 用于显示和选择日期的日历小部件.  
`CheckBox`, 创建一个复选框选项, 每个复选框都是单独管理的, 必须为每个复选框注册点击监听器.  
`CheckedTextView`, 扩展 `TextView` 支持 `Checkable` 界面和显示. 也就是说文本支持选中后复选支持.  
`Chronometer` 基于 `TextView` 实现的计时器. 控制和展示计时时间.  
`CompoundButton` 复合按钮, 抽象类, 具有两种状态的按钮, 选中和未选中(开和关). 当按下或单击按钮时, 状态会自动更改. 主要派生出了 `CheckBox`, `RadioButton`, `Switch`, `ToggleButton`  
`DialerFilter` 被弃用  
`DigitalClock` 被弃用  
`EdgeEffect` 用于在可滑动控件边缘提供视觉反馈, 例如 `ScrollView` 在滑动到边界时显示的弧形颜色效果.  
`EditText` 用于输入和修改文本的用户界面元素, 支持输入类型选择, 文本类型, 密码类型等.  
`ExpandableListView` 可扩展列表视图, 显示垂直滚动的两级列表中的项目的视图, 与 `ListView` 的不同之处在于允许两个级别：可以单独展开以显示其子级的组.  
`Filter` 过滤器使用过滤模式来异步约束数据, 细节待定.  
`FrameLayout` 框架布局, 可以添加多个子视图进行叠放, 新添加的视图, 会覆盖在旧视图上面.  
`Gallery` 被弃用了. 可以参考新的 `HorizontalScrollView` 和 `ViewPager`  
`GridLayout` 矩形网格布局, 可以指定网格的列数和行数. `GridLayout` 基本上将其子级放置在矩形网格中. 该网格有一组许多细线, 将视图区域分隔成单元格, N 列的网格, 那么我们将有 N+1 个从 0 开始的网格索引. 子项占据一个或多个连续的单元格, 由其 `rowSpec` 和 `columnSpec` 布局参数定义, 占据相同单元格的子项, 可能会产生重叠.  
`GridView` 网格视图, 将多个子项显示在支持滚动的二维网格的视图. 数据通过 Adapter 适配器与 GridView 连接, 并将每条数据插入到将在 GridView 中显示的适当项目中.  
`HeaderViewListAdapter`, 一个基类, 目前不需要学习.  
`HorizontalScrollView` 水平滚动视图, 也只支持水平滚动, 需要在其中放置一个包含要滚动的全部内容的子项, 在水平方向上, 呈现用户可以滚动浏览的顶级项目的水平数组.  
`ImageButton` 图像按钮, 显示一个带有图像 (而不是文本) 的按钮, 用户可以按下或单击该按钮.  
`ImageSwitcher` 图像切换器, 当在两个 `ImageView` 上设置新图像时, `ViewSwitcher` 在两个 `ImageView` 之间切换. 添加到 `ImageSwitcher` 的视图必须都是 `ImageView`.  
`ImageView` 图像视图, 显示图片资源, 例如 `Bitmap` 或者 `Drawable` 资源. I  
`LinearLayout` 线性布局, 将其他视图水平排列在单列中或垂直排列在单行中的布局.  
`ListPopupWindow` 列表弹出窗口, `ListPopupWindow` 将自身锚定到主视图并显示一个选项列表, 能够显示 `ListAdapter` 中的项目. , 进行包括定位、滚动父项以适应下拉菜单、与 IME (如果存在) 进行合理交互等.  
`ListView` 显示可垂直滚动的视图集合, 其中每个视图都位于列表中前一个视图的正下方.  
`Magnifier` 放大镜, `Android` 放大镜小部件. 可由附加到窗口的任何视图使用.  
`MediaController` 媒体控制器. 如果拥有 “android.permission.MEDIA_CONTENT_CONTROL” 权限或者是启用的通知侦听器, 或者直接从会话所有者获取 `MediaSession.Token`, 则可以通过 `MediaSessionManager` 创建 `MediaController`. 允许应用程序与正在进行的媒体会话交互. 媒体按钮和其他命令可以发送到会话. 可以注册回调以接收来自会话的更新, 例如元数据和播放状态变化.  
`MultiAutoCompleteTextView`,可编辑的文本视图, 扩展 `AutoCompleteTextView`, 可以显示用户正在键入的文本子字符串的补全建议, 而不只是整个内容. `AutoCompleteTextView` 仅提供有关整个文本的建议. 但是 `MultiAutoCompleteTextView` 为文本的子字符串提供了多种建议.  
`NumberPicker` 数字选择器, 一个小部件, 使用户能够从预定义范围中选择一个数字, 支持显示为可编辑输入字段, 上面有一个递增按钮, 下面有一个递减按钮. 也支持将当前值显示为可编辑输入字段, 上面的值较小, 下面的值较大. 点击较小或较大的值可以通过向上或向下动画数轴来选择该值, 以使所选值成为当前值. 向上或向下滑动允许当前值多次递增或递减. 长按较小和较大值还可以快速更改当前值. 点击当前值可以输入所需的值. 还支持将当前值显示为滚动垂直选择器, 所选值位于中心, 上方和下方是前一个和后一个数字, 并由分隔线分隔. 通过垂直滑动来更改该值.  
`OverScroller` 过滚, 封装了滚动能力, 同时支持超出滚动操作范围的能力.  
`PopupMenu` 弹出菜单, `PopupMenu` 在锚定到视图的模式弹出窗口中显示菜单. 如果有空间, 弹出窗口将出现在锚视图下方；如果没有空间, 则弹出窗口将出现在锚视图上方. 如果 `IME` 可见, 则弹出窗口不会与其重叠, 直到触摸它为止. 触摸弹出窗口外部会将其关闭.  
`PopupWindow` 弹出窗口. 此类表示可用于显示任意视图的弹出窗口. 弹出窗口是一个浮动容器, 出现在当前活动的顶部.  
`ProgressBar` 进度条. 指示操作进度的用户界面元素. 进度条支持两种表示进度的模式：确定和不确定. 不确定模式是进度条的默认模式, 显示循环动画, 但不指示具体的进度量. 当想要显示已发生特定数量的进度时, 请对进度栏使用确定模式. 例如, 正在检索的文件的剩余百分比、写入数据库的批次中的记录数量或正在播放的音频文件的剩余百分比.  
`QuickContactBadge`, 显示为一个小徽章, 用户单击该徽章即可快速创建联系人, 例如将电话号码或电子邮件添加到联系人列表.

- AbsListView
- AbsListView.LayoutParams
- AbsoluteLayout
- AbsoluteLayout.LayoutParams
- AbsSeekBar
- AbsSpinner
- ActionMenuView

    - ActionMenuView.LayoutParams

- AdapterView
- AdapterView.AdapterContextMenuInfo
- AdapterViewAnimator
- AdapterViewFlipper
- AlphabetIndexer
- AnalogClock
- ArrayAdapter
- AutoCompleteTextView
- BaseAdapter
- BaseExpandableListAdapter
- Button
- CalendarView
- CheckBox
- CheckedTextView
- Chronometer
- CompoundButton
- CursorAdapter
- CursorTreeAdapter
- DatePicker
- DialerFilter
- DigitalClock
- EdgeEffect
- EditText
- ExpandableListView

    - ExpandableListView.ExpandableListContextMenuInfo

- Filter

    - Filter.FilterResults

- FrameLayout

    - FrameLayout.LayoutParams

- Gallery

    - Gallery.LayoutParams

- GridLayout

    - GridLayout.Alignment
    - GridLayout.LayoutParams
    - GridLayout.Spec

- GridView
- HeaderViewListAdapter
- HorizontalScrollView
- ImageButton
- ImageSwitcher
- ImageView
- LinearLayout

    - LinearLayout.LayoutParams

- ListPopupWindow
- ListView

    - ListView.FixedViewInfo

- Magnifier

    - Magnifier.Builder

- MediaController
- MultiAutoCompleteTextView

    - MultiAutoCompleteTextView.CommaTokenizer

- NumberPicker
- OverScroller
- PopupMenu
- PopupWindow
- ProgressBar
- QuickContactBadge
- RadioButton
- RadioGroup

    - RadioGroup.LayoutParams

- RatingBar
- RelativeLayout

    - RelativeLayout.LayoutParams

- RemoteViews

    - RemoteViews.DrawInstructions
    - RemoteViews.DrawInstructions.Builder
    - RemoteViews.RemoteCollectionItems
    - RemoteViews.RemoteCollectionItems.Builder
    - RemoteViews.RemoteResponse
    - RemoteViews.RemoteViewOutlineProvider

- RemoteViewsService
- ResourceCursorAdapter
- ResourceCursorTreeAdapter
- Scroller
- ScrollView
- SearchView
- SeekBar
- ShareActionProvider
- SimpleAdapter
- SimpleCursorAdapter
- SimpleCursorTreeAdapter
- SimpleExpandableListAdapter
- SlidingDrawer
- Space
- Spinner
- StackView
- Switch
- TabHost

    - TabHost.TabSpec

- TableLayout

    - TableLayout.LayoutParams

- TableRow

    - TableRow.LayoutParams

- TabWidget
- TextClock
- TextSwitcher
- TextView

    - TextView.SavedState

- TimePicker
- Toast

    - Toast.Callback

- ToggleButton
- Toolbar

    - Toolbar.LayoutParams

- TwoLineListItem
- VideoView
- ViewAnimator
- ViewFlipper
- ViewSwitcher
- ZoomButton
- ZoomButtonsController
- ZoomControls
- InlineContentView
- InlinePresentationSpec

    - InlinePresentationSpec.Builder

### androidx 扩展组件

- ActionBar

    - ActionBar.LayoutParams
    - ActionBar.Tab

- ActionBarDrawerToggle
- AlertDialog

    - AlertDialog.Builder

- AppCompatActivity
- AppCompatDelegate
- AppCompatDialog
- AppCompatDialogFragment
- AppCompatViewInflater
- AppLocalesMetadataHolderService
- ActionMenuView

    - ActionMenuView.LayoutParams

- AppCompatAutoCompleteTextView
- AppCompatButton
- AppCompatCheckBox
- AppCompatCheckedTextView
- AppCompatEditText
- AppCompatImageButton
- AppCompatImageView
- AppCompatMultiAutoCompleteTextView
- AppCompatRadioButton
- AppCompatRatingBar
- AppCompatSeekBar
- AppCompatSpinner
- AppCompatTextView
- AppCompatToggleButton
- LinearLayoutCompat

    - LinearLayoutCompat.LayoutParams

- ListPopupWindow
- PopupMenu
- SearchView
- ShareActionProvider
- SwitchCompat
- ThemedSpinnerAdapter.Helper
- Toolbar

    - Toolbar.LayoutParams
    - Toolbar.SavedState

- TooltipCompat

### androidx 碎片组件(Fragment)

`Fragment`是 `Activity` 中使用的一种可重用 UI 组件, 可以在 `Activity` 中被添加、替换、移除, 也可以在 `Fragment` 中嵌套其他 `Fragment`, 有自己的生命周期, 可以与 `Activity` 共享生命周期.

- `Fragment` 生命周期回调方法: `onCreate()` , `onCreateView()` , `onViewCreated()` , `onViewStateRestored()` , `onStart()` , `onResume()` , `onPause()` , `onStop()` , `onSaveInstanceState()` , `onDestroyView()` , `onDestroy()`
- `Fragment` 生命周期状态: `CREATED`, `STARTED`, `RESUMED`, `DESTROYED`. 可以由 `getLifecycle().getCurrentState()` 获取当前状态
- `Fragment` 视图状态: `INITIALIZED` , `CREATED` , `STARTED` , `RESUMED` , `DESTROYED`. 可以由 `getViewLifecycleOwner().getLifecycle().getCurrentState()` 获取当前状态

实际开发中, `Fragment` 需要一个托管它的视图容器, 通常是一个 `FrameLayout` 等布局容器. 新的 API 提供了 `FragmentContainerView` 来代替 `FrameLayout`, 支持更好的视觉效果设置, 和额外的编辑器功能.

可以根据不同的场景获取不同的 `FragmentManager` 管理实例, 来管理场景内 `Fragment` 的添加、替换、移除等操作. `FragmentManager` 通过事务(`FragmentTransaction`) 和回退栈(`BackStack`) 来管理 `Fragment` 的状态和生命周期.

回退栈是一个后进先出的栈, 用于存储 `Fragment` 的状. 在应用的任意时刻, 只能有一个 `FragmentManager` 可以控制 `Fragment` 的回退栈, 所以在多 `Fragment` 的情况下, 需要使用 `setPrimaryNavigationFragment()` 方法在不同的导航片段之间切换主要导航控制权, 以便正确管理回退栈. 吃外如果需要支持多个回退栈, 可以使用 `saveBackStack()` 和 `restoreBackStack()` 方法来保存和恢复回退栈, 比如在导航栏切换时.

事务是一组针对 `Fragment`的操作集合, 通过 `beginTransaction()` 或 kotlin 扩展方法 `commit` 来创建和提交事务, 可以包括任意数量的操作. 事务执行时可以通过 `addToBackStack()` 方法在回退栈中保存事务, 这样可以通过 `popBackStack()` 方法来回退到上一个状态. 没添加到回退栈的事务会被立即执行, 但不会保存状态, 比如删除任务会立即删除和销毁, 无法回撤.

如果设备发生了配置变化 (如屏幕旋转) , Activity 及其所有 Fragment 都会被销毁并重新创建, 此时需要注意 `Fragment` 的实例初始化问题.

- Fragment

    - DialogFragment
    - PreferenceFragmentCompat
    - ListFragment

```kotlin
class MyFragment : Fragment() {
    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        return inflater.inflate(R.layout.fragment_my, container, false)
    }
}

class MyActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        if (savedInstanceState == null) {
            supportFragmentManager.beginTransaction()
                .add(R.id.fragment_container, MyFragment())
                .commit()
            // 或者
            supportFragmentManager.commit {
                add<MyFragment>(R.id.fragment_container)
            }
        }
    }
}
```

- FragmentContainer: 一个抽象类, 用于管理 Fragment 的容器, 通常是一个 ViewGroup
- FragmentContainerView: 一个 ViewGroup, 用于管理 Fragment 的容器
- FragmentManager:

    - 在 Activity 中通过 `getSupportFragmentManager()` 获取管理实例
    - 在 Fragment 中通过 `getChildFragmentManager()` 获取管理实例
    - 在 Child Fragment 中通过 `getParentFragmentManager()` 获取管理实例
    - 通过 `beginTransaction()` 创建事务, 类型为 `FragmentTransaction`
    - 通过 `commit()` 提交事务
    - 通过 `popBackStack()` 弹出回退栈
    - 通过 `addToBackStack()` 添加到回退栈
    - 通过 `add`, `replace`, `remove`, `hide`, `show` 等方法操作 Fragment
    - 通过 `findFragmentById()` 和 `findFragmentByTag()` 查找 Fragment
    - 通过 `getFragments()` 获取当前所有 Fragment
    - 通过 `setReorderingAllowed()` 设置是否允许事务操作的重新排序
    - 通过 `setCustomAnimations` 设置自定义动画, 应用于调用位置后续的所有 `Fragment` 操作

        - `setCustomAnimations(enter: Int, exit: Int, popEnter: Int, popExit: Int)`

- Fragment.SavedState
- FragmentActivity
- FragmentController
- FragmentFactory: 用于创建 Fragment 实例的工厂, 可以通过自定义工厂来控制 Fragment 的实例创建过程. 默认情况下, Fragment 会通过反射机制创建实例, 通过 `FragmentFactory` 可以自定义创建逻辑.
- FragmentHostCallback
- FragmentKt
- FragmentManager.FragmentLifecycleCallbacks
- FragmentManagerKt
- FragmentManagerNonConfig
- FragmentPagerAdapter
- FragmentStatePagerAdapter
- FragmentTabHost
- FragmentTransaction
- FragmentTransactionKt
- FragmentViewModelLazyKt
- ViewKt

```kotlin
class MainActivity : AppCompatActivity() {
    // 创建 Fragment 实例
    val fragment = MyFragment()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        if (savedInstanceState == null) {

            supportFragmentManager.commit {
                setReorderingAllowed(true)
                add<MyFragment>(R.id.fragment_container_view)
            }
        }
    }
}
```

### androidx 导航组件(Navigation)

特点:

- 固定起始目的地
- 通过堆栈管理目的地
- 向上和后退按钮功能一致
- 深度链接支持(深度链接时, 现有返回堆栈都将被删除, 基于导航图重建新的返回堆栈)

组成:

- Host: `NavHostFragment` 和 `NavHost`, 用来存储和展示所有导航目的地对象的 `Fragment` 容器组件, 使用时需要手动指定导航图

    - `navGraph` 属性绑定导航图
    - `defaultNavHost` 属性设置为 true, 以便使得此导航组件首先处理系统返回键事件.

- Graph: `NavGraph`, 定义导航目的地连接关系的数据结构, 构成一个导航图

    - 目的地类型: `fragment`, `activity`, `dialog`.

        - `fragment`, 目的对象充满整个 Host 区域
        - `activity`, 退出导航图所在的 `Activity`, 启动一个新的 `Activity`
        - `dialog`, 展示在之前的内容上方

- Controller: `NavController`, 管理目的地之间导航, 处理深层链接, 处理返回堆栈等的协调员

    - 保存导航图并公开允许您的应用程序在图中的目的地之间移动的方法
    - 使用导航组件时，您可以使用 NavController 类创建导航控制器。 NavController 是中央导航 API。它跟踪用户访问过的目的地，并允许用户在目的地之间移动。

- Destination: `NavDestination`, 导航图中的节点, 通常在构建导航图时创建
- Route: 任何可序列化的数据类型, 通过 Route 进行导航到达目的地

目的地类型有三种: `Hosted` , `Dialog` , `Activity`

- `Hosted` 会使得目的内容占满整个导航内容区域
- `Dialog` 会使得目的内容展示在之前的内容上方
- `Activity` 会退出导航图所在的 Activity, 启动一个与导航组件分开管理的新 Android 活动

### androidx 可重用视图(RecycleView)

> [!cite]
> [RecyclerView源码分析(二)—缓存机制](https://juejin.cn/post/6844904104641167368)
> [【进阶】RecyclerView源码解析(二)](https://www.jianshu.com/p/e44961f8add5)

`RecycleView` 是一个高度可定制的视图组件, 用于显示大量数据, 支持多种布局, 支持动画, 支持分页加载, 支持数据变化通知, 支持点击事件, 支持拖拽和滑动删除等功能.

`RecycleView` 可以动态的显示大量数据, 通过 `Adapter` 适配器将数据绑定到 `ViewHolder` 视图持有者上, `LayoutManager` 布局管理器控制视图绘制方式, `ItemDecoration` 控制视图左右额外间距, `ItemAnimator` 控制视图动画效果. 同时其内部的 `Recycler` 会通过四级缓存机制来重用视图, 以减少内存开销.

#### `RecycleView` 优化点

- 视图绑定优化
    - bindViewHolder() 方法运行在 UI 线程, 应避免耗时操作(如日期格式化).
    - 监听事件可以全局创建一个, 所有视图共用一个监听器, 放在 onCreateViewHolder() 中, 减少对象创建消耗.
- 数据更新优化
    - 使用 DiffUtil 进行局部刷新, 尽量避免 notifyDataSetChanged() 全局刷新带来的性能损耗.
    - 通过 setHasStableIds(true) + 重写 getItemId() 赋予 Item 唯一 ID, 使得焦点固定, 避免数据更新时闪烁.
- 布局优化
    - 减少嵌套层级, 降低 layout traversal 的复杂度
    - 高度固定的视图, 使用 setHasFixedSize(true) 来避免 requestLayout() 浪费资源.
- 预取与缓存优化
    - Prefetch 功能(API ≥ 21), 通过 setInitialPrefatchItemCount() 设置预取个数, 优化滑动性能.
    - 调整 RecyclerView 缓存大小: 默认 cacheView 大小为 2, 可适当增大, 用空间换取时间.
    - 当多个 RecyclerView 使用相同 Adapter 时, 可通过 setRecycledViewPool() 共用一个 RecycledViewPool, 减少 ViewHolder 创建的开销.

#### `ViewHolder`

视图持有者是一个用于存储实际视图的容器, 用于支持 `RecycleView` 中视图的重用机制, 内部包含了依附的 RecyclerView `mOwnerRecyclerView` 和目前绑定的适配器 `mBindingAdapter`, 视图相关数据(如引用 `itemView`, 类型 `itemViewType`, 位置`mPosition`, 唯一性 ID `mItemId`), 以及用于标记视图状态的标志位 `mFlags`. 同时提供了以下方法, 方便获取视图的信息:

- `getLayoutPosition()`: 获取视图在布局中的位置, 与屏幕展示位置一致. 可能由于适配器新数据没处理和展示完导致与适配器实际位置不一致.
- `getBindingAdapterPosition()`: 获取视图在所绑定的直接适配器中的内部相对位置. 可能由于 `notifyDataSetChanged()` 等方法导致位置失效.
- `getAbsoluteAdapterPosition()`: 获取视图在整个 `RecyclerView` 中顶层适配器中的绝对位置.

#### `Adapter`

适配器是数据源和视图之间的桥梁, 使用时需要继承 `RecyclerView.Adapter` 类, 同时实现一些必须或定制的方法:

- `onCreateViewHolder()`: 必须, 通过提供的视图类型(整型值)创建新的 `ViewHolder` 视图持有者, 视图类型来自于 `getItemViewType()` 方法, 可以控制展示不同的视图.
- `onBindViewHolder()`: 必须, 通过提供的位置, 将数据绑定到 `ViewHolder` 视图持有者上, 用于更新视图的展示内容.
- `getItemCount()`: 必须, 返回数据集的大小, 用于确定需要展示多少个视图.
- `getItemViewType()`: 可选, 返回视图类型(整型值), 用于创建不同的视图.
- `onViewAttachedToWindow()`: 可选, 当视图被添加到窗口时调用, 可以重新启动动画或之前停止的动作等.
- `onViewRecycled()`: 可选, 当视图被回收时调用, 可以清除旧图片资源, 监听器等, 优化资源占用和内存泄漏.
- `registerAdapterDataObserver()`: 可选, 注册数据变化监听器, 比如空数据时显示空视图, 数据加载失败时显示错误视图等.
- `onAttachedToRecyclerView()`: 可选, 当适配器附加到 `RecyclerView` 时调用, 可以为当前适配器设置特定的 `RecyclerView` 功能, 如更换滑动对齐方式等.

此外, 适配器还提供了一些可以外部调用的方法, 用于通知数据变化或设置状态:

- `notifyDataSetChanged()`: 通知数据集发生变化, 重新绑定所有数据.
- `notifyItemRangeChanged()`: 通过提供的数据起始位置, 数据数量, 通知此范围内的数据发生变化, 重新绑定数据. 此外可以通过 `payloads` 参数, 通知部分数据发生变化, 进行更精细化的数据更新.
- `notifyItemRangeInserted()`: 通过提供的数据起始位置, 数据数量, 通知此范围内的数据为新插入的数据, 实现数据插入效果.
- `notifyItemRangeRemoved()`: 通过提供的数据起始位置, 数据数量, 通知此范围内的数据被移除, 实现数据删除效果.
- `setStateRestorationPolicy()`: 设置状态恢复策略, 用于控制视图状态的恢复, 默认为 `ALLOW`, 可以设置为 `PREVENT` 阻止状态恢复, 或者 `PREVENT_WHEN_EMPTY` 当数据为空时阻止状态恢复, 有数据后再恢复状态.

#### `LayoutManager`

布局管理器是用于控制 `RecyclerView` 中视图的布局方式, 常见的布局方式有:

- `LinearLayoutManager`: 线性布局管理器, 支持垂直和水平两种布局方式. 一般用于可滑动查看的列表数据展示.
- `GridLayoutManager`: 网格布局管理器, 支持网格布局方式, 可以设置列数. 一般用于网格数据展示.
- `StaggeredGridLayoutManager`: 瀑布流布局管理器, 支持瀑布流布局方式, 可以设置列数和方向. 一般用于大小不一, 或高度和宽度不均的数据展示.

布局路径:

- 测量: `RecyclerView.OnMeasure` -> `RecyclerView.LayoutManager` -> `LayoutManager.onMeasure` -> `RecyclerView.setMeasuredDimension`
- 布局: `RecyclerView.OnLayout` -> `RecyclerView.dispatchLayoutStep1` -> `RecyclerView.dispatchLayoutStep2` -> `LayoutManager.onLayoutChildren` -> `RecyclerView.dispatchLayoutStep3`
    - `dispatchLayoutStep1`: 对应 `STEP_START` 布局状态
        - 收集动画数据: 记录条目在布局前的状态（位置、属性）, 为比较新旧状态生成动画提供依据;
        - 处理预测性布局: 预测条目在最终布局中的位置, 确保动画（如移动、删除）平滑过渡;
        - 协调适配器变更: 解析数据变化, 确定需要执行的动画类型, 并初始化相关上下文.
    - `dispatchLayoutStep2`: 对应 `STEP_LAYOUT` 布局状态
        - 数据同步与实际布局: 应用所有数据变更, 完成子视图的最终布局;
        - 状态恢复: 确保配置变更(如横竖屏切换)后恢复滚动位置等状态;
        - 动画准备: 为 dispatchLayoutStep3() 的动画阶段提供正确的布局信息(如最终位置).
    - `dispatchLayoutStep3`: 对应 `STEP_ANIMATIONS` 布局状态
        - 动画执行: 根据新旧数据和布局信息差异, 触发条目增删改动画(如移动、渐变、交叉动画);
        - 资源回收: 清理不可见或废弃的视图, 优化内存使用;
        - 状态重置: 重置 RecyclerView 恢复到稳定状态, 为下次布局做准备;
        - 回调与通知: 完成布局后的事件回调(如滚动、焦点恢复).
- 绘制: `RecyclerView.draw` -> `View.draw` -> `RecyclerView.onDraw` -> `ItemDecoration.onDraw` -> `View.dispatchDraw`(子视图绘制)

自定义布局管理器时需要继承 `RecyclerView.LayoutManager` 类, 同时实现一些必须或定制的方法(目前只是一部分, 后续遇到需要自定义布局时再完善):

- `onLayoutChildren()`: 必须, 用于布局子视图, 通过提供的 `RecyclerView.Recycler` 回收池和 `RecyclerView.State` 状态, 布局子视图, 用于初始化和更新视图.
- `onMeasure()`: 
- `isAutoMeasureEnabled()`: 可选, 返回是否启用自动测量, 默认为 false.
- `supportsPredictiveItemAnimations()`: 可选, 返回是否支持预测项动画, 默认为 false.
- `collectAdjacentPrefetchPositions()`: 可选, 收集相邻预取位置, 用于提前加载视图, 只在启用预取时调用, 默认为空实现.
- `collectInitialPrefetchPositions()`: 可选, 收集初始预取位置, 用于提前加载视图, 只在启用预取时调用, 默认为空实现.
- `onAttachedToWindow()`: 可选, 当布局管理器附加到 `RecyclerView` 时调用, 可以为当前布局管理器设置特定的 `RecyclerView` 功能, 如更换滑动对齐方式等.
- `onDetachedFromWindow()`: 可选, 当布局管理器从 `RecyclerView` 分离时调用, 可以清除旧图片资源, 监听器等, 优化资源占用和内存泄漏.

此外, 布局管理器还提供了一些可以外部调用的方法, 用于控制视图的布局方式:

- `setItemPrefetchEnabled()`: 设置是否启用预取, 用于提前加载视图, 默认为 true.

#### `ItemDecoration`

用于在 `RecyclerView` 中为子视图添加边距或装饰.

- `getItemOffsets()`: 用于为子视图添加边距, 通过提供的 `Rect` 对象, 为子视图设置上下左右的边距. 注意 子视图并不知道自己的边距, 即其并不在子视图 padding 计算中.
- `onDraw()`: 用于在子视图上绘制装饰, 通过提供的 `Canvas` 画布对象, 在子视图上绘制装饰.
- `onDrawOver()`: 用于在子视图上绘制装饰, 通过提供的 `Canvas` 画布对象, 在子视图上绘制装饰, 与 `onDraw()` 方法不同的是, `onDrawOver()` 方法绘制的装饰会覆盖在子视图上, 不会影响子视图的点击事件.

#### `ItemAnimator`

`RecyclerView.ItemAnimator` 用于在 `RecyclerView` 中展示视图不同状态变更时的动画效果, 通过 `animateAppearance()`, `animateChange()`, `animatePersistence()`, `animateDisappearance()` 四个方法控制, 通过 `runPendingAnimations()` 方法来执行动画效果. 每个方法都会提供 `RecyclerView.ViewHolder` 视图持有者和 `ItemHolderInfo` 信息, 用于为视图设置动画效果. `SimpleItemAnimator` 是 `ItemAnimator` 的再封装, 提供了更移动的 API.

- `animateAppearance()`: 视图出现在屏幕时的动画效果.
- `animateDisappearance()`: 视图从屏幕消失的动画效果.
- `animatePersistence()`: 视图布局改变(数据没改变)时的动画效果.
- `animateChange()`: 视图数据改变时的动画效果.
- `runPendingAnimations()`: 执行所有等待的动画效果.

#### `Recycler`

回收池用于管理 `RecyclerView` 缓存和回收的 `ViewHolder`, 以支持其视图重用机制.

存(插入或删除):  `mAttachedScrap`
存(滑动): `mChangedScrap` -> `mCachedViews`

- `mAttachedScrap`: 一级缓存, 用于存储因为布局改变暂时回收的视图持有者.
- `mChangedScrap`: 一级缓存, 用于存储因为数据改变暂时回收的视图持有者.
- `mCachedViews`: 二级缓存, 用于存储完全脱离屏幕布局, 且可以直接重用的视图持有者.
- `mViewCacheExtension`: 三级缓存, 用户自定义的扩展缓存, 直接存储对应位置和类型的视图 `View`. 默认无.
- `mRecyclerPool`: 四级缓存, 可自定义的, 能支持用于多个 `RecyclerView` 的全局化缓存池, 存储和管理 `ScrapData` 数据结构. 默认不共享, 单 `RecyclerView` 使用.

#### 基本使用

```kotlin
val recyclerView: RecyclerView = findViewById(R.id.recycler_view)
val dataset = arrayOf("January", "February", "March")
val adapter = CustomAdapter(dataset)
val itemDecoration = DividerItemDecoration(this, DividerItemDecoration.VERTICAL)
recyclerView.adapter = adapter
recyclerView.layoutManager = LinearLayoutManager(this)
recyclerView.addItemDecoration(itemDecoration)

data class DataClass(
    val text: String,
    val viewType: Int
    )

class CustomAdapter(private val dataset: Array<DataClass>) : RecyclerView.Adapter<CustomAdapter.ViewHolder>() {
    class ViewHolder(val textView: TextView) : RecyclerView.ViewHolder(textView)

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val textView = TextView(parent.context)

        return when (viewType) {
            0 -> ViewHolder(textView)
            1 -> ViewHolder(textView)
            2 -> ViewHolder(textView)
            else -> ViewHolder(textView)
        }
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        holder.textView.text = dataset[position].text
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int, payloads: MutableList<Any>
    ) {
        if (payloads.isEmpty()) {
            super.onBindViewHolder(holder, position, payloads)
        } else {
            val item = payloads[0] as DataClass
            holder.textView.text = item.text
        }
    }

    override fun getItemViewType(position: Int): Int {
        return dataset[position].viewType
    }

    override fun getItemCount() = dataset.size
}

```

#### 扩展 DiffUtil

`DiffUtil` 是一个用于计算两个数据集之间差异的工具类, 通过 `DiffUtil.Callback` 回调类, 用于提供两个数据集的比较, 以及如何更新数据集的方法. `DiffUtil` 会通过 `calculateDiff()` 方法计算两个数据集之间的差异, 并返回一个 `DiffUtil.DiffResult` 对象, 用于通过 `dispatchUpdatesTo` 自动调用 `Adapter` 的更新方法.

- `getOldListSize()`: 返回旧数据集的大小.
- `getNewListSize()`: 返回新数据集的大小.
- `areItemsTheSame()`: 返回两个数据集中的数据是否相同.
- `areContentsTheSame()`: 返回两个数据集中的数据内容是否相同.
- `getChangePayload()`: 返回两个数据集中的数据内容差异.
- `dispatchUpdatesTo()`: 通过提供的 `Adapter` 对象, 自动调用 `Adapter` 的更新方法.

```kotlin
data class DataClass(
    val text: String,
    val viewType: Int
    )

class CustomAdapter(private var dataset: List<DataClass>) : RecyclerView.Adapter<CustomAdapter.ViewHolder>() {
    class ViewHolder(val textView: TextView) : RecyclerView.ViewHolder(textView)

    fun updateData(newData: List<DataClass>) {
        val diffResult = DiffUtil.calculateDiff(object : DiffUtil.Callback() {
            override fun getOldListSize() = dataset.size
            override fun getNewListSize() = newData.size
            override fun areItemsTheSame(oldItemPosition: Int, newItemPosition: Int) =
                dataset[oldItemPosition] == newData[newItemPosition]
            override fun areContentsTheSame(oldItemPosition: Int, newItemPosition: Int) =
                dataset[oldItemPosition] == newData[newItemPosition]
        })
        dataset = newData
        diffResult.dispatchUpdatesTo(this)
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val textView = TextView(parent.context)
        return ViewHolder(textView)
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        holder.textView.text = dataset[position].text
    }

    override fun getItemCount() = dataset.size
}
```

### androidx 分页组件(paging)

`Paging` 是基于 `RecyclerView` 和 `Flow` 的专注于分页数据加载的库, 与 `RecyclerView` 解耦, 同时提供了标准化的分页生命周期管理, 开发者只需关注数据加载规则.

- 引入 `PagingSource<Key : Any, Value : Any>` 将数据源抽象为响应式数据流.
    - 泛型参数 `<Key, Value>`: `Key` 用于唯一页码标识, `Value` 用于表示数据项类型.
    - `load(params: LoadParams<Key>)`: 指定如何从数据源中加载特定页的数据, 并返回一个分页数据结果 `LoadResult`.
    - `LoadParams<Key>`: 封装加载请求参数的密封类, 包含请求加载的项目数量 `loadSize`, 是否启用了占位符 `placeholdersEnabled`, 请求加载的页码标识 `key`. 具体类型 `Refresh`: 刷新, `Prepend`: 前一页, `Append`: 后一页.
    - `LoadResult<Key, Value>`: 封装加载结果的密封类. 分具体类型 `Error(throwable: Throwable)`: 加载失败, 携带异常信息; `Invalid`: 无效加载, 终止请求数据源, 并自动触发 `invalidate()`; `Page(data: List<Value>, prevKey: Key?, nextKey: Key?), itemsBefore: Int, itemsAfter: Int`: 加载成功, 携带数据列表, 前一页码, 后一页码, 前面的数据数量, 后面的数据数量.

- 引入 `RemoteMediator<Key : Any, Value : Any>` 实现本地缓存与远程数据源之间的协同工作.
    - `load(loadType: LoadType, state: PagingState<Key, Value>)`: 核心方法，响应分页边界条件/刷新事件，返回加载结果 `MediatorResult`
    - `LoadType`: 加载类型, `REFRESH`: 刷新, `PREPEND`: 前一页, `APPEND`: 后一页
    - `PagingState<Key, Value>`: 分页系统的数据状态快照, 内部包含已加载的分页数据列表 `pages`, 最近访问的列表位置 `anchorPosition`, 初始化数据流时的配置 `config`, 首项前的占位符数量 `leadingPlaceholderCount`.
    - `MediatorResult`: 封装加载结果的密封类. 分具体类型 `Error(throwable: Throwable)`: 加载失败, 携带异常信息; `Success(endOfPaginationReached: Boolean)`: 加载成功, 携带是否到达分页末尾; 

, 通过 `load()` 方法从远程数据源加载数据, 并返回加载状态 `MediatorResult`, 数据按需缓存到本地数据库.

- 引入 `Pager` 分页器, 用于结合 `PagingSource`, `RemoteMediator` 和相关配置, 并创建 `PagingData` 数据冷流 `Flow`.
    - 通过 `PagingConfig` 配置分页加载数据的参数, 如初始加载数量 `initialLoadSize`, 后续每页加载数量 `pageSize`, 预加载距离 `prefetchDistance`, 
    
    注意当 `initialLoadSize` 和 `pageSize` 相等时才能固定初始加载数量.
    - 通过 `
    引入了 `PagingData` 用于表示分页数据, 通过 `Flow` 传递, 包含分页数据和加载状态.
    - 注意冷流获取的 `PagingData` 实例不能重复使用(消费), 不然可能会出错. 获取新实例可以通过 `PagingDataAdapter.refresh()` 方法. 重用旧实例的需求, 可以在使用 `Flow` 时通过 `cachedIn()` 方法进行缓存和多播, 确保每个观察者拿到一个新的、独立的 `PagingData` 实例.

- 统一的用于 `RecyclerView` 的适配器基类 `PagingDataAdapter`, 实现数据绑定和自动 Diff 计算, 同时支持设置头部和尾部适配器, 以及加载状态适配器.
    - 硬性要求传递 `DiffUtil.ItemCallback` 对象, 用于计算数据差异.
    - `submitData` 方法用于提交新的 `PagingData` 数据, 以此自动计算数据差异, 更新视图.
    - `retry` 方法用于重试加载失败 `LoadState.Error` 的数据.\
    - `refresh` 方法用于重新加载数据(如下拉刷新).
    - `getItem` 方法用于获取指定位置的数据, 数据类型对应创建 `PagingDataAdapter` 时的泛型类型.
    - `loadStateFlow` 属性用于监听分页数据的加载状态 `LoadState` 的 `StateFlow` 热数据流.
    - `onPagesUpdatedFlow` 属性用于监听分页页面结构变化的 `SharedFlow` 热数据流.
    - `withLoadStateHeaderAndFooter` 基于 `ConcatAdapter`, `LoadState` 和 `LoadStateAdapter` 实现头部和尾部适配器的设置. 可自动处理加载状态的显示和隐藏.
- 引入加载状态 `LoadState: 加载中, 没加载, 失败`, 用于实现 UI 状态与数据的同步更新.

#### 使用示例

```kotlin
// 相关依赖
// implementation "androidx.paging:paging-runtime-ktx:3.1.1"
// implementation "androidx.paging:paging-compose:3.1.1" // 如果使用 Compose
// implementation "org.jetbrains.kotlinx:kotlinx-coroutines-android:1.6.4"
// implementation "androidx.room:room-ktx:2.5.2"
// kapt "androidx.room:room-compiler:2.5.2"
// implementation "com.squareup.retrofit2:retrofit:2.9.0"

// 数据模型 & API 定义
data class ApiResponse(
    val items: List<Item>,
    val nextPage: Int?
)

@Entity(tableName = "items")
data class Item(
    @PrimaryKey val id: String,
    val name: String,
    val page: Int // 记录所属页码用于分页
)

interface ApiService {
    @GET("items")
    suspend fun getItems(
        @Query("page") page: Int,
        @Query("size") size: Int
    ): ApiResponse
}

// 数据库 & DAO 定义
@Database(entities = [Item::class], version = 1)
abstract class AppDatabase : RoomDatabase() {
    abstract fun itemDao(): ItemDao
}

@Dao
interface ItemDao {
    @Query("SELECT * FROM items ORDER BY page ASC")
    fun getPagingSource(): PagingSource<Int, Item>

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertAll(items: List<Item>)

    @Query("DELETE FROM items")
    suspend fun clearAll()
}

// RemoteMediator (协调本地/远程)
class ItemRemoteMediator(
    private val api: ApiService,
    private val db: AppDatabase
) : RemoteMediator<Int, Item>() {

    override suspend fun load(
        loadType: LoadType,
        state: PagingState<Int, Item>
    ): MediatorResult {
        try {
            // 根据加载类型计算下一页页码
            val page = when (loadType) {
                LoadType.REFRESH -> 1
                LoadType.PREPEND -> return MediatorResult.Success(endOfPaginationReached = true)
                LoadType.APPEND -> {
                    val lastItem = state.lastItemOrNull()
                    lastItem?.page?.plus(1) ?: 1
                }
            }

            // 从网络加载数据
            val response = api.getItems(page, state.config.pageSize)
            
            // 写入数据库
            db.withTransaction {
                if (loadType == LoadType.REFRESH) {
                    db.itemDao().clearAll()
                }
                db.itemDao().insertAll(response.items.map { it.copy(page = page) })
            }

            return MediatorResult.Success(
                endOfPaginationReached = response.nextPage == null
            )
        } catch (e: Exception) {
            return MediatorResult.Error(e)
        }
    }
}

// 实现 Adapter
class ItemAdapter : PagingDataAdapter<Item, ItemViewHolder>(ITEM_COMPARATOR) {

    companion object {
        private val ITEM_COMPARATOR = object : DiffUtil.ItemCallback<Item>() {
            override fun areItemsTheSame(oldItem: Item, newItem: Item): Boolean =
                oldItem.id == newItem.id

            override fun areContentsTheSame(oldItem: Item, newItem: Item): Boolean =
                oldItem == newItem
        }
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ItemViewHolder {
        val view = LayoutInflater.from(parent.context).inflate(R.layout.item_layout, parent, false)
        return ItemViewHolder(view)
    }

    override fun onBindViewHolder(holder: ItemViewHolder, position: Int) {
        val item = getItem(position)
        holder.bind(item)
    }
}

// 头部适配器（静态内容）
class HeaderAdapter : RecyclerView.Adapter<HeaderAdapter.HeaderViewHolder>() {

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): HeaderViewHolder {
        val view = LayoutInflater.from(parent.context)
            .inflate(R.layout.item_header, parent, false)
        return HeaderViewHolder(view)
    }

    override fun onBindViewHolder(holder: HeaderViewHolder, position: Int) {
        holder.bind("List Header")
    }

    override fun getItemCount(): Int = 1 // 只显示一个头部项

    class HeaderViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        fun bind(text: String) {
            itemView.findViewById<TextView>(R.id.headerText).text = text
        }
    }
}

// 页脚适配器（动态加载状态）
class FooterAdapter(private val retry: () -> Unit) : RecyclerView.Adapter<FooterAdapter.FooterViewHolder>() {

    private var loadState: LoadState = LoadState.NotLoading(endOfPaginationReached = false)

    fun setLoadState(newState: LoadState) {
        val previousState = loadState
        loadState = newState
        when {
            // 使用 DiffUtil 简化状态更新
            previousState is LoadState.Loading && newState is LoadState.NotLoading -> 
                notifyItemRemoved(0)
            newState is LoadState.Loading -> 
                notifyItemInserted(0)
            previousState.endOfPaginationReached != newState.endOfPaginationReached -> 
                notifyItemChanged(0)
        }
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): FooterViewHolder {
        val view = LayoutInflater.from(parent.context)
            .inflate(R.layout.item_footer, parent, false)
        return FooterViewHolder(view, retry)
    }

    override fun onBindViewHolder(holder: FooterViewHolder, position: Int) {
        holder.bind(loadState)
    }

    override fun getItemCount(): Int = if (loadState is LoadState.NotLoading && loadState.endOfPaginationReached) 0 else 1

    class FooterViewHolder(view: View, retry: () -> Unit) : RecyclerView.ViewHolder(view) {
        private val progressBar = view.findViewById<ProgressBar>(R.id.progressBar)
        private val errorText = view.findViewById<TextView>(R.id.errorText)
        private val retryButton = view.findViewById<Button>(R.id.retryButton)

        init {
            retryButton.setOnClickListener { retry() }
        }

        fun bind(loadState: LoadState) {
            when (loadState) {
                is LoadState.Loading -> {
                    progressBar.visibility = View.VISIBLE
                    errorText.visibility = View.GONE
                    retryButton.visibility = View.GONE
                }
                is LoadState.Error -> {
                    progressBar.visibility = View.GONE
                    errorText.text = loadState.error.localizedMessage
                    errorText.visibility = View.VISIBLE
                    retryButton.visibility = View.VISIBLE
                }
                is LoadState.NotLoading -> {
                    progressBar.visibility = View.GONE
                    errorText.visibility = View.GONE
                    retryButton.visibility = View.GONE
                }
            }
        }
    }
}

// 在 ViewModel 中配置 Pager
class ItemViewModel(
    private val api: ApiService,
    private val db: AppDatabase
) : ViewModel() {

    val pagingDataFlow = Pager(
        config = PagingConfig(
            pageSize = 20,
            prefetchDistance = 5,
            enablePlaceholders = false
        ),
        remoteMediator = ItemRemoteMediator(api, db),
        pagingSourceFactory = { db.itemDao().getPagingSource() }
    ).flow.cachedIn(viewModelScope)
}

// 在 Activity/Fragment 中使用
class MainActivity : AppCompatActivity() {
    private lateinit var viewModel: ItemViewModel
    private val headerAdapter = HeaderAdapter()
    private val itemAdapter = ItemAdapter()
    private val footerAdapter = FooterAdapter { itemAdapter.retry() } // 重试时触发分页重载

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        // 使用 ConcatAdapter 组合三个 Adapter
        val concatAdapter = ConcatAdapter(
            headerAdapter,
            itemAdapter.withLoadStateHeaderAndFooter(
                header = FooterAdapter { itemAdapter.retry() },
                footer = footerAdapter
            )
        )

        val recyclerView = findViewById<RecyclerView>(R.id.recycler_view)
        recyclerView.adapter = concatAdapter

        // 监听分页数据（保持原有逻辑）
        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.pagingDataFlow.collectLatest { pagingData ->
                    itemAdapter.submitData(pagingData)
                }
            }
        }

        // 监听加载状态并更新 Footer
        itemAdapter.addLoadStateListener { loadStates ->
            footerAdapter.setLoadState(loadStates.append) // 监听追加状态

            // 原有全局状态处理保持不变
            when (loadStates.refresh) {
                is LoadState.Loading -> showLoading()
                is LoadState.Error -> showError((loadStates.refresh as LoadState.Error).error)
                is LoadState.NotLoading -> hideLoading()
            }
        }
    }
}
```

### 自定义视图

> [!cite]
>
> [Android 事件分发机制完全解析](https://blog.csdn.net/guolin_blog/article/details/9097463)

通常的自定义 View 流程:

- 继承自 `View` 或者 `ViewGroup` 类

```kotlin
/**
 * 自定义 View
 * params context 应用上下文
 * params attrs 属性集合, 用于在 xml 中使用自定义组件时, 为组件传递自定义属性(不使用时, 可以传递 null)
 * params defStyleAttr 默认样式, 用于在 xml 中使用自定义组件时, 为组件传递默认样式. 可以通过在 xml 中设置 style 属性来覆盖默认样式.
 */
class MyView(context: Context, attrs: AttributeSet, defStyleAttr: Int) : View(context, attrs, defStyleAttr) {
    // 1. 定义属性
    private var mText: String = ""

    // 2. 初始化属性
    init {
        val typedArray = context.obtainStyledAttributes(attrs, R.styleable.MyView, defStyleAttr, 0)
        mText = typedArray.getString(R.styleable.MyView_text) ?: ""
        typedArray.recycle()
    }
}

// 使用
<com.example.MyView
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    app:text="Hello World!" />

val myView = MyView(context).apply {
    text = "Hello World!"
    layoutParams = ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT)
}
```

- 重写 `override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int)` 方法, 在其中测量自定义 View 及其子 View 的大小, 并通过 `setMeasuredDimension(width, height)` 方法设置自定义 View 的最终大小.
- 重写 `override fun onLayout(changed: Boolean, left: Int, top: Int, right: Int, bottom: Int)` 方法, 由 ViewGroup 调用, 在其中布局确定自定义 View 及其子 View 在父布局中的位置.
- 重写 `override fun onDraw(canvas: Canvas?)` 方法, 在其中绘制自定义 View 的内容, 一般通过 `Canvas` 对象来绘制图形, 文字, 图片等.
- 重写 `override fun onTouchEvent(event: MotionEvent?): Boolean` 方法, 在其中处理自定义 View 的触摸事件

#### `onMeasure` 方法

> [!cite]
>
> [onMeasure 详解](https://blog.csdn.net/dmk877/article/details/49558367)

每个视图都有一个 `onMeasure` 方法, 用于测量视图的大小, 并通过 `setMeasuredDimension(width, height)` 方法设置视图的最终大小. 视图的大小由两部分组成: 宽度和高度, 其最终大小会受到父视图的测量要求 `MeasureSpec`(大小和模式), 视图自身的 `LayoutParams` 以及视图内容等因素的影响.

- `MeasureSpec.EXACTLY` 精确模式, 视图大小是确定的, 由 `MeasureSpec.getSize()` 获取. 对应布局属性 `match_parent` 或者 `具体数值dp`
- `MeasureSpec.AT_MOST` 最大模式, 视图大小不能超过 `MeasureSpec.getSize()`, 通常是父视图的大小. 对应布局属性 `wrap_content`.
- `MeasureSpec.UNSPECIFIED` 未指定模式, 视图大小不受限制, 可以任意大小. 通常用于 `ScrollView` 中的子视图.

```java
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),
            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));
}

private void setMeasuredDimension(int measuredWidth, int measuredHeight) {
    mMeasuredWidth = measuredWidth;
    mMeasuredHeight = measuredHeight;
}
```

最根源的父视图是 `Activity` 绑定的 `Window` 视窗内的 `DecorView`. `Window` 视窗用于包含和管理应用的窗口内容有关的所有视图; `DecorView` 是一个继承自 `FrameLayout` 类型的根布局, 它的大小一般是手机屏幕的大小.

```java
public class Activity ... { ...
    mWindow = new PhoneWindow(this, window, activityConfigCallback);
    public void setContentView(@LayoutRes int layoutResID) {
        mWindow.setContentView(layoutResID);
        initWindowDecorActionBar();
    }
}

public class PhoneWindow ... { ...
    public void setContentView(int layoutResID) {
        installDecor();
    }

    private void installDecor() {
        if (mDecor == null) {
            mDecor = new DecorView(context, -1, this, getAttributes());;
        }
        if (mContentParent == null) {
            ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);
            mContentParent = generateLayout(mDecor);
        }
    }
}
```

此外 `PhoneWindow` 又有一个 `mContentParent: FrameLayout` 容器, 用于存放实际的应用内容区域的视图, 大小通常是 `DecorView` 的大小减去状态栏和导航栏的高度.

`DecorView extends FrameLayout -> ViewGroup -> View` 也是个视图, 同时它也就有自己的 `onMeasure` 方法来测量自己的大小. 但是 `DecorView` 并没有父视图, 那么它的大小是怎么确定的呢?

首先每一个 `View` 都会通过 `measure(widthMeasureSpec, heightMeasureSpec)` 方法来测量自己的大小, 因此只需要搞清楚这里的 `widthMeasureSpec` 和 `heightMeasureSpec` 的来源即可. 这里需要去追溯到 `ViewRootImpl`.

在 `PhoneWindow` 创建的同时, 会创建一个 `ViewRootImpl` 对象自动与 `DecorView` 绑定, 用于管理当前窗口内部视图树内所有视图的绘制和事件分发. 而 `DecorView` 就可以通过 `getViewRootImpl()` 通过得到的 `ViewRootImpl` 对象来触发 `ViewRootImpl` 的 `performTraversals()` 方法来重新测量自己的大小.

```java
public class PhoneWindow ... { ...
    private void openPanel(final PanelFeatureState st, KeyEvent event) {
        ...
        final WindowManager wm = getWindowManager();
        wm.addView(st.decorView, lp);
        ...
    }
}

// WindowManagerImpl
public final class WindowManagerGlobal { ...
    public void addView(View view, ViewGroup.LayoutParams params, ...) {
        ViewRootImpl root;
        root = new ViewRootImpl(view.getContext(), display);
        mViews.add(view);
        mRoots.add(root);
        ...
    }
}
```

`ViewRootImpl` 会在自己的 `performTraversals()` 方法中计算 `DecorView` 需要的根测量规格 `childWidthMeasureSpec` 或 `childHeightMeasureSpec`.

简单来说这两个测量规格的计算取决于窗口的类型, 如果是特殊窗口类型, 直接使用设备的宽高, 如果是 `WRAP_CONTENT` 类型, 则扣除系统栏的高度后, 当前窗口在屏幕上显示的实际矩形区域, 其他情况直接使用 `WindowManager` 获取的屏幕尺寸. 具体的计算还有更多细节.

然后 `ViewRootImpl` 会利用计算好的根测量规格调用 `performMeasure()` 方法来执行 `DecorView` 的 `measure(...)` 方法, 从而使得 `DecorView` 根据根测量规格来测量自己的大小.

```java
public final class ViewRootImpl ... {
    private void performTraversals() {
        ...
        int desiredWindowWidth;
        int desiredWindowHeight;
        Rect frame = mWinFrame;
        if (mFirst) {
            final Configuration config = mContext.getResources().getConfiguration();
            if (shouldUseDisplaySize(lp)) {
                Point size = new Point();
                mDisplay.getRealSize(size);
                desiredWindowWidth = size.x;
                desiredWindowHeight = size.y;
            } else if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT
                    || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
                desiredWindowWidth = dipToPx(config.screenWidthDp);
                desiredWindowHeight = dipToPx(config.screenHeightDp);
            } else {
                desiredWindowWidth = frame.width();
                desiredWindowHeight = frame.height();
            }
        } else {
            desiredWindowWidth = frame.width();
            desiredWindowHeight = frame.height();
        }

        // Ask host how big it wants to be
        windowSizeMayChange |= measureHierarchy(mView, layoutParams, contextResources,
                desiredWindowWidth, desiredWindowHeight);
    }

    private boolean measureHierarchy(host, lp, res, desiredWindowWidth, desiredWindowHeight) {
        ...
        final DisplayMetrics packageMetrics = res.getDisplayMetrics();
            childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);
            childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);
            performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);
        ...
    }

    private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) {
        mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);
    }
}
```

其中 `measure(...)` 方法中有一个默认的根据测量规格计算大小的实现, 即 `onMeasure()` 方法, 它会直接使用所提供的测量规格提供的大小. (因为一般传入的模式不会是 `MeasureSpec.UNSPECIFIED`)

#### `onLayout` 方法

每个视图都有一个 `onLayout` 方法, 用于布局当前视图相对于父视图的位置, 并通过 `setFrame(left, top, right, bottom)` 方法设置视图的最终位置. 视图的位置由四个坐标值组成: 左上角的 x 坐标和 y 坐标, 右下角的 x 坐标和 y 坐标, 其最终位置取决于设置的坐标, 分别对应以下四个属性:

- `mLeft——View.getLeft()`: 当前视图的左边界到父视图的左边界的距离
- `mTop——View.getTop()`: 当前视图的顶部到父视图顶部的距离
- `mRight——View.getRight()`: 当前视图的右边界到父视图的左边界的距离
- ``mBottom——View.getBottom(): 当前视图的底部到父视图的顶部的距离

```java
public void layout(int l, int t, int r, int b) {
    ...
    int oldL = mLeft;
    int oldT = mTop;
    int oldB = mBottom;
    int oldR = mRight;
    boolean changed = setFrame(l, t, r, b);
    if (changed) {
        onLayout(changed, l, t, r, b);
    }
}

protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
}

protected boolean setFrame(int left, int top, int right, int bottom) {
    boolean changed = false;

    if (mLeft != left || mRight != right || mTop != top || mBottom != bottom) {
        changed = true;

        int oldWidth = mRight - mLeft;
        int oldHeight = mBottom - mTop;
        int newWidth = right - left;
        int newHeight = bottom - top;
        boolean sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight);

        invalidate(sizeChanged);

        mLeft = left;
        mTop = top;
        mRight = right;
        mBottom = bottom;
        mRenderNode.setLeftTopRightBottom(mLeft, mTop, mRight, mBottom);
    }
    return changed;
}


```

最根源的父视图是 `Activity` 绑定的 `Window` 视窗内的 `DecorView`. 与 `onMeasure` 方法的介绍类似, `DecorView` 可以通过触发绑定的 `ViewRootImpl` 对象的 `performTraversals()` 方法来重新布局自己的子视图. 默认的根布局区域就是 `onMeasure` 方法中确定的测量大小所占区域.

```java
public final class ViewRootImpl ... {
    private void performTraversals() {
        windowSizeMayChange |= measureHierarchy(mView, layoutParams, contextResources,
                desiredWindowWidth, desiredWindowHeight);

        if (mWidth != frame.width() || mHeight != frame.height()) {
            mWidth = frame.width();
            mHeight = frame.height();
        }
        performLayout(lp, mWidth, mHeight);
    }

    private void performLayoutWindowManager.LayoutParams lp, int desiredWindowWidth,
            int desiredWindowHeight {
        mView.layout(0, 0, mView.getMeasuredWidth(), mView.getMeasuredHeight());

        // 这里如果布局失败, 会尝试使用 desiredWindowWidth 和 desiredWindowHeight 参数重新计算视图大小, 并重新布局
    }
}
```

#### `onDraw` 方法

#### `invalidate` 方法

#### `dispatchTouchEvent` 方法

![_](https://img2018.cnblogs.com/blog/653161/201903/653161-20190321113420853-1974821013.png)

> [!cite]
> [Android 事件分发机制解析](https://juejin.cn/post/7102248400019521544")

每当用户触摸屏幕时, 系统会首先将触摸事件封装成 `MotionEvent` 对象, 并通过当前 `Activity` 将事件传递给 `DecorView` 中的根视图 `ViewGroup` 对象, 由根视图对象将此事件传递给其子视图, 一直到最终的目标视图.

包括 `Activity`, `Window`, `ViewGroup`, `View` 在内的所有类型对象都有一个 `dispatchTouchEvent` 方法, 用于分发触摸事件. 以下介绍每种对象的 `dispatchTouchEvent` 方法的实现逻辑:

- `Activity.dispatchTouchEvent`

    - 会首先在 `ACTION_DOWN` 事件到来时, 调用 `onUserInteraction` 方法, 默认为空实现, 可以重写此方法来记录用户交互事件
    - 然后将事件传递给绑定的 `Window` 对象处理, 如果事件被消费, 则返回 true, 否则继续去调用 `Activity.onTouchEvent` 方法.

- `Window.dispatchTouchEvent`

    - 一般会将事件直接传递给绑定的 `DecorView: ViewGroup` 对象处理.

- `ViewGroup.dispatchTouchEvent`

    - 进行设置输入一致性验证, 辅助功能标志, 安全性检查等. (不重要)
    - 清除所有之前的触摸目标, 并调用重置触摸状态, 防止之前的触摸事件影响当前事件.
    - 首先进行事件拦截的判断和处理. 事件拦截, 会导致事件不再向子视图传递.

        - 拦截条件 1: 1. 是 `ACTION_DOWN` 事件, 或者已有子视图在处理触摸事件; 2. `FLAG_DISALLOW_INTERCEPT` 标志未被设置为 true; 拦截成功后会调用 `onInterceptTouchEvent` 方法. 后续不会再进行向子视图的触摸事件分发.
        - 拦截条件 2: 不是 `ACTION_DOWN` 事件, 且没有任何子视图在处理当前触摸事件. 也视为拦截成功. 后续不会再进行向子视图的触摸事件分发.

    - 然后判断事件是否被取消, 通过 `FLAG_CANCEL_FORCED` 标志或事件类型是否是 `ACTION_CANCEL` 来判断. 事件被取消会导致事件不再向子视图传递.
    - 判断是否需要进行多点触控事件的处理, 通过 `FLAG_SPLIT_MOTION_EVENTS` 标志和是否不是鼠标事件来判断.
    - 进行事件分发判断和处理

        - 当事件是 `ACTION_DOWN`(初始按下) 或 `ACTION_POINTER_DOWN`(多点触控新增的手指按下) 或 `ACTION_HOVER_MOVE`(按下后移动) 时

            - 先逆序查找所有可以接收事件的子视图 (确认视图能否接收事件) 并调用子视图的 `dispatchTouchEvent` 方法传递事件, 直到有子视图消费事件或者事件被取消. 如果事件被消费了, 将可接收子视图保存在链表结构头部, 为多点触控事件做准备.
            - 如果没有子视图消费事件, 但是事件是多点触控和触摸后移动事件, 则尝试将要处理的事件分发给第一次按下时保存的所有可以处理事件的子视图链表中的尾部视图.

        - 如果是其他事件, 则直接从头到尾遍历所有可以接收事件的子视图, 并调用子视图的 `dispatchTouchEvent` 方法传递事件, 直到有子视图消费事件或者事件被取消.

- `View.dispatchTouchEvent`

    - 进行设置输入一致性验证, 辅助功能标志, 安全性检查等. (不重要)
    - 如果视图启用了滚动条并且事件是相关的滚动操作, 会先尝试处理滚动条拖拽事件 `handleScrollBarDragging` 方法, 消费后继续向下.
    - 如果设置了触摸事件监听器, 会先调用监听器的 `onTouch` 方法处理事件, 消费后直接返回.
    - 调用视图自身的 `onTouchEvent` 方法处理事件, 消费后直接返回.
    - 未消费事件, 返回 false.

##### `onTouchEvent` 方法

##### `onInterceptTouchEvent` 方法

##### `handleScrollBarDragging` 方法

##### `requestDisallowInterceptTouchEvent` 方法

通过设置 `FLAG_DISALLOW_INTERCEPT` 标志来控制父视图是否拦截触摸事件.

##### `setMotionEventSplittingEnabled` 方法

通过设置 `FLAG_SPLIT_MOTION_EVENTS` 标志来控制是否分割多点触控事件.

#### `getMeasuredWidth` 和 `getWidth` 方法的区别

- `getMeasureWidth()` 方法在 `measure()` 过程结束后就可以获得到它的值.
- `getWidth()` 方法要在 `layout()`过程结束后才能获取到.

自定义控件的时候在 `onLayout` 方法中一般采用 `getMeasuredWidth` 来获得控件的宽度.  
在除了 `onLayout` 之外的方法中采用 `getWidth` 方法来获取控件的宽度.

```java
public class View ... {
    public final int getMeasuredWidth() {
        return mMeasuredWidth & MEASURED_SIZE_MASK;
    }

    public final int getWidth() {
        return mRight - mLeft;
    }
}
```

#### TextPaint

`TextPaint` 是 `Paint` 的子类, 用于绘制文本的画笔. `TextPaint` 除了继承了 `Paint` 的所有属性和方法外, 还有一些专门用于绘制文本的属性和方法.

- `TextPaint.setTextSize(float textSize)`: 设置文本大小
- `TextPaint.setTypeface(Typeface typeface)`: 设置字体样式
- `TextPaint.setUnderlineText(boolean underlineText)`: 设置是否显示下划线
- `TextPaint.setStrikeThruText(boolean strikeThruText)`: 设置是否显示删除线

文本的基本信息 `Paint.FontMetrics`:

- `baseline`: 基线, 文本绘制的基准线, 用于绘制文本的起始位置
- `ascent`: 文本中字符的最高点到基线的距离
- `descent`: 文本中字符的最低点到基线的距离
- `top`: 文本中字符可以达到的最高点到基线的距离
- `leading`:

文本居中的计算方法: `int baseline = viewHeight / 2 + (fontMetrics.descent - fontMetrics.ascent) / 2 - fontMetrics.descent;`

### 动画和过渡

> [!cite]
>
> [https://developer.android.com/guide/fragments/animate](https://developer.android.com/guide/fragments/animate) > [Frame Animation（逐帧动画）](https://developer.aliyun.com/article/567019)

#### Frame 动画(帧动画)

帧动画: 通过一系列的图片帧来实现动画效果, 适用于帧数较少的动画效果

- 动画文件定义位置: `res/drawable/`
- 动画定义类型: `AnimationDrawable`
- 在 `Activity` 的 `onCreate()` 方法期间无法调用 `AnimationDrawable` 上调用的 `start()` 方法. 可以从 `Activity` 中的 `onStart()` 方法或者 `onWindowFocusChanged()` 方法中调用 `start()` 方法, 以避免动画启动时界面未绘制完成的问题.
- 使用时以 `ImageView` 为载体, 通过 `ImageView.setBackgroundResource()` 方法设置动画资源, 并通过将背景转换为 `AnimationDrawable` 对象来启动动画

```kotlin
// rocket_thrust_anim.xml
<?xml version="1.0" encoding="utf-8"?>
<animation-list
    xmlns:android="http://schemas.android.com/apk/res/android"
    <-- 动画是否只播放一次 --/>
    android:oneshot="false"
    >
    <item android:drawable="@drawable/rocket_thrust1" android:duration="200" />
    <item android:drawable="@drawable/rocket_thrust2" android:duration="200" />
    <item android:drawable="@drawable/rocket_thrust3" android:duration="200" />
</animation-list>

<ImageView
    android:id="@+id/rocket_image"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:background="@drawable/rocket_thrust_anim" />

// 使用
val rocketImage = findViewById<ImageView>(R.id.rocket_image).apply {
    setBackgroundResource(R.drawable.rocket_thrust)
    rocketAnimation = background as AnimationDrawable
}

rocketImage.setOnClickListener({ rocketAnimation.start() })
```

#### 插值器和求值器

每一个动画都有一个插值器和一个求值器, 插值器控制动画的进度, 求值器控制动画的属性值.

插值器（Interpolator）决定了动画的进度如何随时间变化. 时间是线性的, 但是动画的进度不一定是线性的, 插值器就是用来控制动画进度的, 在固定的时间内, 可以让它先快后慢, 先慢后快 或者提前到达终点进行回弹等.

默认可用的插值器:

- `@android:anim/linear_interpolator` | `LinearInterpolator`: 线性匀速
- `@android:anim/decelerate_interpolator` | `DecelerateInterpolator`: 减速
- `@android:anim/accelerate_interpolator` | `AccelerateInterpolator`: 加速
- `@android:anim/overshoot_interpolator` | `OvershootInterpolator`: 快速超出终点一小步后回弹到终点
- `@android:anim/anticipate_interpolator` | `AnticipateInterpolator`: 先回退一小步再加速
- `@android:anim/accelerate_decelerate_interpolator` | `AccelerateDecelerateInterpolator`: 先加速后减速
- `@android:anim/anticipate_overshoot_interpolator` | `AnticipateOvershootInterpolator`: 先回退一小步再加速, 最后超出重点一小步后回弹到终点
- `@android:anim/bounce_interpolator` | `BounceInterpolator`: 加速到终点后持续弹跳直至停止
- `@android:anim/cycle_interpolator` | `CycleInterpolator`: 周期运动
- `pathInterpolator` | `PathInterpolator`: 自定义路径插值器, 支持为二次贝塞尔曲线和三次贝塞尔曲线创建插值器

```xml
// 默认插值器的参数设置
<linearInterpolator xmlns:android="http://schemas.android.com/apk/res/android" /> // 无法自定义参数
<decelerate_interpolator xmlns:android="http://schemas.android.com/apk/res/android" android:factor="2" /> // 可设置减速因子
<accelerate_interpolator xmlns:android="http://schemas.android.com/apk/res/android" android:factor="2" /> // 可设置加速因子
<overshootInterpolator xmlns:android="http://schemas.android.com/apk/res/android" android:tension="2" /> // 可设置超出终点后的张力(回拉力)
<anticipate_interpolator xmlns:android="http://schemas.android.com/apk/res/android" android:tension="2" /> // 可设置回退一小步的张力
<accelerateDecelerateInterpolator xmlns:android="http://schemas.android.com/apk/res/android" /> // 无法自定义参数
<anticipateOvershootInterpolator xmlns:android="http://schemas.android.com/apk/res/android" android:tension="2" android:extraTension="2" /> // 可设置回退一小步的张力和超出终点后的张力
<bounceInterpolator xmlns:android="http://schemas.android.com/apk/res/android" /> // 无法自定义参数
<cycleInterpolator xmlns:android="http://schemas.android.com/apk/res/android" android:cycles="2" /> // 可设置周期数
<pathInterpolator xmlns:android="http://schemas.android.com/apk/res/android"
    android:controlX1="0.1" android:controlY1="0.2" android:controlX2="0.3" android:controlY2="0.4"
/> // 可设置路径插值器的控制点坐标
```

```kotlin
// 自定义插值器
class MyInterpolator : Interpolator {
    override fun getInterpolation(input: Float): Float {
        return input * input
    }
}

// 使用自定义插值器
val objectAnimator = ObjectAnimator.ofFloat(view, "translationX", 0f, 100f).apply {
    duration = 1000
    interpolator = MyInterpolator()
}
objectAnimator.start()

// 使用路径插值器
val path = Path().apply {
    moveTo(0f, 0f) // moveTo() 方法用于将画笔移动到指定位置
    lineTo(100f, 100f) // lineTo() 方法用于从当前位置画一条直线到指定位置
    cubicTo(100f, 0f, 200f, 200f, 300f, 100f) // cubicTo() 方法用于绘制三次贝塞尔曲线
    arcTo(0f, 0f, 100f, 100f, 0f, 270f, true) // arcTo() 方法用于绘制弧形
}
val pathInterpolator = PathInterpolator(path)
```

求值器（TypeEvaluator）决定了动画属性值在起始值和结束值之间随进度 (fraction) 而如何变化. 动画期间, 求值器会根据当前时间对应的动画进度来计算出当前属性值, 并将其传递给动画监听器, 从而实现动画效果.

默认可用的求值器:

- `IntEvaluator`: 用于整型属性值的求值
- `FloatEvaluator`: 用于浮点型属性值的求值
- `ArgbEvaluator`: 用于颜色属性值的求值
- `RectEvaluator`: 用于矩形属性值的求值
- `PointEvaluator`: 用于点属性值的求值
- `IntArrayEvaluator`: 用于整型数组属性值的求值
- `FloatArrayEvaluator`: 用于浮点型数组属性值的求值

```kotlin
// 自定义求值器
class PointFEvaluator : TypeEvaluator<PointF> {
    override fun evaluate(fraction: Float, startValue: PointF, endValue: PointF): PointF {
        val x = startValue.x + (endValue.x - startValue.x) * fraction
        val y = startValue.y + (endValue.y - startValue.y) * fraction
        return PointF(x, y)
    }
}

// 使用自定义求值器
val startPoint = PointF(0f, 0f)
val endPoint = PointF(500f, 500f)

val animator = ValueAnimator.ofObject(PointFEvaluator(), startPoint, endPoint)
animator.duration = 1000
animator.addUpdateListener { animation ->
    val point = animation.animatedValue as PointF
    view.translationX = point.x
    view.translationY = point.y
}
animator.start()
```

#### android.view.animation（视图动画, 补间动画, 平移, 缩放, 旋转, 透明度）

> [!cite]
>
> [Tween(补间动画)完全解析](https://blog.csdn.net/dmk877/article/details/51912104)

视图动画: 通过对视图的属性进行动画操作, 适用于简单的动画效果

- 动画文件定义位置: `res/anim/`
- 动画定义方式

  ```xml
  <translate xmlns:android="http://schemas.android.com/apk/res/android"
      // 平移动画
      android:fromXDelta="0" // 起始位置 x 坐标 (px值, 百分比值, 百分比 p 值)
      android:toXDelta="100" // 结束位置 x 坐标
      android:fromYDelta="0" // 起始位置 y 坐标
      android:toYDelta="100" // 结束位置 y 坐标
  
  // 百分比 p 值表示相对于父容器宽或高的百分比值, 0% 表示起始位置, 100% 表示结束位置
  />
  
  <scale xmlns:android="http://schemas.android.com/apk/res/android"
      // 缩放动画
      android:fromXScale="1.0" // 起始 x 缩放比例, 0-1 缩小, 1-∞ 放大
      android:toXScale="0.5" // 结束 x 缩放比例
      android:fromYScale="1.0" // 起始 y 缩放比例
      android:toYScale="0.5" // 结束 y 缩放比例
  
      android:pivotX="50%" // 视图缩放的中心 x 坐标 (px 值, 百分比值, 百分比 p 值)
      android:pivotY="50%" // 视图缩放的中心 y 坐标
  />
  
  <rotate xmlns:android="http://schemas.android.com/apk/res/android"
      // 旋转动画
      android:fromDegrees="0" // 起始角度
      android:toDegrees="360" // 结束角度
      android:pivotX="50%" // 旋转中心 x 坐标 (px 值, 百分比值, 百分比 p 值)
      android:pivotY="50%" // 旋转中心 y 坐标
  />
  
  <alpha xmlns:android="http://schemas.android.com/apk/res/android"
      // 透明度动画
      android:fromAlpha="1.0" // 起始透明度
      android:toAlpha="0.0" // 结束透明度
  />
  
  <set xmlns:android="http://schemas.android.com/apk/res/android"
      // 组合动画
      android:shareInterpolator="true" // 是否共享插值器, false 时需要为每个子动画设置插值器
      // 可以通过 startOffset 属性自定义每个动画开始前的延迟时间, 默认一起开始
  >
  
      <alpha
          ...
      />
  
      <scale
          ...
      />
  
      ...
  
  </set>
  
  <any
      // 通用属性
      android:duration="1000" // 动画持续时间
      android:startOffset="1000" // 动画开始前的延迟时间
      android:fillBefore="true" // 动画结束后是否回到初始状态, 默认为 true
      android:fillEnabled="true" // 是否启用 fillBefore, 默认为 true
      android:fillAfter="true" // 动画结束后是否保持结束状态, 默认为 false, 优先于 fillBefore
      android:repeatCount="infinite" // 动画重复次数, 默认为 0, 0 为不重复, -1 为无限重复
      android:repeatMode="reverse" // 动画重复模式, 默认为 restart, reverse 为反向重复
      android:interpolator="@android:anim/accelerate_decelerate_interpolator" // 动画插值器
  />
  ```

- 动画启动方式 (xml)

  ```kotlin
  
  // View
  val imageView = findViewById<ImageView>(R.id.image)
  val animation = AnimationUtils.loadAnimation(this, R.anim.bounce_animation)
  imageView.startAnimation(animation)
  
  // Fragment
  val fragmentManager = supportFragmentManager(Activity 情况下) | getParentFragmentManager()(Fragment 情况下)
  FragmentTransaction transaction = fragmentManager.beginTransaction();
  transaction.setCustomAnimations(R.anim.enter_animation, R.anim.exit_animation);
  transaction.replace(R.id.fragment_container, new MyFragment());
  transaction.addToBackStack(null)
  transaction.commit();
  
  // Activity
  val intent = Intent(context, TargetActivity::class.java)
  val options = ActivityOptions.makeCustomAnimation(context, R.anim.enter_anim, R.anim.exit_anim)
  startActivity(intent, options.toBundle())
  ```

- 动画启动方式(代码) 暂无

#### android.animation (属性动画)

属性动画: 通过对视图的属性进行动画操作, 适用于复杂的动画效果.

- 针对属性值进行动画操作, 因此适用于任何对象的任何属性, 而不仅限于平移, 缩放, 旋转, 透明度等.
- 动画操作可以针对于对象本身, 而不是如补间动画那样只是改变了视图对象的显示效果.
- 属性动画支持所有的通用属性, 如动画持续时间, 动画插值器等.
- 动画文件定义位置: `res/animator/`
- 使用时需要每个动画都需要绑定目标对象的属性名称, 并通过 `setTarget()` 方法绑定目标对象, 然后再通过 `start()` 方法启动动画.
- 23 之后的安卓版本可以使用 `PropertyValuesHolder` 和 `Keyframe` 来进阶定义动画效果, 比如为动画添加关键帧, 设置关键帧的插值器, 为 `objectAnimator` 添加多个属性值等.
- 对于修改后不自动触发 `invalidate()` 方法的属性, 需要手动调用 `invalidate()` 方法来刷新视图.
- 具有与视图动画几乎相同的通用属性, 如 `duration`, `startOffset`, `fillBefore`, `fillEnabled`, `fillAfter`, `repeatCount`, `repeatMode`, `interpolator` 等.

  ```xml
  <any
      // 通用属性
      android:duration="1000" // 动画持续时间
      android:startOffset="1000" // 动画开始前的延迟时间
      android:fillBefore="true" // 动画结束后是否回到初始状态, 默认为 true
      android:fillEnabled="true" // 是否启用 fillBefore, 默认为 true
      android:fillAfter="true" // 动画结束后是否保持结束状态, 默认为 false, 优先于 fillBefore
      android:repeatCount="infinite" // 动画重复次数, 默认为 0, 0 为不重复, -1 为无限重复
      android:repeatMode="reverse" // 动画重复模式, 默认为 restart, reverse 为反向重复
      android:interpolator="@android:anim/accelerate_decelerate_interpolator" // 动画插值器
  />
  ```

##### `ValueAnimator` 定义

构造时直接传入起始值, 中间值(可选, 可多个), 结束值. 使用时需要通过动画监听器来监听动画过程中属性值的变化, 并在监听器中根据当前属性值来更新目标对象的属性值(如视图的位置), 从而实现动画效果.

- 可以通过不同的工厂方法创建不同类型的 `ValueAnimator` 对象, 如 `ofInt()`, `ofFloat()`, `ofObject()`.

```kotlin
// 创建 ValueAnimator 对象
val valueAnimator = ValueAnimator.ofInt(0, 100)
val valueAnimator = ValueAnimator.ofFloat(0f, 100f)
val valueAnimator = ValueAnimator.ofObject(PointFEvaluator(), startPoint, endPoint)
```

```xml
<animator xmlns:android="http://schemas.android.com/apk/res/android"
    android:valueFrom="1"
    android:valueTo="0"
    android:valueType="floatType" | "intType" | "objectType"
/>
```

##### `ObjectAnimator` 定义

`ObjectAnimator` 是 `ValueAnimator` 的子类, 用于对对象的属性进行动画操作. 构造时需要传入目标对象, 属性名称, 起始值, 中间值(可选, 可多个), 结束值. 使用时直接调用 `start()` 方法启动动画.

- 对象属性必须可以 `get` 和 `set`. 例如, 如果属性名称是 `foo`, 则需要有一个 `getFoo()` 方法和一个 `setFoo()` 方法.

```kotlin
// 创建 ObjectAnimator 对象
val objectAnimator = ObjectAnimator.ofInt(view, "translationX", 0, 100)
val objectAnimator = ObjectAnimator.ofFloat(view, "translationX", 0f, 100f)
val objectAnimator = ObjectAnimator.ofObject(view, "point", PointFEvaluator(), startPoint, endPoint)
val path = Path().apply {
    arcTo(0f, 0f, 100f, 100f, 0f, 359f, true) // 一个圆形路径
}
val objectAnimator = ObjectAnimator.ofFloat(view, View.X, View.Y, path)
```

```xml
<objectAnimator xmlns:android="http://schemas.android.com/apk/res/android"
    android:propertyName="translationX" // 动画属性名称
    android:valueFrom="0" // 起始值
    android:valueTo="100" // 结束值
    android:valueType="floatType" | "intType" | "objectType"
/>
```

##### `TimeAnimator` 定义

`TimeAnimator` 是 `ValueAnimator` 的子类, 用于监听动画过程中的时间变化. 使用时需要通过动画监听器来监听动画过程中时间的变化, 并在监听器中根据当前时间来更新目标对象的属性值, 从而实现动画效果. 注意动画监听器有两种, 一种是专属 `TimeAnimator`的 `TimeListener` 用于监听动画过程中时间的变化, 另一种是 `AnimatorListener` 用于监听动画的开始, 结束, 取消, 重复等事件.

```kotlin
// 创建 TimeAnimator 对象
val animator = TimeAnimator().apply {
    // 添加动画监听器
    setTimeListener { animation, totalTime, deltaTime ->
        view.layout(deltaTime.toInt(), deltaTime.toInt(), deltaTime.toInt() + view.width, deltaTime.toInt() + view.height)
    }
}
```

##### `AnimatorSet` 定义

借助 `AnimatorSet` 可以将多个动画组合在一起, 并设置它们的执行顺序, 重复次数, 重复模式等. 使用时需要通过 `play()` 方法将多个动画添加到 `AnimatorSet` 中, 然后通过 `start()` 方法启动动画.

```kotlin
// 创建 ObjectAnimator 对象
val objectAnimator1 = ...
val objectAnimator2 = ...
val objectAnimator3 = ...
val objectAnimator4 = ...
val objectAnimator5 = ...

// 创建 AnimatorSet 对象
val animator = AnimatorSet().apply {
    // 手动设置动画执行顺序
    play(objectAnimator1).before(objectAnimator2)
    play(objectAnimator3).with(objectAnimator2)
    play(objectAnimator4).with(objectAnimator2)
    play(objectAnimator5).after(objectAnimator4)
    // 设置动画重复次数
    repeatCount = ValueAnimator.INFINITE
    // 设置动画重复模式
    repeatMode = ValueAnimator.REVERSE
}

// 嵌套和统一设置方法
val animatorSet1 = AnimatorSet().apply {
    playTogether(objectAnimator2, objectAnimator3, objectAnimator4)
}
val animator = AnimatorSet().apply {
    playSequentially(objectAnimator1, animatorSet1, objectAnimator5)
}
```

```xml
<set xmlns:android="http://schemas.android.com/apk/res/android"
    // 组合动画
    android:shareInterpolator="true" // 是否共享插值器, false 时需要为每个子动画设置插值器
    android:ordering="together" // 动画执行顺序, together 为同时执行, sequential 为顺序执行. 也可以通过 startOffset 属性自定义每个动画开始前的延迟时间
>

    <animate ... />
    <objectAnimator ... />
    <set ... />

</set>
```

##### 关键帧 (Keyframe)

关键帧: 用于为属性动画添加关键帧, 设置关键帧的插值器, 为 `objectAnimator` 添加多个属性值等.

- 关键帧使用方式 (xml)

  ```xml
  <animator xmlns:android="http://schemas.android.com/apk/res/android">
      <propertyValuesHolder>
          <keyframe android:fraction="0" android:value="1"/>
          <keyframe android:fraction=".2" android:value=".4"/>
          <keyframe android:fraction="1" android:value="0"/>
      </propertyValuesHolder>
  </animator>
  
  <objectAnimator xmlns:android="http://schemas.android.com/apk/res/android">
      <propertyValuesHolder android:propertyName="x" >
          <keyframe android:fraction="0" android:value="800" />
          <keyframe android:fraction=".2"
                  android:interpolator="@android:anim/accelerate_interpolator"
                  android:value="1000" />
          <keyframe android:fraction="1"
                  android:interpolator="@android:anim/accelerate_interpolator"
                  android:value="400" />
      </propertyValuesHolder>
      <propertyValuesHolder android:propertyName="y" >
          <keyframe/>
          <keyframe android:fraction=".2"
                  android:interpolator="@android:anim/accelerate_interpolator"
                  android:value="300"/>
          <keyframe android:interpolator="@android:anim/accelerate_interpolator"
                  android:value="1000" />
      </propertyValuesHolder>
  </objectAnimator>
  ```

- 关键帧使用方式 (代码)

  ```kotlin
  val keyframe1 = Keyframe.ofFloat(0f, 1f)
  val keyframe2 = Keyframe.ofFloat(0.2f, 0.4f)
  val keyframe3 = Keyframe.ofFloat(1f, 0f)
  
  val propertyValuesHolder = PropertyValuesHolder.ofKeyframe("scaleX", keyframe1, keyframe2, keyframe3)
  val animator = ValueAnimator.ofPropertyValuesHolder(propertyValuesHolder)
  
  val keyframe1 = Keyframe.ofFloat(0f, 800f)
  val keyframe2 = Keyframe.ofFloat(0.2f, 1000f)
  val keyframe3 = Keyframe.ofFloat(1f, 400f)
  val propertyValuesHolderX = PropertyValuesHolder.ofKeyframe("x", keyframe1, keyframe2, keyframe3)
  val keyframe1 = Keyframe.ofFloat(0f, 0f)
  val keyframe2 = Keyframe.ofFloat(0.2f, 300f)
  val keyframe3 = Keyframe.ofFloat(1f, 1000f)
  val propertyValuesHolderY = PropertyValuesHolder.ofKeyframe("y", keyframe1, keyframe2, keyframe3)
  val animator = ObjectAnimator.ofPropertyValuesHolder(tagetView, propertyValuesHolderX, propertyValuesHolderY)
  ```

##### 属性动画启动

- 动画监听器有两种, 一种是专属 `ValueAnimator`的 `AnimatorUpdateListener` 用于监听动画过程中属性值的变化, 另一种是 `AnimatorListener` 用于监听动画的开始, 结束, 取消, 重复等事件.

```kotlin

// 代码动画启动
val animator = ...
animator.start()

// xml 动画定义需要加载和启动
val animator = AnimatorInflater.loadAnimator(context, R.animator.animator_file) as ValueAnimator | ObjectAnimator | AnimatorSet
animator.setTarget(view)

animator.apply {
    // 设置动画持续时间
    duration = 1000
    // 设置动画插值器
    interpolator = AccelerateDecelerateInterpolator()
    // 添加动画监听器
    addUpdateListener {
        val value = it.animatedValue as Int | Float | PointF
        // 修改目标对象的属性值
    }

    addListener(object : AnimatorListener {
        // 重载方法
    })
}

animator.start()

// 布局动画启动

viewGroup = <LinearLayout android:animateLayoutChanges="true" > </LinearLayout> // xml
viewGroup = code && viewGroup.layoutTransition.enableTransitionType(LayoutTransition.CHANGING) // 代码

val layoutTransition = LayoutTransition()
layoutTransition.setAnimator(LayoutTransition.APPEARING, animator)
layoutTransition.setAnimator(LayoutTransition.DISAPPEARING, animator)
layoutTransition.setAnimator(LayoutTransition.CHANGE_APPEARING, animator)
layoutTransition.setAnimator(LayoutTransition.CHANGE_DISAPPEARING, animator)
layoutTransition.setAnimator(LayoutTransition.CHANGING, animator)
viewGroup.layoutTransition = layoutTransition

```

##### 针对视图的更简易的属性动画启动方式

```kotlin
// 代码动画启动
view.animate().translationX(100f).translationY(100f).rotation(360f).alpha(0.5f).setDuration(1000).start()
```

#### 矢量图动画

矢量图动画: 通过对矢量图的属性进行动画操作, 例如旋转它或更改路径数据以将其变形为不同的图像.

- 动画文件定义位置: `res/drawable/` & `res/animator/`
- 动画定义方式 (xml)

  ```xml
  <!-- res/drawable/vectordrawable.xml  定义矢量图 -->
  <vector xmlns:android="http://schemas.android.com/apk/res/android"
      android:height="64dp"
      android:width="64dp"
      android:viewportHeight="600"
      android:viewportWidth="600">
      <group
          android:name="rotationGroup"
          android:pivotX="300.0"
          android:pivotY="300.0"
          android:rotation="45.0" >
          <path
              android:name="v"
              android:fillColor="#000000"
              android:pathData="M300,70 l 0,-70 70,70 0,0 -70,70z" />
      </group>
  </vector>
  
  <!-- res/animator/animatorvectordrawable.xml  定义矢量图动画 -->
  <animated-vector xmlns:android="http://schemas.android.com/apk/res/android"
  android:drawable="@drawable/vectordrawable" >
      <target
          android:name="rotationGroup"
          android:animation="@animator/rotation" />
      <target
          android:name="v"
          android:animation="@animator/path_morph" />
  </animated-vector>
  
  <!-- res/animator/rotation.xml  定义旋转动画 -->
  <objectAnimator
      android:duration="6000"
      android:propertyName="rotation"
      android:valueFrom="0"
      android:valueTo="360" />
  
  <!-- res/animator/path_morph.xml  定义路径变形动画 -->
  <set xmlns:android="http://schemas.android.com/apk/res/android">
      <objectAnimator
          android:duration="3000"
          android:propertyName="pathData"
          android:valueFrom="M300,70 l 0,-70 70,70 0,0   -70,70z"
          android:valueTo="M300,70 l 0,-70 70,0  0,140 -70,0 z"
          android:valueType="pathType" />
  </set>
  ```

#### Transition (过渡动画)

过渡动画: 用于在两个视图之间进行动画切换, 适用于视图之间的切换效果.

#### 状态列表动画

状态列表动画: 用于在视图的不同状态之间进行动画切换, 适用于视图的状态切换效果.

- 动画文件定义位置: `res/xml/`
- 动画定义方式 (xml)

  ```xml
  <?xml version="1.0" encoding="utf-8"?>
  <selector xmlns:android="http://schemas.android.com/apk/res/android">
      <!-- the pressed state; increase x and y size to 150% -->
      <item android:state_pressed="true">
          <set>
              <objectAnimator android:propertyName="scaleX"
                  android:duration="@android:integer/config_shortAnimTime"
                  android:valueTo="1.5"
                  android:valueType="floatType"/>
              <objectAnimator android:propertyName="scaleY"
                  android:duration="@android:integer/config_shortAnimTime"
                  android:valueTo="1.5"
                  android:valueType="floatType"/>
          </set>
      </item>
      <!-- the default, non-pressed state; set x and y size to 100% -->
      <item android:state_pressed="false">
          <set>
              <objectAnimator android:propertyName="scaleX"
                  android:duration="@android:integer/config_shortAnimTime"
                  android:valueTo="1"
                  android:valueType="floatType"/>
              <objectAnimator android:propertyName="scaleY"
                  android:duration="@android:integer/config_shortAnimTime"
                  android:valueTo="1"
                  android:valueType="floatType"/>
          </set>
      </item>
  </selector>
  ```

- 动画定义方式 (代码)

  ```kotlin
  
  ```

- 动画启动方式 (xml)

  ```xml
  <Button android:stateListAnimator="@xml/animate_scale"
      ... />
  ```

- 动画启动方式 (代码)

  ```kotlin
  val button = findViewById<Button>(R.id.button)
  val stateListAnimator = AnimatorInflater.loadStateListAnimator(this, R.xml.animate_scale)
  button.stateListAnimator = stateListAnimator
  ```

#### 动画实用工具类(圆形揭示动画)

`ViewAnimationUtils` 提供了一些实用的方法来创建和操作动画.

- `createCircularReveal()`: 创建一个圆形揭示动画, 从一个视图的中心开始揭示到视图的边缘.

  ```kotlin
  val view = findViewById<View>(R.id.view)
  // 获取视图的中心坐标
  val cx = view.width / 2
  val cy = view.height / 2
  // 计算揭示动画的半径
  val initialRadius = Math.hypot(cx.toDouble(), cy.toDouble()).toFloat()
  val anim = ViewAnimationUtils.createCircularReveal(view, cx, cy, initialRadius, 0f)
  anim.addListener(object : AnimatorListenerAdapter() {
      override fun onAnimationStart(animation: Animator) {
          view.visibility = View.INVISIBLE
      }
  })
  anim.start()
  ```

#### 动态动画 (dynamicanimation)

`DynamicAnimation` 是一个用于创建动态动画的类, 用于模拟物理运动, 例如弹簧, 摩擦力等. `DynamicAnimation` 有两个子类, 分别是 `SpringAnimation` 和 `FlingAnimation`. `SpringAnimation` 用于模拟弹簧运动, `FlingAnimation` 用于模拟惯性运动.

- 需要引入额外的依赖库

  ```gradle
  dependencies {
      implementation 'androidx.dynamicanimation:dynamicanimation:1.0.0'
  }
  ```

- `ViewProperty` 用于指定需要进行动画操作的属性, 如 `TRANSLATION_X`, `TRANSLATION_Y`, `TRANSLATION_Z`, `ROTATION`, `ROTATION_X`, `ROTATION_Y`, `SCALE_X`, `SCALE_Y`, `X`, `Y`, `Z`, `ALPHA`.
- `FlingAnimation` 用于模拟惯性运动, 例如滑动效果.

  ```kotlin
  val view = findViewById<View>(R.id.view)
  // 计算触摸速度
  val velocityX = 1000f
  val maxScroll = 1000f
  val flingAnimation = FlingAnimation(view, DynamicAnimation.TRANSLATION_X)
  flingAnimation.setStartVelocity(velocityX) // 以每秒像素为单位的速度
  flingAnimation.setMinValue(0f)
  flingAnimation.setMaxValue(maxScroll)
  flingAnimation.setFriction(1.1f) // 摩擦力, 定义了动画中速度降低的速度
  flingAnimation.start()
  ```

- `SpringAnimation` 用于模拟弹簧运动, 例如弹簧的拉伸和压缩效果.

  ```kotlin
  val view = findViewById<View>(R.id.view)
  val springAnimation = SpringAnimation(view, DynamicAnimation.TRANSLATION_Y, 0f)
  springAnimation.spring.stiffness = SpringForce.STIFFNESS_LOW
  springAnimation.spring.dampingRatio = SpringForce.DAMPING_RATIO_HIGH_BOUNCY
  springAnimation.addUpdateListener { animation, value, velocity ->
      // 更新视图的属性值
  }
  springAnimation.addEndListener { animation, canceled, value, velocity ->
      // 动画结束时的回调
      flingAnimation.start()
  }
  springAnimation.start()
  ```

## 网络库(HttpURLConnection, OkHttp, Retrofit, 内部库)

网络请求库 = 网络请求 + 数据解析 + 线程切换(异步) + 异常处理

### HttpURLConnection

> [!TODO]

### OkHttp

> [!cite] > [【OkHttp】OkHttp Get 和 Post 请求 ( 同步 Get 请求 | 异步 Get 请求 | 同步 Post 请求 | 异步 Post 请求 )-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/2249988) > [网络请求框架 OkHttp3 全解系列 (一) ：OkHttp 的基本使用-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/1667338) > [由浅入深, 聊聊 OkHttp 的那些事(易懂, 不繁琐) - 掘金](https://juejin.cn/post/7199431845367922745?searchId=20240806152219108948FAF7C05048547D) > [Android 主流网络请求框架 OkHttp 全方位详析 - 掘金](https://juejin.cn/post/7345756317557817354?searchId=20240806152219108948FAF7C05048547D) > [从 OKHttp 框架看代码设计](https://juejin.cn/post/6844903449469943821?searchId=2024080615223180876F5097A608E5EACE) > [HTTP 客户端连接, 选择 HttpClient 还是 OkHttp？](https://juejin.cn/post/6844904040644476941?searchId=2024080615223180876F5097A608E5EACE) > [OkHttp 的完整指南](https://juejin.cn/post/7068162792154464264?searchId=2024080615223180876F5097A608E5EACE) > [雨露均沾的 OkHttp—WebSocket 长连接 (使用篇) - 掘金](https://juejin.cn/post/6847009772198166536?searchId=2024080615223180876F5097A608E5EACE) > [官方推荐使用的 OkHttp4 网络请求库全面解析！](https://juejin.cn/post/7212536164057776184?searchId=2024080615223180876F5097A608E5EACE) > [OkHttp 拦截器的一些骚操作 - 掘金](https://juejin.cn/post/6844903606718562317?searchId=2024080615223180876F5097A608E5EACE) > [一篇文章带你走通 OkHttp+Retrofit+Rxjava - 掘金](https://juejin.cn/post/6844903464082866190?searchId=2024080615223180876F5097A608E5EACE) > [使用 Retrofit 2.0 + OkHttp 3.0 实现缓存处理 - 掘金](https://juejin.cn/post/6844903444285751309?searchId=2024080615223180876F5097A608E5EACE) > [OKHttp 源码解析(一)--初阶-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/1199021)

- 简洁易用的 API：通过构建 Request 对象和使用 Call 对象来发起同步或异步的网络请求.
- 支持现代的 HTTP 协议, 包括 HTTP/2 和 SPDY
- 连接池和缓存：OkHttp 内置了连接池和响应缓存, 可以有效地管理和复用网络连接, 并提供可配置的缓存机制, 减少重复的网络请求.
- 自动重试 ：在请求失败时自动重试请求, 从而提高请求可靠性.
- 拦截器：提供拦截器机制, 允许在发送请求和接收响应的过程中进行自定义处理, 例如添加公共参数、日志记录等.
- 支持 gzip 压缩 ：支持接受和解压 GZIP 压缩的响应数据, 减小网络传输的数据量, 提升网络性能.

#### 使用

![_](%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91.assets/file-20240806154800379.png)

```kotlin
val client = OkHttpClient.Builder() // 1. 创建 OkHttpClient 实例
    .connectTimeout(5000L, java.util.concurrent.TimeUnit.MILLISECONDS)
    .readTimeout(5000L, java.util.concurrent.TimeUnit.MILLISECONDS)
    .writeTimeout(5000L, java.util.concurrent.TimeUnit.MILLISECONDS)
    .retryOnConnectionFailure(true)
    .followRedirects(true)
    .followSslRedirects(true)
    .cache(null) // 设置缓存
    .authenticator(null) // 设置身份验证器
    .certificatePinner(null) // 设置证书锁定器
    .connectionPool(null) // 设置连接池
    .connectionSpecs(listOf()) // 设置连接规范
    .cookieJar(null) // 设置 Cookie 管理器
    .dispatcher(null) // 设置分发器
    .dns(null) // 设置 DNS 解析器
    .eventListenerFactory(null) // 设置事件监听器工厂
    .proxy(null) // 设置代理
    .protocols(listOf()) // 设置支持的协议
    .proxyAuthenticator(null) // 设置代理身份验证器
    .proxySelector(null) // 设置代理选择器
    .socketFactory(null) // 设置 Socket 工厂
    .hostnameVerifier(null) // 设置主机名验证器
    .build()

val getRequest = Request.Builder() // 2. 创建 Request 对象
    .url("https://reqres.in/api/users?page=2")
    .header("name", "value")
    .addHeader("name", "value")
    .cacheControl(null) // 设置缓存控制
    .build()

// 3. 同步请求
val response1 = client.newCall(getRequest).execute().use { response ->
    response.body?.string() ?: ""
}

// 3. 异步请求, 如果当前 request 已执行, 抛出错误
val response2 = client.newCall(get).enqueue(object : Callback {
    override fun onFailure(call: Call?, e: IOException) {
        //
    }

    override fun onResponse(call: Call?, response: Response) {
        val content = response.body?.string() ?: ""
    }
})
```

#### 原理

> [!cite] > [由浅入深, 聊聊 OkHttp 的那些事(易懂, 不繁琐) - 掘金](https://juejin.cn/post/7199431845367922745?searchId=20240806152219108948FAF7C05048547D) > [面试官：听说你熟悉 OkHttp 原理？ - 掘金](https://juejin.cn/post/6844904087788453896?searchId=20240806152219108948FAF7C05048547D)

![_](%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91.assets/file-20240806152547281.png)

> [!TODO]

### Retrofit

> [!TODO]

### 内部库

## 临时

### Git – 断点续传 git 大项目

假设要从 GitHub 拉取 OpenCV：[https://github.com/opencv/opencv 进行编译](https://github.com/opencv/opencv进行编译), 可以按照以下的方法.

1. 首先新建一个项目文件夹, 初始化空白 git 仓库

   ```bash
   mkdir opencv
   cd opencv
   git init
   ```

2. 添加远程仓库

   ```bash
   git remote add origin https://github.com/opencv/opencv
   ```

3. 拉取所有分支、标签和完整历史记录

   ```bash
   git fetch origin --prune --tags +refs/heads/*:refs/remotes/origin/*
   
   origin：指定远程仓库名.
   --prune：删除本地没有的远程分支.
   --tags：获取所有标签.
   +refs/heads/*:refs/remotes/origin/*：获取远程仓库的所有分支, 并将其映射到本地的 refs/remotes/origin/ 下, 一般可以不加此选项
   ```

4. 如果第 3 步中断或者失败, 则重复执行第 3 步, 直到完成下载
5. 下载完成之后, 检出需要的分支或标签, 如 master

   ```bash
   git branch -r
   git tag
   git checkout master
   ```

6. 更新所有本地分支和远程分支的映射关系

   ```bash
   git pull origin --all
   ```

7. 再执行 `git checkout master` 命令

在 Linux 系统下, 可以写一个 shell 脚本, 自动循环进行 `git fetch`.

### 为什么减少依赖很重要？

这段内容强调了在开发 Android 应用时, 应该尽量减少对 Android 框架类 (如 Context、Toast 等) 的直接依赖, 将这些依赖隔离在少数核心组件中. 这样做的主要目的是提高代码的可测试性和模块化, 降低耦合度.

1. 提高可测试性：当类依赖于 Android 框架时 (例如需要一个 Context 实例) , 在编写单元测试时, 必须模拟这些依赖对象, 这可能会增加复杂性. 如果业务逻辑不依赖于 Android 框架类, 那么编写单元测试就变得更加容易, 因为你只需要测试纯粹的业务逻辑, 而不必处理 Android 特有的依赖.
2. 降低耦合度：如果类依赖于 Android 框架, 它们就只能在 Android 环境中运行 (例如设备或模拟器). 通过减少这种依赖性, 代码可以更独立、更灵活, 可以在不同的环境中复用, 且不容易受到 Android 特定 API 的限制.  
   举例说明  
   不良的依赖设计  
   考虑以下示例, 一个 UserManager 类直接依赖于 Context 来获取资源或展示 Toast：

```kotlin
class UserManager(private val context: Context) {

    fun showWelcomeMessage() {
        // 使用 Context 来显示 Toast 消息
        Toast.makeText(context, "Welcome!", Toast.LENGTH_SHORT).show()
    }
}
```

在这个设计中, UserManager 类直接依赖于 Context, 这会带来以下问题：

- 难以测试：在测试时, 你需要提供一个 Context 实例, 这可能会使测试更加复杂和笨重.
- 耦合性高：UserManager 只能在 Android 环境中使用, 因为它需要一个 Context 实例.  
  改进后的设计  
  现在我们将 UserManager 中与 Android 相关的操作抽离到一个单独的接口中, 这样就可以减少对 Android 类的直接依赖：

```kotlin
interface MessageDisplayer {
    fun showMessage(message: String)
}

class ToastMessageDisplayer(private val context: Context) : MessageDisplayer {
    override fun showMessage(message: String) {
        Toast.makeText(context, message, Toast.LENGTH_SHORT).show()
    }
}

class UserManager(private val messageDisplayer: MessageDisplayer) {

    fun showWelcomeMessage() {
        // 使用抽象接口来显示消息
        messageDisplayer.showMessage("Welcome!")
    }
}
```

在这个改进的设计中：

- MessageDisplayer：定义了一个抽象接口, 它不依赖于 Android 框架. 这个接口可以有不同的实现, 比如 ToastMessageDisplayer 用于 Android 环境.
- ToastMessageDisplayer：是 MessageDisplayer 的具体实现, 负责实际显示 Toast 消息. 它依赖 Context, 但这种依赖被隔离在了这个具体的类中.
- UserManager：现在只依赖于 MessageDisplayer 接口, 而不是直接依赖 Context. 这使得 UserManager 可以轻松地进行单元测试, 因为你可以传递一个简单的 MessageDisplayer mock 对象.  
  在测试中的优势  
  在测试 UserManager 时, 你不再需要依赖 Context 或 Android 特有的类：

```kotlin
class FakeMessageDisplayer : MessageDisplayer {
    var message: String? = null

    override fun showMessage(message: String) {
        this.message = message
    }
}

fun testShowWelcomeMessage() {
    val fakeMessageDisplayer = FakeMessageDisplayer()
    val userManager = UserManager(fakeMessageDisplayer)

    userManager.showWelcomeMessage()

    assert(fakeMessageDisplayer.message == "Welcome!")
}
```

在这个测试中, FakeMessageDisplayer 是 MessageDisplayer 的一个简单实现, 允许你检查 UserManager 的行为而不需要 Context.  
总结  
减少对 Android 类的直接依赖, 通过使用接口或抽象类来隔离 Android 相关操作, 可以让你的应用更加模块化和可测试. 你可以将业务逻辑与 Android 特有的实现细节分开, 使代码更灵活、更容易测试, 也更符合 SOLID 原则中的单一职责和依赖倒置原则.

### 文件读写和权限说明

> [!todo] > [记一个 Android 14 适配引发的 Android 存储权限问题](https://www.cnblogs.com/joy99/p/17809113.html) > [Android 文件读写最全解析](https://www.cnblogs.com/joy99/p/17809113.html) > [Android 数据存储五种方式使用与总结.md](<https://github.com/helen-x/AndroidInterview/blob/master/android/Android> 数据存储五种方式使用与总结.md)

sharedPreferences: 基于 XML 文件存储的键值对数据, 根据第一个参数 name 获得相应的 SharedPreferences 对象

- MODE_PRIVATE: 只能被本应用程序读、写
- MODE_WORLD_READABLE: 其他应用程序可以读, 但不能写
- MODE_WORLD_WRITEABLE: 其他应用程序可以读, 写
- MODE_MULTI_PROCESS: 当多个进程同时读写同一个 SharedPreferences 时, 会检查文件是否修改

## Android 多线程

任务执行和管理: `Thread` | `Runnable` | `Executors` | `WorkManager` (`AsyncTask` 弃用了) | `ThreadPoolExecutor`  
任务反馈及交互: `Callable` | `Future` | `FutureTask` | `Handler` | `HandlerThread` |

### 直接创建和管理线程及其任务

子类化 `Thread`. 通过复写 `run` 方法自定义线程任务, 同时可以通过创建的线程对象管理线程, 如 运行、睡眠、挂起、停止.

```kotlin
class MyThread(name: String) : Thread(name) {
    private var ticket = 100
    override fun run() {
        while (ticket > 0) {
            ticket--
            Thread.sleep(1000)
        }
    }
}

// 创建线程对象并启动
val mt = MyThread("线程名称")
mt.start()

// 使用匿名类创建和启动线程
Thread("线程名称") {
    var ticket = 100
    while (ticket > 0) {
        ticket--
        println("线程名称: 卖掉了1张票, 剩余票数为: $ticket")
        Thread.sleep(1000) // 卖票速度是1秒一张
    }
}.start()
```

### 任务与线程分离, 实现线程复用和资源共享

通过实现 `Runnable` 任务接口, 只需要定义一个 `run` 方法来自定义线程任务(即只关注于任务). 通过创建 `Runnable` 任务对象, 并将 `Runnable` 对象传递给一个或多个线程对象, 使得线程对象可以执行 `Runnable` 对象定义的线程任务, 同时共享此 `Runnable` 对象中的资源. 线程的管理仍是通过线程对象自身进行, 但是无需子类化 `Thread`.

```kotlin
class MyRunnable : Runnable {
    private var ticket = 100
    override fun run() {
        while (ticket > 0) {
            ticket--
            Thread.sleep(1000)
        }
    }
}

// 创建线程对象并启动任务
val myRunnable = MyRunnable()
val thread1 = Thread(myRunnable)
val thread2 = Thread(myRunnable)
thread1.start()
thread2.start()

// 使用匿名 Runnable 创建和启动线程
val runnable = Runnable {
    var ticket = 100
    while (ticket > 0) {
        ticket--
        Thread.sleep(1000)
    }
}

Thread(runnable, "线程名称1").start()
Thread(runnable, "线程名称2").start()

// 使用 lambda 表达式创建和启动线程, lambda 表达式会被自动转换成 Runnable.
Thread {
    var ticket = 100
    while (ticket > 0) {
        ticket--
        Thread.sleep(1000)
    }
}.start()
```

### 使用线程池简化线程创建和生命周期管理

将任务提交给线程池, 根据需要分配线程来执行任务.

`Executor` 是一个接口, 只限制了实现任务提交到线程池和任务执行的功能.  
`ExecutorService` 是在 `Executor` 的基础上进一步定义的接口, 提供了控制任务执行和更高级的任务提交功能.

- `shutdown()` 方法停止提交任务, 并允许先前提交的任务继续执行, 直到执行完成.
- `shutdownNow()` 方法停止提交任务, 并阻止等待先前提交的任务, 尝试停止当前正在执行的任务.
- `submit(...)` 方法提交任务, 并返回一个可用于取消任务执行和存放任务结果的 `Future` 对象.
- `invokeAny` 和 `invokeAll` 执行一组任务, 然后等到至少一个或全部任务完成.  
  `ScheduledExecutorService` 是在 `ExecutorService` 基础上进一步定义的接口, 提供了延迟和周期性执行任务的功能.
- `schedule(...)` 方法, 用于延迟执行任务.
- `scheduleAtFixedRate(...)` 方法, 用于周期性执行任务.
- `scheduleWithFixedDelay(...)` 方法, 用于周期性执行任务, 但是在任务完成后的固定延迟后再次执行.

完整的实现了 `ExecutorService` 或 `ScheduledExecutorService` 的线程池服务类型有:

- `ForkJoinPool`
- `ScheduledExecutorService`
- `ThreadPoolExecutor`

    - `ScheduledThreadPoolExecutor`

`Executors` 是一个工具类, 提供了方便的工厂方法来创建以上列举的不同类型的线程池服务对象.

```kotlin
// 固定大小的线程池, 适用于需要限制线程数量, 且需要复用线程执行大量短期任务的场景
val executor = Executors.newFixedThreadPool(3) // ExecutorService
// 可缓存的线程池, 优先复用已有线程, 不足时根据需要创建新线程, 适用于执行大量生存期很短的异步任务
val executor = Executors.newCachedThreadPool()
// 只有一个线程, 所有任务按照提交顺序执行
val executor = Executors.newSingleThreadExecutor()
executor.execute { Thread.sleep(1000) } // 模拟任务执行时间
executor.shutdown()

// 定时任务线程池, 适用于需要延迟执行或周期性执行任务的场景
val scheduler = Executors.newScheduledThreadPool(2)
scheduler.schedule({ Thread.sleep(1000) }, 2, TimeUnit.SECONDS) // 延迟2秒后执行
scheduler.scheduleAtFixedRate({ Thread.sleep(1000) }, 1, 3, TimeUnit.SECONDS) // 延迟1秒后, 每3秒执行一次
scheduler.shutdown()

// 自定义线程池
val threadPool = ThreadPoolExecutor(
    2, // 核心线程数
    4, // 最大线程数
    60, // 空闲线程存活时间
    TimeUnit.SECONDS, // 时间单位
    LinkedBlockingQueue<Runnable>(2) // 任务队列
)
threadPool.execute { Thread.sleep(1000) } // 模拟任务执行时间
threadPool.shutdown()
```

### 异步获取任务结果

`ExecutorService` 和 `ScheduledExecutorService` 两种任务执行器类型的 `submit` 或 `schedule` 等方法均可以通过传递一个 `Callable` 任务对象来返回一个表示异步计算结果的 `Future` 或 `ScheduledFuture` 对象. 通过 `Future` 对象可以取消其所绑定的任务, 获取任务执行状态, 以及获取任务执行结果.

```kotlin
val executor = Executors.newSingleThreadExecutor()
val callableTask = Callable {
    Thread.sleep(1000)
    "Callable 任务执行结果"
}
val future: Future<String> = executor.submit(callableTask)
println("任务执行结果: ${future.get()}")
executor.shutdown()

Thread 可以通过 FutureTask 将任务进行封装, 其可以同时作为 Runnable 任务对象和 Future 对象作为任务载体, 同时获取和控制线程状态.
val futureTask = FutureTask<String> {
    "Hello"
}
Thread(futureTask).start()
val result = futureTask.get()
```

### 不同任务线程间进行消息传递

在线程中通过 `Handler`、`MessageQueue` 和 `Looper` 实现在不同线程间传递消息和执行任务.

- `MessageQueue` 用于在线程内部存储待处理的消息 `Message` 和任务 `Runnable`. 一种基于单链表的数据结构实现的消息队列, 支持对内部 `Message` 的插入 `enqueueMessage`、取出 `next`、移除 `removeMessages` 等操作. 此外, `MessageQueue` 与 `Looper` 绑定, 当创建 `Looper` 时, 会自动创建一个 `MessageQueue` 对象, 并将其绑定到当前线程, 不需要手动创建.
- `Looper` 负责循环处理消息队列中的消息. 每个线程可以通过内部调用 `Looper.prepare()` 创建一个 `Looper` 对象, 并通过 `Looper.loop()` 方法启动消息处理循环, 注意只能创建一个 `Looper` 对象, 主线程默认已经创建了一个 `Looper` 对象. 启动消息处理循环后, `Looper` 会不断从消息队列中取出消息, 并将其分发给目标 `Handler` 处理, 直到消息队列为空. 未处理完成或手动退出消息处理循环前, 线程会一直处于阻塞状态.
- `Handler` 用于发送和处理消息 `Message` 和任务 `Runnable`. 每个线程可以有多个 `Handler` 对象, 但是每个 `Handler` 对象只能绑定到一个指定的 `Looper` 对象(默认为当前线程的 `Looper`). 通过 `Handler` 的 `sendMessage` 方法向绑定的 `Looper` 的消息队列中发送消息, 通过 `Handler` 的 `post` 方法向消息队列中发送任务. 支持消息的延迟发送.
- `Message` 用于封装消息内容, 包括 `arg1` 和 `arg2` 两个存储整数的参数、`obj` 存储接收者对象的引用、`what` 存储消息类型或用户定义的消息代码、`target` 存储消息接收者的 `Handler` 对象、`callback` 存储消息处理回调函数等.

```kotlin
import android.os.Handler
import android.os.Looper
import android.os.Message

fun main() {
    // 主线程的 Handler, 用于发送消息到后台线程
    val mainHandler = Handler(Looper.getMainLooper())

    val backgroundThread = BackgroundThread()
    backgroundThread.start()

    mainHandler.post {
        println("主线程发送消息到后台线程")
        val message = Message.obtain()
        message.what = 1
        message.obj = "Hello from the Main Thread!"
        backgroundThread.getHandler()?.sendMessage(message)
    }
}

class BackgroundThread : Thread() {
    private var backgroundHandler: Handler? = null

    override fun run() {
        Looper.prepare()
        backgroundHandler = MyHandler(Looper.myLooper()!!)
        Looper.loop()
    }

    fun getHandler(): Handler? {
        return backgroundHandler
    }
}

// 自定义后台线程的消息处理逻辑
class MyHandler(looper: Looper) : Handler(looper) {
    override fun handleMessage(msg: Message) {
        when (msg.what) {
            1 -> {
                println("后台线程处理消息: ${msg.obj}")
                val mainHandler = Handler(Looper.getMainLooper())
                mainHandler.post {
                    println("主线程收到消息: ${msg.obj}")
                }
            }
        }
    }
}


```

在线程中通过 `HandlerThread` 和 `Handler` 实现在不同线程间传递消息和执行任务.

- `HandlerThread` 是一个带有 `Looper` 的线程类, 用于在后台线程中执行任务和处理消息. `HandlerThread` 继承自 `Thread` 类, 通过 `Looper` 实现了消息循环处理机制, 可以通过 `getLooper()` 方法获取 `Looper` 对象, 通过 `quit()` 方法退出消息循环.
- `HandlerThread` 与 `Handler` 结合使用, 可以实现在后台线程中执行任务和处理消息, 通过 `HandlerThread` 的 `getLooper()` 方法获取 `Looper` 对象, 并通过 `Handler` 的构造方法传入 `Looper` 对象, 从而实现消息的发送和处理.

```kotlin
import android.os.Handler
import android.os.HandlerThread
import android.os.Looper
import android.os.Message

fun main() {
    // 主线程的 Handler, 用于发送消息到后台线程
    val mainHandler = Handler(Looper.getMainLooper())

    // 创建并启动 HandlerThread
    val backgroundThread = HandlerThread("BackgroundThread")
    backgroundThread.start()
    val backgroundHandler = Handler(backgroundThread.getLooper())

    //
    mainHandler.post {
        println("主线程发送消息到后台线程")
        val message = Message.obtain()
        message.what = 1
        message.obj = "Hello from the Main Thread!"
        backgroundHandler.sendMessage(message)
    }
}

class MyHandler(looper: Looper) : Handler(looper) {
    override fun handleMessage(msg: Message) {
        when (msg.what) {
            1 -> {
                println("后台线程处理消息: ${msg.obj}")
                // 处理完任务后, 将结果发送回主线程
                val mainHandler = Handler(Looper.getMainLooper())
                mainHandler.post {
                    println("主线程收到消息: ${msg.obj}")
                }
            }
        }
    }
}
```

## 路由框架

> [!Cite] > [ARouter](https://github.com/alibaba/ARouter) > [ActivityRouter](https://github.com/mzule/ActivityRouter) > [WMRouter](https://github.com/meituan/WMRouter) > [TheRouter](https://github.com/HuolalaTech/hll-wp-therouter-android) > [DRouter](https://github.com/didi/DRouter) > [BRouter](https://github.com/bilibili/BRouter) > [Custom Router](https://github.com/gdutxiaoxu/Router) > [Custom Router](https://github.com/waws80/Router) > [Custom Router](https://github.com/chenenyu/Router) > [Android 路由框架用法大全](https://juejin.cn/post/6984993972804550692) > [Android 组件化 —— 路由设计最佳实践](https://cloud.tencent.com/developer/article/1356515) > [Android 客户端路由框架的整理和思考](https://www.jianshu.com/p/15d8cc6cf19b) > [GRouter](https://github.com/taoweiji/grouter-android/)

| 功能模块             | ARouter 功能                                                   | 说明                                                             |
| -------------------- | -------------------------------------------------------------- | ---------------------------------------------------------------- |
| **页面跳转**         | 支持直接通过路径跳转到目标页面                                 | 通过 `@Route` 标注路径，简化跳转逻辑                             |
| **参数传递**         | 支持多种参数类型，包括基本数据类型、自定义对象等               | 参数通过 `@Autowired` 自动注入，简化开发                         |
| **转场动画**         | 支持跳转时自定义转场动画                                       | 可通过常规方式或 `ActivityOptionsCompat` 自定义动画              |
| **跳转拦截器**       | 可定义多个拦截器，按优先级执行                                 | 常用于登录检查、埋点等逻辑，简化重复代码                         |
| **全局降级策略**     | 自定义降级处理逻辑，支持页面未找到等情况                       | 降级策略提升用户体验，特别是路径失效或目标不存在时               |
| **服务注册与发现**   | 支持跨模块服务发现和依赖注入，模块间解耦                       | 通过 `@Route` 注解和 `IProvider` 接口实现服务发现                |
| **参数序列化**       | 支持自定义对象序列化，通过实现 `SerializationService` 接口实现 | 支持复杂数据结构和自定义对象的传递                               |
| **动态注册**         | 支持动态注册路由信息，适用于插件化架构                         | 通过 `addRouteGroup` 方法动态添加路由信息                        |
| **路径重写**         | 支持路径或 URL 的动态重写                                      | 通过实现 `PathReplaceService` 接口，对路径重写或重定向           |
| **自动生成文档**     | 支持自动生成路由文档                                           | 可生成 JSON 格式文档，用于团队协作                               |
| **多模块支持**       | 支持多模块工程，分组按需初始化                                 | 各模块的路由按组分类加载，节约资源                               |
| **Debug 与日志控制** | 支持调试模式和日志开关，便于开发调试                           | 可通过 `ARouter.openLog()` 和 `ARouter.openDebug()` 控制日志输出 |
| **增量编译**         | 支持增量编译，提高编译速度                                     | 可开启增量编译，但开启文档生成后会关闭增量编译                   |
| **IDE 插件支持**     | 提供 Android Studio 插件，便于路径跳转                         | 可通过 ARouter Helper 插件快速跳转到目标类，提高开发效率         |

### ARouter 解析

#### 设计理念

帮助 Android App 进行组件化改造, 支持模块间的路由、通信、解耦.

- 编译时基于注解处理器(apt)来生成路由表. 在每个组件的 build.gradle 文件中, 配置注解处理器的依赖和配置信息即可在编译时自动扫描组件内所有使用了预设注解(如 `@Route`)的类, 属性, 或方法, 然后根据注解中的信息生成一个路由表, 包含路径到目标类的映射关系和参数信息.
- 运行时基于反射机制创建目标类实例. 在运行时, 通过路由表中的路径信息获取到目标类的类名, 然后通过反射机制创建目标类的实例, 并将参数注入到目标类中, 最后调用目标类的方法.
- 支持 Activity, Fragment, Service, Provider, CONTENT_PROVIDER, BOARDCAST, METHOD 等多种路由类型.
- 支持直接解析标准 URL 进行跳转. 实现跨端统一跳转协议, 通过 URL 跳转到指定页面.
- 支持跳转时自定义转场动画. 实现多种场景下的转场动画.
- 支持定义多个拦截器, 按优先级顺序执行. 实现通过路径跳转到目标页面前的拦截处理, 常用于登录检查、埋点等逻辑, 简化重复代码.
- 支持自定义全局与局部降级处理逻辑. 实现当路径失效或目标不存在时的降级处理, 提升用户体验.
- 支持通过预设注解自动注入多种参数类型, 包括基本数据类型、自定义对象等. 实现通过路径跳转到目标页面, 无需手动解析传递的参数, 简化开发.
- 支持生成路由文档. 实现自动生成 JSON 格式文档, 用于团队协作.
- 支持增量编译(开启文档生成后无法增量编译).
- 提供 IDE 插件支持. 实现通过 ARouter Helper 插件快速跳转到目标类, 提高开发效率.
- 支持多模块工程. 实现路由按模块进行分组加载, 节约资源.

#### 使用介绍

- 添加依赖和配置

  ```gradle
  android {
      defaultConfig {
          ...
          javaCompileOptions {
              annotationProcessorOptions {
                  arguments = [AROUTER_MODULE_NAME: project.getName()]
              }
          }
      }
  }
  dependencies {
      implementation 'com.alibaba:arouter-api:1.5.1'
      kapt 'com.alibaba:arouter-compiler:1.2.2'
  }
  ```

- 在需要跳转的 Activity 上添加注解

  ```kotlin
  @Route(path = "/test/activity")
  class TestActivity : AppCompatActivity() {
      ...
  }
  ```

- 添加可传递参数

  ```kotlin
  @Route(path = "/test/activity")
  class TestActivity : AppCompatActivity() {
      @Autowired
      var name: String? = null
  
      // 自定义映射关系
      @Autowired(name = "girl")
      var boy: String? = null
  
      // json 与 object 映射(需要对象实现 Parcelable 接口)
      @Autowired
      var obj: TestObj? = null
      var map: Map<String, String>? = null
      var list: List<TestObj>? = null
  
      override fun onCreate(savedInstanceState: Bundle?) {
          super.onCreate(savedInstanceState)
          ARouter.getInstance().inject(this) // 自动注入参数
      }
  }
  ```

- 使用拦截器

  ```kotlin
  @Interceptor(priority = 1, name = "TestInterceptor")
  class TestInterceptor : IInterceptor {
      override fun process(postcard: Postcard, callback: InterceptorCallback) {
          // 拦截器处理逻辑
          callback.onContinue(postcard)
      }
  
      override fun init(context: Context) {
          // 拦截器的初始化，会在sdk初始化的时候调用该方法，仅会调用一次
      }
  }
  ```

- 自定义全局降级策略

  ```kotlin
  @Route(path = "/service/degrade")
  public class DegradeServiceImpl implements DegradeService {
  
      @Override
      public void onLost(Context context, Postcard postcard) {
          // 当找不到页面时执行的操作，例如跳转到一个错误页面或提示
      }
  
      @Override
      public void init(Context context) {
          // 初始化代码，可以为空
      }
  }
  ```

- 在 Application 中初始化 ARouter

  ```kotlin
  class App : Application() {
      override fun onCreate() {
          super.onCreate()
          ARouter.init(this)
      }
  }
  ```

- 跳转到指定 Activity

  ```kotlin
  // 简单跳转
  ARouter.getInstance().build("/test/activity").navigation()
  // 携带参数跳转
  ARouter.getInstance().build("/test/activity")
      .withString("key", "value")
      .navigation()
  // 通过类型跳转
  ARouter.getInstance().navigation(TestActivity::class.java)
  ```

#### 源码解析

##### 前置知识

- `编译期元数据` 是指在编译时生成的元数据, 用于描述源代码的结构和信息, 通常用于代码生成、代码检查、代码优化等场景.

    - `SourceVersion` 枚举表示 Java 语言的版本, 通常用于判断当前编译环境支持的 `Java` 版本。
    - `Elements` 是 Java 编译器提供的是一个工具接口, 提供了一系列用于获取和操作源代码元素信息的便捷方法, 包括类、方法、字段、注解等.

        - `TypeMirror` 是 Java 编译器提供的一个接口, 用于表示 Java 类型, 包括基本数据类型、数组、泛型、通配符、类型变量、方法类型等.
        - `getEnclosedElements` 方法用于获取指定元素直接包含的子元素, 如类或接口的字段、方法、构造函数和内部类型; 包的顶级类和接口; 模块的包。
        - `getEnclosingElement` 方法用于获取当前元素的直接上层结构, 如类的包、方法的类、字段的类等.

    - `Types` 是 Java 编译器提供的一个工具接口, 提供了对 Java 类型(如类、接口、枚举等)进行分析、比较、转换等操作的方法.

- `AnnotationProcessor` 是 Java 编译器的一个工具, 用于在编译时扫描和处理注解.

    - `AbstractProcessor` 是所有注解处理器的基类. 编写自定义注解处理器时继承该类, 并实现 `process` 方法即可在编译期间实现自定义的注解处理逻辑.
    - `Filer` 注解处理工具中提供的一个接口, 用于创建新文件、类文件、资源文件等.

        - `Writer` 是 Java IO 提供的一个抽象类, 用于写入字符流, 如 json 文件.

    - `Messager` 是注解处理工具中提供的一个接口, 用于输出信息、警告、错误等.
    - Options: `Map<String,String>` 是传递给注解处理器的配置参数信息.
    - `ProcessingEnvironment` 是传递给注解处理器的编译时环境信息, 可以通过该对象获取到 `Filer`、`Elements`、`Types` 等工具对象.
    - 注解处理器的处理是分轮次（round）进行的, 每轮都会重复调用 process 方法. 第一轮编译器扫描所有源文件, 并调用 process 方法, 之后判断当前轮次是否有新的源文件生成, 如果有则继续扫描, 否则结束处理.

- `AutoService` 是 Google 提供的一个库, 用于简化 `AnnotationProcessor` 的 SPI(Service Provider Interface) 注册.
- `JavaPoet` 是一个用于生成 Java 源代码的库, 通过 `JavaPoet` 可以在编译时生成 Java 代码, 用于生成路由表.

    - `ClassName` 用于表示类名, 如 `com.alibaba.arouter.facade.annotation.Route`.
    - `ParameterizedTypeName` 用于表示类型, 如 List`<String>`、Map<String, Integer> 等.
    - `ParameterSpec` 用于表示方法参数, 可以通过 `ParameterizedTypeName` 指定类型.
    - `MethodSpec` 用于表示方法, 可以通过 `ParameterSpec` 指定方法参数.

- 反射机制: Java 提供的用于在运行时获取类的信息、属性、方法、构造方法等, 并通过反射机制调用类的方法、获取属性值等.

    - `Class` 类用于表示类的信息, 包括类名、属性、方法、构造方法等.
    - `Field` 类用于表示类的属性信息, 包括属性名、属性类型、属性值等.
    - `Method` 类用于表示类的方法信息, 包括方法名、方法参数、方法返回值等.
    - `Constructor` 类用于表示类的构造方法信息, 包括构造方法参数、构造方法访问修饰符等.

##### arouter-annotation

声明了 ARouter 框架中使用的注解类型和一些枚举类

- `@Route(path: String, group: String = "", name: String = "", extras: Int = 0, priority: Int = -1)` 用于标注路由路径信息.
- `@Autowired(name: String = "", required: Boolean = false, desc: String = "")` 用于标注目的对象内部的属性, 用于自动注入参数.
- `@Interceptor(priority: Int, name: String = "")` 用于标注拦截器信息.
- `RouteType` 枚举类, 用于定义路由类型.

    - `ACTIVITY`, `FRAGMENT`: 页面路由类型, 用于打开某个页面.
    - `SERVICE`: 后台服务路由类型, 用于打开某个需要后台运行的服务.
    - `PROVIDER`: 接口服务提供者路由类型, 用于获取某个接口的具体实现.
    - `ContentProvider`: 内容提供者路由类型, 用于获取某个内容提供者的实例. 内容提供者可以提供数据给其他应用程序.
    - `BOARDCAST`: 广播路由类型, 用于发送广播.
    - `METHOD`: 方法路由类型, 用于调用某个方法.

- `RouteMeta` 数据类, 用于封装路由信息, 包括路径、组、名称、类型、优先级、降级策略、拦截器、参数等信息.

    - `type: RouteType`: 路由类型.
    - `rawType: Element`: 路由目标类原始信息
    - `destination: Class<?>`: 路由目标类具体
    - `path: String`: 路由跳转路径, 为 `@Route` 注解中的 `path` 属性.
    - `group: String`: 路由路径所在组, 一般为默认组(路径第一个 `/` 后的字符串, 没有则分组为 null).
    - `priority: int`: 路由优先级.
    - `extra: int`: 路由附加信息.
    - `paramsType: Map<String, Integer>`: 路由注入的所有参数类型.
    - `name: String`: 路由名称.
    - `injectConfig: Map<String, Autowired>`: 路由注入的所有参数配置.

- `TypeKind` 枚举类, 用于定义所支持的自动注入参数类型.
    - 基本类型: `BOOLEAN`, `BYTE`, `SHORT`, `INT`, `LONG`, `CHAR`, `FLOAT`, `DOUBLE`.
    - 其他类型: `STRING`, `SERIALIZABLE`, `PARCELABLE`, `OBJECT`.

##### arouter-compiler

实现了注解处理器, 用于在编译时扫描组件内所有使用了预设注解的类, 属性, 或方法, 然后根据注解中的信息生成一个路由表, 包含路径到目标类的映射关系和参数信息.

项目中要处理注解自动生成路由表代码, 则必须依赖 `arouter-compiler` 模块, 并在 `build.gradle` 文件中配置 `kapt` 插件. 以下是 `arouter-compiler` 中包含的注解处理器:

- `AutowiredProcessor` 支持解析 `@Autowired` 注解.
- `InterceptorProcessor` 支持解析 `@Interceptor` 注解.
- `RouteProcessor` 支持解析 `@Route` 和 `@Autowired` 注解.

注解处理器的处理顺序: `AutowiredProcessor` -> `InterceptorProcessor` -> `RouteProcessor`.

注解处理时分模块处理, 区分模块采用 `build.gradle` 文件中的 `AROUTER_MODULE_NAME` 参数定义的模块名称.

```gradle
javaCompileOptions {
    annotationProcessorOptions {
        arguments = [AROUTER_MODULE_NAME: project.getName(), AROUTER_GENERATE_DOC: "enable"]
    }
}
```

支持生成路由文档, 通过 `AROUTER_GENERATE_DOC` 参数开启文档生成. 最终生成的文档是一个 JSON 格式的文件, 包含了所有模块的路由信息. 文档生成的路径是在 `build/generated/source/apt` 目录下. 文件名为 `arouter-map-of-模块名.json`. 详细怎么生成的本文不进行讲解.

###### AutowiredProcessor

`@Autowired` 注解用于标注目的对象内部的属性, 用于自动注入参数. 注意点如下:

- 仅支持为 Activity, Fragment 类型的目的对象内部注入基本数据类型、自定义对象、集合类型、IProvider 类型等.
- IProvider 类型的参数注入默认通过其实际类类型(直接实现)或其接口类型(间接实现)来获取实例, 也可以通过 `@Autowired` 注解的 `name` 属性来指定实例名称, 用于区分同一接口的不同实现.
- 参数注入需要 `SerializationService` 服务支持, 用于序列化和反序列化参数. 内部已经有一个默认实现了, 也可以通过实现 `SerializationService` 接口和添加 `@Route` 注解来自定义序列化服务.

`AutowiredProcessor` 是 `@Autowired` 的注解处理器, 其最终目的是为每个需要注入参数的类型生成一个帮助类, 用于自动注入参数.

参数注入的注解处理过程主要分为两个步骤:

- 第一步是扫描所有使用了 `@Autowired` 注解的元素, 并根据元素的上层结构分类存储到内存中.

  ```java
  // 获取所有使用了 @Autowired 注解的元素
  Map<TypeElement, List<Element>> parentAndChild; // 用于存储父元素和子元素的映射关系
  Set<? extends Element> autowiredElements = roundEnv.getElementsAnnotatedWith(Autowired.class);
  for (Element element : autowiredElements) {
      TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
      List<Element> elements = autowiredMap.get(enclosingElement);
      parentAndChild[enclosingElement].add(element);
  }
  ```

- 第二步是为每个需要注入参数的类型生成一个帮助类, 用于自动注入参数.

  ```java
  // 遍历所有需要注入参数的类型, 生成帮助类
  for (parentElement, childElements : parentAndChild) {
      MethodSpec.Builder injectMethodBuilder: PUBLIC Override inject(Object target) // 统一注入方法的构造器
  
      injectMethodBuilder.addStatement("serializationService = ARouter.getInstance().navigation(SerializationService.class)"); // 内置序列化服务实现.
      injectMethodBuilder.addStatement("$T t = ($T)target", ClassName.get(parent), ClassName.get(parent)); // 强制类型转换为目标类型.
  
      // 生成注入代码
      for (Element element : childElements) {
          Autowired fieldConfig = element.getAnnotation(Autowired.class);
          String fieldName = element.getSimpleName().toString();
          String name = autowired.name();
          boolean required = autowired.required();
          String desc = autowired.desc();
          // iProvider 类型的参数注入时可以选择是否指定实例名称来支持多实现注入. 因此需要额外处理.
          when element is iProvider : 
              if (name.isEmpty()) {
                  injectMethodBuilder.addStatement(
                      "substitute." + fieldName + " = ARouter.getInstance().navigation($T.class)",
                      ClassName.get(element.asType())
                  );
                  // 示例: substitute.testProvider = ARouter.getInstance().navigation(TestProvider.class);
              } else {
                  injectMethodBuilder.addStatement(
                      "substitute." + fieldName + " = ($T)ARouter.getInstance().build($S).navigation()",
                      ClassName.get(element.asType()),
                      fieldConfig.name()
                  );
                  // 示例: substitute.testProvider = (TestProvider)ARouter.getInstance().build("testProvider").navigation();
              }
              // 判断是否必须注入, 必须则需要添加非空判断代码
              if (fieldConfig.required()) {
                  injectMethodBuilder.beginControlFlow("if (substitute." + fieldName + " == null)");
                  injectMethodBuilder.addStatement(
                      "throw new RuntimeException(\"The field '" + fieldName + "' is null, in class '\" + $T.class.getName() + \"!\")", ClassName.get(parent));
                      injectMethodBuilder.endControlFlow();
              }
              // 示例: if (substitute.testProvider == null) throw new RuntimeException("The field 'testProvider' is null, in class 'com.xxx.TestActivity'!");   
          when other:
              // 其他类型的参数注入
              String statement = "substitute." + fieldName + " = (${ClassName.get(element.asType())})" + "substitute."; // 这里强制类型转换其实只有 Serializable 类型需要, 其他类型都是自动转换的.
              when parentElement is Activity:
                  statement += "getIntent().";
              when parentElement is Fragment:
                  statement += "getArguments().";
              
              // 然后根据参数类型生成不同的注入代码
              when element.asType() is BOOLEAN:
                  statement += "getBoolean" + (isActivity ? "Extra" : "") + "($S, " + "substitute." + fieldName + ")";
                  injectMethodBuilder.addStatement(statement, StringUtils.isEmpty(fieldConfig.name()) ? fieldName : fieldConfig.name());
                  // 示例: substitute.testBoolean = substitute.getIntent().getBooleanExtra("testBoolean", substitute.testBoolean);
                  // 示例: substitute.name = substitute.getIntent().getExtras() == null ? substitute.name : substitute.getIntent().getExtras().getString("name", substitute.name);
              ...
              when element.asType() is OBJECT:
                  statement = "serializationService.parseObject(substitute." + (isActivity ? "getIntent()." : "getArguments().") + (isActivity ? "getStringExtra($S)" : "getString($S)") + ", new " + ".TypeWrapper" + "<$T>(){}.getType())";
                  // 如果解析的是对象类型, 需要额外添加一个 TypeWrapper 类型, 用于获取对象的类型信息.
                  injectMethodBuilder.beginControlFlow("if (null != serializationService)");
                  injectMethodBuilder.addStatement(
                      "substitute." + fieldName + " = " + statement,
                      (StringUtils.isEmpty(fieldConfig.name()) ? fieldName : fieldConfig.name()),
                      ClassName.get(element.asType())
                  );
                  injectMethodBuilder.nextControlFlow("else");
                  injectMethodBuilder.addStatement(
                      "$T.e(\"" + Consts.TAG + "\", \"You want automatic inject the field '" + fieldName + "' in class '$T' , then you should implement 'SerializationService' to support object auto inject!\")", AndroidLog, ClassName.get(parent));
                  injectMethodBuilder.endControlFlow();
                  // 示例: substitute.obj = serializationService.parseObject(substitute.getIntent().getStringExtra("obj"), new TypeWrapper<TestObj>(){}.getType());
              // 判断是否必须注入, 必须则需要添加非空判断代码
              if (fieldConfig.required()) {
                  ...
              }
              
      // 生成注入帮助类代码, 包含注入参数的帮助方法和用于序列化和反序列化参数的服务实现.
      TypeSpec.Builder helper = TypeSpec.classBuilder(parent.getSimpleName() + "$$ARouter$$Autowired")
          .addSuperinterface(ClassName.get(ISyringe))
          .addModifiers(PUBLIC);
      FieldSpec jsonServiceField = FieldSpec.builder(TypeName.get(SerializationService.asType()), "serializationService", Modifier.PRIVATE).build();
      helper.addField(jsonServiceField);
      helper.addMethod(injectMethodBuilder.build());
      // 生成帮助类文件
      // packageName 与 parentElement 的包名相同
      avaFile.builder(packageName, helper.build()).build().writeTo(mFiler);
      }
  }
  ```

###### InterceptorProcessor

`@Interceptor` 注解用于标注拦截器信息. 注意点如下:

- 拦截器注解只支持标注实现了 `IInterceptor` 接口的类型.
- 拦截器的优先级用于标识拦截器的执行顺序, 数值越小优先级越高. 不能出现相同优先级的拦截器.

`InterceptorProcessor` 是 `@Interceptor` 的注解处理器, 其最终目的是生成一个拦截器表, 实际是一个类文件, 包含了所有拦截器信息的映射关系.

拦截器表的生成过程主要分为两个步骤:

- 第一步是扫描所有使用了 `@Interceptor` 注解的类, 并将其拦截器信息存储到内存中.
- 根据拦截器的优先级排序, 生成一个拦截器表, 包含了所有拦截器的映射关系.

大概生成的类文件如下:

```java
public class ARouter$$Interceptors$$ModuleName implements IInterceptorGroup {
    @Override
    public void loadInto(Map<Integer, Class<? extends IInterceptor>> interceptors) {
        interceptors.put(7, Test1Interceptor.class);
        interceptors.put(90, TestInterceptor90.class);
    }
}
```

###### RouteProcessor

`@Route` 注解用于位支持类标注其路由信息(如路径、组、名称、优先级、附加标志位). 注意点如下:

- 路由注解只支持标注类, 包括 Activity, Fragment, Service, IProvider 类型.
- 路由信息必须包含路径信息, 同时以 `/` 开头.
- 路由信息的组信息用于模块内分组加载路由信息, 不提供则要求路径至少包含两级, 采用第一级作为组名.
- Activity 和 Fragment 额外支持 `@Autowired` 注解实现自动注入目的对象内部的属性值. 因此处理时需要额外处理 `@Autowired` 注解.

`RouteProcessor` 是 `@Route` 的注解处理器, 其最终目的是生成一个路由表, 实际是多个类文件, 包含了所有路由信息的映射关系和参数信息.

路由表的生成需要分模块和分组处理, 也就是两级映射和加载关系. 分模块确保模块之间的解耦, 方便单独开发. 分组则是为了按需加载(延迟加载)路由信息, 节约资源.

- 每个模块内部都会生成两个根映射表, 名称是 `ARouter$$Root$$模块名` 和 `ARouter$$Providers$$模块名`, 其内部分别包含了所有路由组到组内映射表的映射关系, 以及所有路由路径到 IProvider 类型的映射关系.
- 每个组内部都会生成一个组内映射表, 名称是 `ARouter$$Group$$组名`, 其内部包含了所有路由路径到对应目标类类型的映射关系.

所有根映射表和组内映射表共同构成了一个完整的路由表. 在 app 内初始化 ARouter 时, 会依次加载所有模块的根映射表, 然后根据根映射表中的组名加载对应的组内映射表, 最终获取到所有的从路径到目标类信息的映射关系, 用于后续的路由跳转(基于反射机制创建目标类实例).

路由表的生成过程主要分为两个步骤:

- 第一步是扫描所有使用了 `@Route` 注解的类, 并将其路由信息存储到内存中.

    - `groupMap: Map<String, List<RouteMeta>>` 用于分组存储不同组和其内包含的路由信息. <组名, 组内路由信息列表>
    - `rootMap: Map<String, String>` 用于存储根路由信息, 用于生成类文件时的顺序. <组名, 组内映射表类名>
    - `process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv)` 方法, 用于处理注解.

        - `annotations` 包含了本轮处理器感兴趣的注解类型集合. 每个 TypeElement 代表一个注解类型, 通过此信息可以从 roundEnv 中查找对应的元素.
        - `roundEnv` 提供了当前编译轮次的上下文信息, 可以通过它查询使用了特定注解的类、方法、字段等元素.

  ```java
  // 获取所有使用了 @Route 注解的元素
  Set<? extends Element> routeElements = roundEnv.getElementsAnnotatedWith(Route.class);
  
  // 分组存储所有的路由信息
  for (element : routeElements) {
      TypeMirror elementType; // 获取元素的类型
      Route routeAnnotation; // 获取元素的注解
      RouteMeta routeMeta; // 创建元素对应的路由信息
  
      when elementType is Activity or Fragment:
          Map<String, Integer> paramsType; // 存储所有要注入的参数的类型
          Map<String, Autowired> injectConfig; // 存储所有要注入的参数的配置(如名称、是否必须, 描述)
          injectParamCollector(element, paramsType, injectConfig); // 递归收集所有要注入的参数信息, 分别存储在 paramsType 和 injectConfig 中.
  
          routeMeta = new RouteMeta(route, element, ACTIVITY or Fragment, paramsType, injectConfig);
      when other(iProvider, Service) as type:
          routeMeta = new RouteMeta(route, element, iProvider or Service);
  
      groupMap[routeMeta.group()].add(routeMeta); // 这里每组的 routeMeta 按路径顺序存储
  }
  ```

- 第二步是根据内存中的路由信息生成路由表(根映射表和组内映射表), 并写入到类文件中, 所有类文件统一组织到一个包路径下.

  ```java
  
  // 生成根映射表类文件包括两种: ARouter$$Root$$模块名
  MethodSpec.Builder loadIntoMethodOfProviderBuilder: PUBLIC Override loadInto(Map<String, RouteMeta> providers) // 用于加载 IProvider 类型的路由信息的 loadInto 方法构造器
  MethodSpec.Builder loadIntoMethodOfRootBuilder: PUBLIC Override loadInto(Map<String, Class<? extends IRouteGroup>> routes) // 用于加载组内映射表的 loadInto 方法构造器
  
  // 分组生成组内映射表
  for (groupName, routeMetas in groupMap):
      MethodSpec.Builder loadIntoMethodOfGroupBuilder: PUBLIC Override loadInto(Map<String, RouteMeta> atlas) // 组内映射表内部用于加载路由信息的 loadInto 方法构造器
      for (routeMeta in routeMetas):
          ClassName className = ClassName.get(routeMeta.getRawType()) // 获取元素类型的类名
          
          // 原项目额外对直接实现 IProvider 接口, 还是实现 IProvider 的子接口进行了区分
          // 这里的处理方式会导致子接口的实现类只能有一个, 难以理解为什么要这么做.
          when routeMeta.getType():
              implement iProvider: 
                  loadIntoMethodOfProviderBuilder.addStatement(
                      "providers.put($S, $T.build($T." + routeMeta.getType() + ", $T.class, $S, $S, null, " + routeMeta.getPriority() + ", " + routeMeta.getExtra() + "))",
                      (routeMeta.getRawType()).toString(),
                      RouteMeta.class,
                      RouteType.class,
                      className,
                      routeMeta.getPath(),
                      routeMeta.getGroup());
              implement subInterface of iProvider:
                  loadIntoMethodOfProviderBuilder.addStatement(
                      ... // 同上
                      subInterface.toString(),
                      ... // 同上
                  );
                  // 示例: providers.put("com.alibaba.android.arouter.demo.testservice.HelloService", RouteMeta.build(RouteType.PROVIDER, HelloService.class, "/service/hello", "service", null, -1, -2147483648));
          
          // 生成支持自动注入的参数类型映射表: Map<String, TypeKind>
          Map<String, Integer> paramsType = routeMeta.getParamsType();
          String paramsTypeMapBody = ""
          for (name, type in paramsType):
              paramsTypeMapBody += "put(\"" + name + "\", " + type + "); "
              // 示例: put("name", 8); put("age", 3);
          
          loadIntoMethodOfGroupBuilder.addStatement(
              "atlas.put($S, $T.build($T." + routeMeta.getType() + ", $T.class, $S, $S, " + (StringUtils.isEmpty(paramsTypeMapBody) ? null : ("new java.util.HashMap<String, Integer>(){{" + paramsTypeMapBody + "}}")) + ", " + routeMeta.getPriority() + ", " + routeMeta.getExtra() + "))",
              routeMeta.getPath(),
              RouteMeta.class,
              RouteType.class,
              className,
              routeMeta.getPath().toLowerCase(),
              routeMeta.getGroup().toLowerCase());
          // 示例: atlas.put("/kotlin/test", RouteMeta.build(RouteType.ACTIVITY, KotlinTestActivity.class, "/kotlin/test", "kotlin", new java.util.HashMap<String, Integer>(){{put("name", 8); put("age", 3); }}, -1, -2147483648));
  
      // 生成最终的组内映射表类文件
      String groupFileName = "ARouter$$Group$$" + groupName;
      JavaFile.builder("com.alibaba.android.arouter.routes", 
          TypeSpec.classBuilder(groupFileName)
              .addSuperinterface(ClassName.get(IRouteGroup.class))
              .addModifiers(Modifier.PUBLIC)
              .addMethod(loadIntoMethodOfGroupBuilder.build())
              .build()
          )
          .build()
          .writeTo(filer);
      // 示例: 
      // package com.alibaba.android.arouter.routes;
      // public class ARouter$$Group$$kotlin implements IRouteGroup {
      //      @Overridepublic void loadInto(Map<String, RouteMeta> atlas) { ... }
      // }
  
      // 缓存根映射表信息
      rootMap.put(groupName, groupFileName);
  
  // 生成根映射表类文件
  for (groupName, groupFileName in rootMap):
      loadIntoMethodOfRootBuilder.addStatement("routes.put($S, $T.class)", entry.getKey(), ClassName.get("com.alibaba.android.arouter.routes", entry.getValue()));
  
  // Provider 的根映射表类文件
  JavaFile.builder("com.alibaba.android.arouter.routes",
      TypeSpec.classBuilder("ARouter$$Providers$$" + moduleName)
          .addSuperinterface(ClassName.get(IProviderGroup.class))
          .addModifiers(Modifier.PUBLIC)
          .addMethod(loadIntoMethodOfProviderBuilder.build())
          .build()
      )
      .build()
      .writeTo(filer);
  
  // Root 的根映射表类文件
  JavaFile.builder("com.alibaba.android.arouter.routes",
      TypeSpec.classBuilder("ARouter$$Root$$" + moduleName)
          .addSuperinterface(ClassName.get(IRouteRoot.class))
          .addModifiers(Modifier.PUBLIC)
          .addMethod(loadIntoMethodOfRootBuilder.build())
          .build()
      )
      .build()
      .writeTo(filer);
                  
  ```

##### arouter-api

ARouter 框架对外暴露的核心类, 用于提供路由表的加载和路由跳转功能. 主要包含以下几个部分(按照包含顺序):

- `ARouter` 类: 单例类, 提供对外暴露给使用者的 API 接口
    - `_ARouter` 类: 单例类, `ARouter` 类中所有接口的代理功能实现类.
        - `LogisticsCenter` 类: 路由表的中心类, 用于加载路由表, 并提供路由跳转的方法.

`ARouter` 对外主要暴露了以下几个主要功能(按照可调用顺序):

- `init` 方法: 线程安全, 初始化 ARouter 框架, 加载路由表(实际加载由 `LogisticsCenter` 执行)
    - `getInstance` 方法: 双检锁获取 ARouter 单例对象实例.
        - `build` 方法: 构造路由请求信息载体类, 用于后续的页面跳转或服务调用, 支持通过 path 和 Uri 进行构建.
            - build 过程支持首先通过注册的 `PathReplaceService` 类型服务对 `path` 或 `Uri` 进行预处理. 默认无此实现.
            - 最终返回一个 `Postcard` 对象, 其内部包含了当前路由请求的所有信息.
            - 后续可以继续通过 `Postcard` 对象进行其他路由参数的设置, 如???.
        - `navigation(service) -> T` 方法: 不需要 path, 直接通过继承自 IProvider 的接口类型获取对应的实现类.
            - 首先通过 `LogisticsCenter` 根据接口类型的名称, 通过`buildProvider` 和 `completion` 内部构造一个 `Postcard` 对象, 包含完整的路由信息.
            - 然后通过 `Postcard` 对象调用 `getProvider` 方法获取对应的实现类.
        - `navigation(context, postcard, requestCode, callback) -> Object` 方法: 通过构造的 Postcard 对象进行跳转.
            - 第一步支持使用注册的预处理服务 `PretreatmentService` 确认是否需要跳转.
            - 第二步通过 `LogisticsCenter` 的 `completion` 方法完成路由路径的加载. 这里支持加载失败时通过注册的 `DegradeService` 降级服务进行降级处理.
            - 第三步通过 `InterceptorService` 服务执行所有的拦截器, 并在拦截器执行完成后执行路由跳转.
                - `ACTIVITY` 类型的路由跳转通过 `startActivity` 方法进行跳转, 支持结果回调, 转场动画, 额外参数等.
                - `PROVIDER` 类型的路由跳转可以直接获取对应的实现类.
                - `BOARDCAST|CONTENT_PROVIDER|FRAGMENT` 类型的路由跳转直接返回实际对象, FRAGMENT会注入额外的参数.
                - `METHOD|SERVICE` 类型的路由不支持, 直接返回 null.
        - `addRouteGroup` 方法: 动态添加路由组信息, 一般用于按需加载插件时使用.
        - `inject` 方法: 通常在需要注入参数的对象中调用, 实现为当前对象自动注入参数.
            - 方法通过固定 `path` 获取 `AutowiredService` 接口的实现类.
            - 基础实现见 `AutowiredServiceImpl` 类, 此类通过利用自动生成的注入帮助类(见 `@Autowired` 注解处理过程)实现自动注入参数.
            - 注入过程是递归的, 会递归注入目的对象及其父类的可支持注入的所有属性.
            - 注入参数来自于路由 `Postcard` 对象通过 `with` 或 `withXxx` 方法设置的参数.

`LogisticsCenter` 类主要提供了以下几个功能:

- `init` 方法: 加载所有本地路由表到内存中.
    - 加载原理 1: 运行时通过 DexFile 加载 dex 文件中的所有类名, 并通过反射加载路由表.
        - 首先通过 apk 文件, 以及 Android5.0 以下 secondary-dexes 文件夹下所有的额外的 dex 文件压缩包文件去获取 dex 文件的路径.
        - 然后通过 DexFile 类加载 dex 文件, 获取 dex 文件中所有的类名, 并过滤掉不符合要求的类名, 即不包含指定包名的类名. (java最终生成类文件的类名是包名 + 代码类名)
        - 缓存所有的类名, 用于后续的路由表通过缓存加速加载.
        - 遍历所有的类名, 分种类(`IRouteRoot`, `IInterceptorGroup`, `IProviderGroup`)的通过反射构造对应类对象, 并调用其 `loadInto` 方法加载路由表到 Warehouse 的全局静态变量中(即内存中的路由表). 注意此时加载的仅是根映射表, 服务提供者, 拦截器提供者的类信息映射关系. 完整的加载会在后续的路由跳转时按需进行.
    - 加载原理 2: 编译时通过 `arouter-auto-register` 插件生成的 `loadRouterMap` 方法加载路由表.
- `buildProvider` 方法: 根据接口类型的全名或小名获取对应的实现类.
    - 首先通过接口类型的名称从内存中的路由表中获取对应的 `RouteMeta` 对象.
    - 然后通过 `RouteMeta` 对象存有的目标类类型信息构造 `Postcard` 对象.
- `completion` 方法: 通过 `Postcard` 对象完成整体路由路径上的所有信息的加载.
    - 首先通过 `Postcard` 对象获取路由路径所在组, 并通过组名加载对应的组内映射表.
    - 然后通过组内映射表获取对应的目标的 `RouteMeta` 对象, 利用其存储的路由信息和目标类类型信息继续完善 `Postcard` 对象. 注意, 这里包含 uri 中 Query 参数的解析(仅支持可注入参数)和 provider 的构建.

`Postcard` 类: 路由请求的载体类, 扩展了 `RouteMeta`, 用于进一步封装路由请求的所有信息.

- 参数 (`ARouter` 的 `build` 路由请求构造过程可选手动设置的参数):
    - `path: String`: 路由跳转路径, 一般为 `@Route` 注解中的 `path` 属性或 `Uri` 对象的 `path` 属性.
    - `group: String`: 路由路径所在组, 一般为默认组(路径第一个 `/` 后的字符串, 没有则分组为 null).
    - `uri: Uri`: 路由跳转的 Uri, 一般用于深度链接跳转内部页面, 其 `path` 属性为路由跳转路径, 其他属性待定.
    - `mBundle: Bundle`: 路由跳转时要传递给目标对象的参数, 可以通过 `with` 或 `withXxx` 方法设置参数.
    - `timeout: Long`: 路由跳转超时时间, 默认用于控制设置的拦截器执行的超时时间.
    - `greenChannel: Boolean`: 是否使用绿色通道, 用于跳过拦截器.
    - `flags: Int`: 用于控制 Activity 类型路由请求的行为标志位, 如 `FLAG_ACTIVITY_NEW_TASK` 等.
    - `enterAnim: Int | exitAnim: Int`: 用于控制 Activity 类型路由请求的进入和退出动画效果.
    - `optionsCompat: ActivityOptionsCompat`: 用于控制 Activity 类型路由请求的转场动画效果, 仅在 Android 5.0 以上有效.
    - `action: String`: 用于控制 Activity 类型路由请求的行为, 如 `Intent.ACTION_VIEW` 等.
- 参数(`ARouter` 的 `navigation` 过程自动设置的参数):
    - `type: RouteType`: 路由类型.
    - `rawType: Element`: 路由目标类原始信息
    - `destination: Class<?>`: 路由目标类具体
    - `priority: int`: 路由优先级.
    - `extra: int`: 路由附加信息.
    - `paramsType: Map<String, Integer>`: 路由注入的所有参数类型.
    - `name: String`: 路由名称.
    - `injectConfig: Map<String, Autowired>`: 路由注入的所有参数配置.
    - `provider: IProvider`: 存储 IProvider 类型的实现类, 会由 `LogisticsCenter` 自动加载.
    - `serializationService: SerializationService`: 序列化服务, 用于序列化和反序列化参数.
    - `context: Context`: 路由请求的上下文.
- `navigation(__)` 类型方法, 用于发起由 `path` 或 `Uri` 构造的路由请求, 支持返回对象实例和回调等.
    - 实际路由跳转过程主要是通过 `ARouter` 的 `navigation(context, ...)` 方法实现.

##### arouter-gradle-plugin

## 插件化框架

插件化框架的核心目标是在原有 app 的基础上, 实现动态加载一个或多个插件(独立 apk 或 jar 文件), 并在 app 中使用插件中的功能和资源. 独立出来的插件可以单独进行开发, 测试, 发布, 升级等流程, 从而实现一些比较重要的功能, 如模块化开发, 动态更新, 热修复, 功能扩展等功能.

因为涉及到 app 和插件之间的交互, 所以插件化框架的实现一般需要解决以下几个问题(不同的插件化框架可能会有不同的实现方式):

- 插件代码加载
- 系统组件注册
- 资源加载
- 插件和宿主, 以及插件和插件之间的通信

### RePlugin 解析

360 开源的一个 Android 插件化框架.

#### 设计理念

- 插件代码加载: 通过类加载器 `ClassLoader` 实现插件的加载和卸载.
- 系统组件注册: 通过坑位组件实现插件中的组件(如 Activity)的注册.
- 资源加载: 

#### 使用介绍

#### 源码解析

RePlugin 包含编译时和运行时两部分, 同时又区分了宿主和插件两种不同的角色. 编译时宿主会通过 `replugin-host-gradle` 插件自动生成插件化框架所需的配置文件, 插件信息, 辅助类文件等. 运行时宿主会通过 `replugin-host-lib` 模块加载插件, 并实现插件的加载, 卸载, 组件注册, 资源加载等操作.

##### 前置知识

> [!cite]
> ![[Gradle#Gradle 插件开发|Gradle 插件开发]]
> Android Binder 通信机制
> Android ClassLoader 原理
> Android 四大组件启动流程

##### replugin-host-gradle (宿主插件)

##### replugin-host-lib (宿主库)

##### replugin-plugin-gradle (插件插件)

##### replugin-plugin-lib (插件库)
