---
tags:
title: 安卓开发
description: ""
author: ""
categories: ""
keywords:
  - ""
draft: true
layout: ""
date: 2024-07-31 10:44:21
lastmod: 2024-08-12 13:47:23
---

> [!todo] > [https://developer.android.com/courses/android-basics-compose/course](https://developer.android.com/courses/android-basics-compose/course) > [https://developer.android.com/courses/unit/kotlin-basics-unit-1](https://developer.android.com/courses/unit/kotlin-basics-unit-1) > [https://www.geeksforgeeks.org/kotlin-android-tutorial/](https://www.geeksforgeeks.org/kotlin-android-tutorial/) > [https://developer.android.com/courses/](https://developer.android.com/courses/)

## Android 系统

### Android 系统架构

> [!cite] Android 系统架构图
> [系统启动之BootLoader 简介及内核启动](https://crazymo.blog.csdn.net/article/details/114768692)
> [Android启动过程](https://medium.com/@khetanrajesh/android-boot-up-process-init-c05371c4f976)
> [Linux进程Fork详解](https://juejin.cn/post/7022470737617223717)
> [Android启动过程-万字长文(Android14)](https://www.cnblogs.com/anywherego/p/18221943)
> [Android 进阶——系统启动之Android init进程的创建和启动](https://blog.csdn.net/CrazyMo_/article/details/114769424)
> [Android 操作系统架构开篇](https://gityuan.com/android/)

![架构图](https://source.android.com/static/images/android-stack.svg?hl=zh-cn)

应用层:  包括用户界面、应用程序逻辑和数据存储等.
应用框架层: 提供应用程序开发的 API(System API, Android API, Android framework).
系统运行库: 提供系统服务(System services)和安卓运行时环境(Android runtime (ART))
硬件抽象层: 包括 Hardware abstraction layer (HAL) 和 Native daemons and libraries.
内核层: 包括 Android kernel 和 Linux Kernel, 共同构成GKI(前身 ACK)

### Android 系统启动

1. 设备上电: 产生复位时序信号, 启动硬件(IO, 内存等)复位和初始化, 最后复位 CPU(避免寄存器状态不准), 执行引导加载程序(U-Boot 或fastboot).

2. 引导加载程序 (Bootloader): 存储在设备的只读存储器中, 启动时会根据*启动时验证*流程验证设备, 确定要启动的系统内核和启动模式, 然后加载启动映像.

    - 启动时验证可以确保执行的代码是可信的(包括硬件->Bootloader->内核->分区), 占用内存小的代码直接哈希验证, 占用内存大的使用 dm-verity 验证, 要求是哈希树的根哈希值必须可信. 同时防止系统降级和传递启动状态到内核.
    - 系统内核和启动模式和选择受 A/B 更新影响(非A/B 更新, A/B 更新, 虚拟 A/B 更新).
    - 启动映像: 包括 Linux 内核和 ramdisk 映像

3. 内核初始化: 内核自解压, 启动内核, 初始化设备驱动程序.

    - Linux 内核: 会创建 0 号进程(swapper), 运行在内核空间, 同时初始化硬件驱动, 中断处理程序, 进程调度程序, 内存管理, 基于内存的文件系统等.
    - ramdisk: 包含了一些初始化脚本, 用于挂载基于内存的根文件系统.

4. init 进程启动: 由内核启动, 1 号进程, 运行在用户空间, 加载系统配置文件(如 init.rc), 负责启动原生服务 和 Zygote.

    - init.rc: 用于配置系统属性, 如系统语言, 时区, 屏幕密度等.
    - 原生服务(native service): 由 init 进程启动, 用于提供系统服务, 如 bootanim(开机动画), vold(存储设备事件),  servicemanager(内核层Binder服务管理者), installd(安装 APP), lmkd(低内存守护进程), adbd(调试), logcatd(日志)等, 不依赖于 Java 虚拟机环境, 一般通过 socket 通信.

5. 系统服务启动: 由 init 进程首先启动 Zygote 进程, 然后启动其他重要系统服务进程.

    - Zygote 进程: fork 自 init 进程, 独立的用户空间, 执行文件名(/system/bin/app_process), 用于预先加载系统的核心类库(如安卓运行环境 ART, )和安卓系统服务, 然后进入循环, 等待新 Android 应用程序进程创建请求, 期间通过 socket 与其他进程通信, 基于 fork 创建应用程序进程.
        - 创建虚拟机, 注册JNI方法, 通过 JNI 调用 ZygoteInit.main().
        - 预加载系统常用的类、各种资源和核心库.
        - 启动系统服务进程.
    - 系统服务进程均 fork 自 Zygote, 同时通过反射调用 main() 方法进行自定义初始化, 并通过 Binder 机制进行进程间通信. 常见的有 ActivityManagerService, ActivityTaskManagerService, RootWindowContainer, PackageManagerService, PowerManagerService, WindowManagerService, BatteryService, BatteryStatsService, DreamManagerService, DropBoxManagerService, SamplingProfilerService, 等系统服务进程, 进程创建失败时将会重启zygote进程.

6. 桌面程序启动: 通过 ActivityManagerService 和 RootWindowContainer 在所有显示器上通过 Intent 和 startHomeActivity 方法启动了当前用户的桌面程序, 显示用户界面.
    - 桌面程序是通过 Zygote 进程 fork 出的桌面程序进程, 启动时会进行初步初始化, 如构造 Looper, Handler等, 然后绑定到 AMS 中, 由其进行调度.
    - 桌面页面通常是 Launcher, 一个 Activity 类型对象, 可以是其他定制的桌面程序, 包含工作区(搜索框, 桌面, 壁纸, Hotseat等), 应用程序列表, Widget等.

### Android 通信机制

#### Socket

#### Binder

> [为什么 Android 要采用 Binder 作为 IPC 机制？](https://www.zhihu.com/question/39440766/answer/89210950)

#### Handler

> [安卓学习笔记之 Handler机制的简单理解和使用](https://blog.csdn.net/JMW1407/article/details/121966563)

主要用于在主线程中进行 UI 更新操作, 同时也只能在主线程进行 UI 更新操作.

Handler消息机制由 `Message`、`MessageQueue`、`Looper`、`Handler` 组成, 用于在不同线程之间传递消息, 实现线程间的通信.

- `Message`, 线程之间传递的消息, 用于不同线程之间的数据交互.
- `Handler` 用于发送和处理消息, `sendMessage()` 用来发送消息, `handleMessage()` 用于针对不同类型消息进行处理, 如进行相应的UI操作.
- `MessageQueue` 用于存放 `Handler` 发送的消息, 一个线程只能有一个消息队列.
- `Looper` 消息队列的管理者, 当发现 `MessageQueue` 中存在消息, `Looper` 就会将消息传递到`handleMessage()` 方法中, 同样, 一个线程只有一个 `Looper`.

每个线程都可以有自己的 `Looper`, 主线程会自动创建一个 `Looper`, 其他线程需要手动创建, 通过 `Looper.prepare()` 方法创建, 然后通过 `Looper.loop()` 方法开始消息循环.

线程间通信时, 需要创建一个 `Handler`对象, 绑定目标执行线程的 `Looper`, 然后通过 `sendMessage()` 方法发送消息, 目标线程会通过对象重写的 `handleMessage()` 方法中处理消息.

`Looper` 是一个无限循环, 会不断从消息队列中取出消息, 然后调用 `Handler` 的 `handleMessage()` 方法进行处理, 直到消息队列为空.

`Message` 消息处理时可以处理数据类型消息, 通过 `what` 和 `obj` 属性进行区分, 以及可以处理 `Runnable` 消息.

### Android 系统服务

#### ActivityManagerService(AMS)

负责系统内四大组件的生命周期以及应用程序的管理进程.

#### ActivityTaskManagerService(ATMS)

AMS的辅助类, 负责处理 Activity 及其相关容器(如活动栈(Task), 活动栈组(Stack), 屏幕(Display)等)的管理.

#### PackageManagerService(PMS)

负责扫描和监控应用程序的安装和卸载, 管理应用程序的权限, 提供应用程序的信息, 管理应用程序的数据等.

#### PowerManagerService

管理设备的电源管理.

#### WindowManagerService

管理窗口的显示和布局, 其中 RootWindowContainer 为管理所有窗口的容器.

#### SurfaceFlinger

负责显示系统的窗口, 通过 OpenGL 渲染窗口, 并将渲染结果显示到屏幕上.

### Android Runtime(ART, 兼容前身 Dalvik) 应用程序运行环境

支持预先 (AOT) 编译和即时 (JIT) 编译, 用于将 DEX 字节码转换为本机机器代码, 以提高应用程序的性能和效率.

- JIT 及时编译: 在应用程序运行时将字节码编译为本机机器代码, 编译速度快, 但影响应用启动速度.
- AOT 预先编译: 在应用程序安装时, 使用设备自带的 *dex2oat* 工具来编译应用将字节码编译为本机机器代码, 安装速度慢, 但提高应用启动速度.

## Android 应用程序组成

### 清单文件 `AndroidManifest.xml`

安卓操作系统与安卓应用程序之间由清单文件 `AndroidManifest.xml` 进行连接, 该清单文件位于应用程序的根目录下, 用于告知系统应用程序的基本信息, 如应用程序的名称、图标、版本号、权限以及各种组件等.

以下是一个简单的清单文件示例及其内容解析:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <!-- 应用程序信息 -->
    <application
        android:name=".MyApplication"
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.MyApplication3"
        tools:targetApi="31">

        <!-- 活动声明 -->
        <activity
            android:name=".MainActivity"
            android:launchMode="singleTop"
            android:taskAffinity=""
            android:allowTaskReparenting="true"
            android:exported="true"
            android:label="@string/title_activity_main"
            android:permission="com.example.MY_PERMISSION"
            >
        <intent-filter>
            <action android:name="android.intent.action.MAIN" />
            <category android:name="android.intent.category.LAUNCHER" />
        </intent-filter>
        </activity>

        <activity
            android:name=".SecondActivity"
            android:exported="true"
            android:label="@string/title_activity_second">
        <intent-filter>
            <action android:name="com.example.SECOND" />
            <category android:name="android.intent.category.DEFAULT" />
        </intent-filter>
        </activity>

        <!-- 服务声明 -->
        <service
            android:name=".MyService"
            android:exported="true">
            <intent-filter>
                <action android:name="com.example.MY_SERVICE" />
            </intent-filter>
        </service>

        <!-- 广播接收器声明 -->
        <receiver
            android:name=".MyReceiver"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.BOOT_COMPLETED" />
            </intent-filter>
        </receiver>

        <!-- 内容提供程序声明 -->
        <provider
            android:name=".MyProvider"
            android:authorities="com.example.myprovider"
            android:exported="true"
            android:grantUriPermissions="true">
            <grant-uri-permission android:pathPattern="/myprovider/*" />
            </provider>
    </application>

    <!-- 权限声明 -->
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission android:name="android.permission.CAMERA" />
    <uses-permission android:name="android.permission.RECORD_AUDIO" />
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />

    <!-- 使用特性 -->
    <uses-feature android:name="android.hardware.camera" />
    <uses-feature android:name="android.hardware.microphone" />
    <uses-feature android:name="android.hardware.location.gps" />

</manifest>
```

顶部声明

- `<?xml version="1.0" encoding="utf-8"?>`：声明 XML 文件的版本和编码方式.
- `<manifest>`：根元素, 包含应用的所有配置.
    - `xmlns:android="http://schemas.android.com/apk/res/android"`：定义 `android` 命名空间, 用于引用安卓系统提供的属性.
    - `xmlns:tools="http://schemas.android.com/tools"`：定义 `tools` 命名空间, 用于引用开发工具 (如 Android Studio) 提供的一些自定义属性.  

- `<application>` 元素

包含应用级别的配置信息, 定义应用的全局属性和组件.

- `android:name=".MyApplication"`: 指定应用的自定义 `Application` 类.
- `android:allowBackup="true"`: 允许用户备份和恢复应用的数据.
- `android:dataExtractionRules="@xml/data_extraction_rules"`: 指定数据提取规则, 通常用于自动备份功能.
- `android:fullBackupContent="@xml/backup_rules"`: 指定完整备份内容的规则.
- `android:icon="@mipmap/ic_launcher"`: 指向用于标识应用的图标的资源
- `android:label="@string/app_name"`: 指定应用的显示名称.
- `android:roundIcon="@mipmap/ic_launcher_round"`: 指定圆形应用图标 (通常用于圆形图标需求的设备).
- `android:supportsRtl="true"`: 指定应用是否支持从右到左 (RTL) 的布局方向.
- `android:theme="@style/Theme.MyApplication3"`: 指定应用的主题.
- `tools:targetApi="31"`: 指定目标 API 级别, 主要用于开发工具进行静态代码检查, 不影响实际运行时的行为.

**`<activity>`元素**

定义一个活动 (Activity), 是应用的一个主要组件, 代表一个用户界面.

- `android:name=".MainActivity"`: 指定活动的类名, `.MainActivity` 表示该活动在应用包名下.
- `android:launchMode="singleTop"`: 指定活动的启动模式. 这里是 `singleTop`, 表示如果活动已经在栈顶, 不会重新创建新的实例.
- `android:taskAffinity=""`: 指定活动的任务亲和性, 控制活动创建时所在的任务栈. 默认会在当前任务栈, 如果设置了亲和值, 则会寻找具有相同亲和值的任务栈, 如果没有则创建新的任务栈.
- `android:allowTaskReparenting="true"`: 指定当活动所在任务栈进入前台时, 是否可以将活动移动到其他具有相同亲和性的任务栈.
- `android:clearTaskOnLaunch="true"`: 每当用户离开该任务并再次返回时, 任务栈中的所有活动都会被清除, 仅保留根活动.
- `android:alwaysRetainTaskState="true"`: 拒绝系统在用户长时间离开任务栈时清除除了根活动之外的所有活动.
- `android:finsihOnTaskLaunch="true"`: 指定活动是否在任务启动时结束.
- `android:exported="true"`: 指定活动是否可以由应用之外的组件启动. `true` 表示可以被其他应用访问.
- `android:label="@string/title_activity_main"`: 指定活动的显示名称.
- `android:permission="com.example.MY_PERMISSION"`: 指定活动自身被调用时需要的权限.
- `<intent-filter>`: 定义了活动能够响应的意图 (Intent) , 通常用于配置应用的启动活动和处理特定的动作.

    - `<action>`: 定义意图的动作.

        - `android:name="android.intent.action.MAIN"`: 表示该活动是应用的主入口点, 会为其创建程序图标.
        - `android:name="com.example.SECOND"`: 自定义的动作名称.

    - `<category>`: 定义意图的类别.

        - `android:name="android.intent.category.LAUNCHER"`: 表示该活动会出现在应用启动器中, 作为应用的启动活动.
        - `android:name="android.intent.category.DEFAULT"`: 默认的意图类别.

**`<service>`**元素**

定义一个服务 (Service) , 是一个后台运行的组件, 用于执行长时间运行的操作.

- `android:name=".MyService"`: 指定服务的类名.
- `android:exported="true"`: 指定服务是否可以被其他应用访问.
- `<intent-filter>`: 定义了服务能够响应的意图.

    - `<action>`: 定义意图的动作.

        - `android:name="com.example.MY_SERVICE"`: 自定义的动作名称.

**`<receiver>` 元素**

定义一个广播接收器 (Broadcast Receiver) , 用于接收系统广播事件.

- `android:name=".MyReceiver"`: 指定广播接收器的类名.
- `android:exported="true"`: 指定广播接收器是否可以被其他应用访问.
- `<intent-filter>`: 定义了广播接收器能够响应的意图.

    - `<action>`: 定义意图的动作.

        - `android:name="android.intent.action.BOOT_COMPLETED"`: 表示系统启动完成后发送的广播.

**`<provider>` 元素**

定义一个内容提供程序 (Content Provider) , 用于管理应用程序的数据集.

- `android:name=".MyProvider"`: 指定内容提供程序的类名.
- `android:authorities="com.example.myprovider"`: 指定内容提供程序的权限.
- `android:exported="true"`: 指定内容提供程序是否可以被其他应用访问.
- `android:grantUriPermissions="true"`: 指定内容提供程序是否授予 URI 权限.
- `<grant-uri-permission>`: 定义了内容提供程序授予的 URI 权限.

    - `android:pathPattern="/myprovider/*"`: 匹配 URI 的路径模式.

**`<uses-permission>` 元素**

定义应用程序需要的权限.

- `android:name="android.permission.INTERNET"`: 访问互联网的权限.
- `android:name="android.permission.ACCESS_NETWORK_STATE"`: 访问网络状态的权限.
- `android:name="android.permission.CAMERA"`: 使用摄像头的权限.
- `android:name="android.permission.RECORD_AUDIO"`: 录制音频的权限.
- `android:name="android.permission.ACCESS_FINE_LOCATION"`: 访问精确位置的权限.

**`<uses-feature>` 元素**

定义应用程序需要的硬件功能.

- `android:name="android.hardware.camera"`: 摄像头硬件功能.
- `android:name="android.hardware.microphone"`: 麦克风硬件功能.
- `android:name="android.hardware.location.gps"`: GPS 定位硬件功能.

### 应用程序安装和启动

1. 应用程序安装: 通过 Google Play 商店、应用商店、APK 文件等方式安装应用程序, 安装时

    - 系统会解析 APK 文件, 提取清单文件 `AndroidManifest.xml` 中的信息, 包括应用程序的名称、图标、版本号、权限以及各种组件等.
    - 系统桌面启动器 (Launcher) 会在设备上安装应用程序时, 读取 app 的清单文件 `AndroidManifest.xml`, 并为其创建一个程序图标.

2. 应用程序启动: 点击应用程序图标, 当前所在程序(一般是桌面)通过 `Intent` 利用内部的 `startActivity()` 方法或 `LauncherApps` 提供的方法启动对应应用程序的主 `Activity`, 或其他快捷方式、通知栏、桌面小部件等功能, 启动时依然是通过 `ActivityManagerService` 等服务实现.
    - 应用程序是通过 Zygote 进程 fork 出的进程, 启动时会绑定到 AMS 中, 同时进入主线程(UI 线程: ActivityThread)进行应用程序的初始化过程, 包括但不限于构造 Looper,  Handler等, 最后进入消息循环, 等待 AMS 的调度.
    - 等待 AMS 发起 bindApplication() 和 ATMS 发起 attachApplication(), 会在主线程内部产生一个 BIND_APPLICATION 类型的 Message 发起包括但不限于 , Instrumentation(用于监控和管理应用行为), Application, ContentProvider, Activity, Service, BroadcastReceiver 等组件的初始化.
    - 等待 AMS 发起 app.scheduleReceiver(), 会在主线程内部产生一个 RECEIVER 类型的 Message 进行广播接收器的 handle.

### 应用程序组件: Instrumentation

> [Android Instrumentation 框架简单说明 · 测试之家](https://testerhome.com/topics/6592)

### 应用程序组件: Application

应用程序的基础是 `Application` 类, 一个单例类, 每个应用程序都有一个 `Application` 实例, 它是整个应用程序的入口点, 负责应用程序的初始化和全局状态的管理, 可以通过 `getApplication()` 方法获取.

- 在应用程序启动时初始化一些全局的资源或配置, 例如第三方库 (如分析工具、数据库库等).
- 在应用程序的生命周期中管理全局状态, 例如用户登录状态、网络连接状态等.
- 监控整个应用程序的生命周期, 处理一些全局的状态变化.

    - `onCreate()`: 应用程序创建时调用.
    - `onLowMemory()`: 系统内存不足时调用.
    - `onTrimMemory()`: 系统内存不足时调用, 用于释放资源.
    - `onConfigurationChanged()`: 配置发生变化时调用, 如屏幕旋转.
    - `onTerminate()`: 应用程序终止时调用.
    - `registerActivityLifecycleCallbacks()`: 注册活动生命周期回调.

```kotlin
class MyApplication : Application() {
    override fun onCreate() {
        super.onCreate()
        // 初始化Firebase
        FirebaseApp.initializeApp(this)
        // 初始化Crashlytics
        Fabric.with(this, Crashlytics())
        // 初始化数据库
        Realm.init(this)
        // 初始化全局数据
        someGlobalData = "This is some global data"
    }
}
```

### 应用程序四大组件: 活动、服务、广播接收器、内容提供程序

Android 应用程序由四个主要组件组成:

- 活动 (Activity): 用户与应用程序进行交互的主要入口点, 通常表示一个具有用户界面的屏幕
- 服务 (Service): 在后台执行长时间运行的操作或远程处理
- 广播接收器 (Broadcast Receiver): 在系统广播事件发生时接收系统广播
- 内容提供程序 (Content Provider): 管理应用程序的数据集

活动可以启动服务来执行后台任务; 注册广播接收器来接收系统或应用的广播以更新 UI; 使用内容提供程序来访问和管理数据; 启动其他活动, 并传递数据.

广播接收器被动接收系统或应用的广播事件, 然后可以启动服务来执行后台任务, 也可以通过内容提供程序来访问和管理数据.

服务通常是由活动或广播接收器启动, 可以通过内容提供程序来访问和管理数据.

内容提供程序为程序提供标准的数据管理接口, 包括查询、插入、更新和删除.

此外还有些附加组件:

- 片段 (Fragment): 可重用的 UI 组件
- 意图 (Intent): 用于在组件之间传递消息
- 视图 (View): 用户界面的构建块
- 布局 (Layout): 定义视图的结构和外观
- 资源 (Resource): 应用程序的非代码资源, 如图像、字符串和布局文件

#### 活动 (Activity)

每个活动都是一个类, 继承自 `Activity` 类或其子类, 用于表示 Android 应用程序用户界面的一个屏幕. Android 应用启动时, 会首先进入设置的主 `Activity` 的初始化过程. 此外, 每个应用程序可以包含多个活动, 所有活动必须在清单文件 `AndroidManifest.xml` 中进行声明, 当一个应用调用另一个应用时, 发起调用的应用可以调用另一个应用中的其他 `activity`. 例如, 浏览器应用可能会启动社交媒体应用的分享 `activity`.

每个活动都有一个生命周期, 包括以下主要状态:

- `onCreate(Bundle savedInstanceState)`: 活动创建时调用
- `onStart()`: 活动开始时调用, 初始化的资源应在 `onStop` 释放
- `onResume()`: 活动恢复时调用(可见且在前台 ) <-----|
- `onPause()`: 活动暂停时调用(可见但不在前台) ----->| 不建议释放与 ui 相关的资源和耗时操作
- `onStop()`: 活动停止时调用(不可见), 系统会自动保存组件状态, 即使活动被销毁.
- `onRestart()`: 活动重新启动时调用
- `onDestroy()`: 活动销毁时调用

辅助方法:

- `onSaveInstanceState(Bundle outState)`: 保存活动除布局或视图之外的自定义状态, 以便在活动重新创建时恢复, 缺点是只能保存少量数据, 因为要在主线程进行序列化操作.
- `onRestoreInstanceState(Bundle savedInstanceState)`: 恢复保存的状态, 与 `onSaveInstanceState` 配合使用, 一般使用 `onCreate` 方法就足够了.
- `startActivity(Intent intent, Bundle options)`: 启动另一个活动
- `startActivityForResult(Intent intent, int requestCode)`: 启动另一个活动并获取结果, 结果通过 `onActivityResult` 方法返回
- `setResult(int resultCode, Intent data)`: 当被其他活动启动时, 设置返回结果.
- `onActivityResult(int requestCode, int resultCode, Intent data)`: 当其他活动响应了 `Intent` 后, 并通过 `setResult` 设置了返回结果, 会调用此方法.

自定义默认启动活动模式

- `launchMode.standard`: 标准模式, 每次启动都会创建新的实例, 并将启动时的 `Intent` 传递给新的实例. 比如新闻应用中每次点击文章链接都会创建新的文章页面实例.
- `launchMode.singleTop`: 栈顶复用模式, 如果活动已经在栈顶, 不会重新创建新的实例, 而是调用 `onNewIntent` 方法来处理新的 `Intent`. 如果活动不在栈顶, 会创建新的实例. 比如点击消息通知栏的消息进入消息详情页面, 如果在消息通知栏消失前点击多次, 不会创建新的实例, 而是复用当前页面.
- `launchMode.singleTask`: 栈内复用模式, 如果活动已经在栈中, 会将该活动上面的所有活动出栈, 并调用 `onNewIntent` 方法来处理新的 `Intent`. 如果活动不在栈中, 会创建新的实例. 比如点击应用图标或导航栏的主页面, 我的页面等进入页面, 如果页面已经在栈中, 会将页面上面的所有活动出栈`.
- `launchMode.singleInstance`: 单实例模式, 如果没有包含此活动的任务栈, 则创建一个单独的任务栈管理此活动, 并且该活动独占任务栈, 不会与其他活动共享任务栈. 如果已经有包含此活动的任务栈, 则直接把此任务栈置于前台展示, 不会创建新的实例. 比如播放视频的全屏模式, 独立登录页面等, 会创建一个新的任务栈, 并且独占任务栈.
- `launchMode.singleInstancePerTask`: 单示例和栈内复用模式, 如果没有包含此活动的任务栈, 则创建一个单独的任务栈管理此活动, 此活动会置于栈底, 后续启动的活动也会在此任务栈中. 如果已经有包含此活动的任务栈, 则直接把此任务栈置于前台展示, 不会创建新的实例, 同时将此活动顶部的其他活动出栈.

```kotlin
class MainActivity : AppCompatActivity() {
    lateinit var textView: TextView
    var gameState: String? = null
    var currentScore = 0
    var currentLevel = 0
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        if (savedInstanceState != null) {
            with(savedInstanceState) {
                gameState = getString(GAME_STATE_KEY)
                textView.text = getString(TEXT_VIEW_KEY)
                currentScore = getInt(STATE_SCORE)
                currentLevel = getInt(STATE_LEVEL)
            }
        }
        setContentView(R.layout.activity_main)
        textView = findViewById(R.id.text_view)
    }

    override fun onStart() {
        super.onStart()
        Log.d(TAG, "onStart")
    }

    override fun onResume() {
        super.onResume()
        Log.d(TAG, "onResume")
    }

    override fun onPause() {
        super.onPause()
        Log.d(TAG, "onPause")
    }

    override fun onStop() {
        super.onStop()
        Log.d(TAG, "onStop")
    }

    override fun onSaveInstanceState(outState: Bundle?) {
        outState?.run {
            putString(GAME_STATE_KEY, gameState)
            putString(TEXT_VIEW_KEY, textView.text.toString())
            putInt(STATE_SCORE, currentScore)
            putInt(STATE_LEVEL, currentLevel)
        }
        // Call superclass to save any view hierarchy.
        super.onSaveInstanceState(outState)
    }
}
```

活动之间可以通过意图 (Intent) 进行通信, 意图可以用于启动活动、启动服务、发送广播等.

#### 服务 (Service)

服务是可以在后台执行长时间运行操作或远程处理(下载文件、播放音乐、更新数据等)的组件, 不提供用户界面, 即使应用程序处于后台或被销毁, 服务仍然可以继续运行. 每个服务都是一个类, 继承自 `Service` 类或其子类. 服务必须在清单文件 `AndroidManifest.xml` 中进行声明.

服务可以通过活动的 `startService()` 或 `bindService()` 方法启动, 通过 `stopService()` 或 `unbindService()` 方法停止. 区别在于 `startService()` 启动的服务会一直运行, 直到调用 `stopService()` 停止, 而 `bindService()` 是在其他 app 或系统组件中绑定服务, 绑定后服务会一直运行直到所有绑定的组件都解绑.

每个服务也有一个生命周期, 包括以下主要状态:

- `onStartCommand()`: 服务启动时调用
- `onCreate()`: 服务创建时调用
- `onBind()`: 服务绑定时调用
- `onUnbind()`: 服务解绑时调用
- `onRebind()`: 服务重新绑定时调用
- `onDestroy()`: 服务销毁时调用

#### 广播接收器 (Broadcast Receiver)

广播接收器是用于接收系统或应用的广播事件的组件, 当特定事件发生时, 广播接收器会接收并处理广播消息. 每个广播接收器都是一个类, 继承自 `BroadcastReceiver` 类或其子类. 广播接收器必须在清单文件 `AndroidManifest.xml` 中进行声明.

广播接收器可以通过 `registerReceiver()` 方法注册, 通过 `unregisterReceiver()` 方法注销. 也可以通过清单文件声明静态注册, 这样即使应用程序未运行, 也可以接收广播.

广播接收器可以接收系统广播事件, 常见的系统广播事件包括:

- `android.intent.action.BOOT_COMPLETED`: 系统启动完成时发送的广播
- `android.intent.action.SCREEN_ON`: 屏幕开启时发送的广播
- `android.intent.action.SCREEN_OFF`: 屏幕关闭时发送的广播
- `android.intent.action.ACTION_POWER_CONNECTED`: 充电器连接时发送的广播
- `android.intent.action.ACTION_POWER_DISCONNECTED`: 充电器断开时发送的广播
- `android.intent.action.BATTERY_LOW`: 电池电量低时发送的广播
- `android.intent.action.BATTERY_OKAY`: 电池电量恢复正常时发送的广播

广播接收器也可以通过活动的 `sendBroadcast()` 方法发送自定义的广播事件.

#### 内容提供程序 (Content Provider)

内容提供程序是用于管理应用程序的数据集的组件, 提供包括查询、插入、更新和删除等数据接口, 支持跨应用程序访问数据. 存储方式包括数据库, 文件, 网络等.

每个内容提供程序都是一个类, 继承自 `ContentProvider` 类或其子类. 内容提供程序必须在清单文件 `AndroidManifest.xml` 中进行声明.

内容提供程序可以通过查询, 插入, 更新和删除方法来操作数据. 想访问内容提供程序可以通过预定义的 URI (Uniform Resource Identifier) 来标识和访问数据集, URI 由以下部分组成:`<prefix>://<authority>/<data_type>/<id>`

`ContentProvider` 类中的方法:

- `query()`: 查询数据
- `insert()`: 插入数据
- `update()`: 更新数据
- `delete()`: 删除数据
- `getType()`: 获取数据类型
- `onCreate()`: 当提供者被启动时调用

#### 意图 (Intent)

意图是一种异步消息传递机制,

意图是用于在组件之间异步传递消息的对象, 用于在将组件绑定, 同时在组件之间传递消息, 如启动活动、启动服务、发送广播等.

- 显式意图 (Explicit Intent): 指定要启动的组件的类名, 如告诉系统在 Gmail 应用程序中启动发送电子邮件的 `Activity`. 启动时可以修改组件的启动模式.
- 隐式意图 (Implicit Intent): 指定要执行的操作, 由系统根据意图的动作和数据类型选择合适的组件, 然后系统 UI 询问用户选择哪个应用程序来处理该意图, 如在任何可以完成发送电子邮件工作的活动中启动发送电子邮件的 `Activity`.

标志:

- `FLAG_ACTIVITY_NEW_TASK`: 对应 `launchMode` 的 `singleTask`
- `FLAG_ACTIVITY_SINGLE_TOP`: 对应 `launchMode` 的 `singleTop`
- `FLAG_ACTIVITY_CLEAR_TOP`: 如果正在启动的活动已经在当前任务中运行, 那么系统将销毁其上的所有其他活动, 而不是启动该活动的新实例.
- `FLAG_ACTIVITY_CLEAR_TOP` + `FLAG_ACTIVITY_NEW_TASK`: 如果正在启动的活动已经在当前任务中运行, 那么系统将销毁其上的所有其他活动, 并将此活动置于新任务的顶部.

```xml
<uses-permission android:name="com.example.MY_PERMISSION" /> <!-- 调用其他活动需要申请对应活动定义的权限 -->

<activity android:name=".ExampleActivity">
    <intent-filter>
        <action android:name="com.example.EXAMPLE_ACTION" /> <!-- 自定义的动作名称 -->
        <category android:name="android.intent.category.DEFAULT" /> <!-- 默认的意图类别, 表示该活动可以接收启动意图 -->
        <data android:mimeType="text/plain" /> <!-- 可以发送的数据类型 -->
    </intent-filter>
</activity>
```

```kotlin
// 调用意图
val intent = Intent(this, ExampleActivity::class.java)
intent.action = "com.example.EXAMPLE_ACTION"
intent.type = "text/plain"
intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
startActivity(intent)
```

## 项目架构

### 架构原则

原则:

- 组件分离

    - 单一职责
    - 高内聚低耦合

        - 不要将 `ViewModel` 传入 `RecyclerView` 等视图的适配器(Adapter), 而是通过适配器或视图状态的 Callback 接口实现 ViewModel 的访问.

- 通过数据模型驱动界面

    - 尽量持久化存储

- 单一数据源

    - 分配单一的数据持有者
    - 只有持有者可以修改或转变数据, 修改尽量通过提供接口来实现

### 架构结构

UI Layer(界面层, 唯一职责是使用和显示界面状态)

- 界面(UI): 唯一职责是使用 `View` 或 `Jetpack Compose` 等构建视图元素来使用和显示界面状态.

    - 界面会向状态容器发送用户事件通知, 状态容器会处理事件对应的逻辑并更新界面状态.
    - 界面通过使用适当的生命周期感知型协程构建器从状态容器收集最新的界面状态(View: `repeatOnLifecycle`, Compose: `collectAsStateWithLifecycle`). (循环往复)
    - 如果界面不可见或未处于活动状态, 除非明确要求, 否则状态生成和收集的过程可以暂停, 防止消耗任何资源. (生命周期感知型协程构建器会自动控制)
    - 不要替换 activity 或 fragment 的生命周期方法, 可以改为使用 `LifecycleObserver` 监听生命周期事件. 或是通过 `repeatOnLifecycle` 来监听生命周期状态事件(`CREATED`、`DESTROYED`、`INITIALIZED`、`RESUMED`、`STARTED`).

- 界面状态(UI State): 由状态容器提供, 向界面提供数据(`_UiState`, 类似于 `Model`, 尽可能是不可变的.).

    - 一般包含要显示的数据, 控制是否要展示的状态, 控制是否要跳转的状态, 界面的回调函数, 界面的补充信息(突然要弹窗展示的信息)
    - 只有数据源或数据所有者才应负责更新他们公开的数据

- 状态容器(State holder): 负责存储和提供界面状态, 并且包含执行相应任务所必需的处理逻辑.

    - 状态容器分两种, 一种由普通的类实现(界面逻辑状态容器), 绑定到界面的生命周期, 存储不需要长期保留的界面状态和界面逻辑. 一个种由 `ViewModel` 实现(业务逻辑状态容器), 用于处理业务逻辑, 将数据从数据层或网域层转换为屏幕界面状态, 通过数据流向界面提供数据, 通过回调函数向界面提供事件处理逻辑.
    - `ViewModel` 不要放入容器视图的适配器中, 会增加耦合, 可以通过采用回调的方式(界面状态中放回调或适配器定义回调参数)进行.
    - 在 `ViewModel` 中应该立即处理事件, 并通过事件的处理结果引发状态更新, 而不能将来自 `ViewModel` 的事件发送到界面.
    - `ViewModel` 不要存储对任何与生命周期相关的类型的引用, 如 `Activity`, `Fragment`, `Context` 或 `Resources` 作为依赖项传递. 因为 `ViewModel` 生命周期长, 持有的引用在设备状态更改导致被销毁重建时, 旧实例无法被垃圾回收.
    - `ViewModel` 通过数据流(`StateFlow`, `LiveData`)向界面提供界面状态数据, 通过回调函数向界面提供事件处理逻辑.
    - `ViewModel` 通过内置的协程作用域 `viewModelScope` 来执行异步任务(`suspend` 函数), 如从数据源获取数据以及更新界面状态数据.
    - `ViewModel` 应该在屏幕级别的组件中使用, 如 `activity`, `fragment` 等屏幕级别的组件. 对于嵌套的 `fragment`, 如果与父级共享一个 `ViewModel`, 可以通过 `ViewModelProvider` 来获取父级 `fragment` 的 `ViewModel`.

- 界面事件(Event): 由界面发送给状态容器的事件, 用于触发状态容器中的逻辑处理.

    - 包括用户交互、本地资源状态改变、外部资源状态改变产生的事件等.
    - 如果事件需要执行界面逻辑 (与修改界面元素的状态相关, 如可展开项的状态) , 界面便可以直接处理这些事件.
    - 如果事件需要执行业务逻辑 (如刷新屏幕上的数据, 更新数据库数据) , 则应用由 `ViewModel` 处理此事件.

Domain Layer(网域层, 负责封装复杂的业务逻辑, 或者由多个 `ViewModel` 重复使用的简单业务逻辑)

- 合并数据层的多个存储库数据
- 存储可重复使用的简单业务逻辑, 相比于存放在 `Utils` 类中, 使得业务逻辑更加清晰, 便于维护.

Data Layer(数据层, 负责处理数据的获取和存储)

- 由多个存储库(`Repositories`)组成, 其中每个存储库都可以包含零到多个数据源(`Data Sources`).
- 存储库负责处理数据变化, 解决不同数据源冲突, 对数据源抽象化处理, 编码业务逻辑, 提供公开数据访问的函数接口.
- 每个数据源类仅负责处理一个数据源, 数据源可以是文件、网络来源或本地数据库(数据库、`DataStore`、`SharedPreferences`、Firebase API、GPS 位置信息提供程序、蓝牙数据提供程序、网络连接状态提供程序), 且只能由存储库访问.
- 多个存储库可以组合成一个 Manager 存储库, 以便在一个存储库中处理多个数据源.
- 数据源尽可能包含本地数据源和远程数据源, 以便在没有网络连接时使用本地数据源.
- 调用数据源或存储库时, 推荐通过协程(或多线程)来异步获取数据以及与保持数据在不同层之间的流动, 以避免阻塞主线程. 耗时长的操作可以通过 `WorkManager` 来执行. 比如在程序启动时在后台逐一初始化数据源, 以避免启动时的卡顿.
- 从网络数据源读取数据时, 可以通过指数退避算法需要处理网络连接失败、超时等异常情况.

#### 生命周期感知型组件

`Activity` 或 `Fragment` 通常会在其生命周期中执行一些操作, 如初始化数据、加载数据、释放资源等. 普通的生命周期方法在编写时会导致代码冗长, 比如初始化和释放资源的代码分散在了多个生命周期方法中, 使代码难以维护. 不同声明周期方法是异步执行的, 因为执行时间不同, 有时候可能会导致不同的生命周期方法之间的数据不一致.

生命周期感知型组件用于解决这些问题, 通过 `Lifecycle`(`LifecycleRegistry` 是其具体实现的类) 和 `LifecycleObserver`(`DefaultLifecycleObserver` 和 `LifecycleEventObserver` 是其具体实现的类) 来观察和响应具有生命周期变化的组件(如 `Activity` 或 `Fragment`等实现了 `LifecycleOwner` 接口的组件)的生命周期事件, 从而在生命周期状态发生变化时执行相应的操作.

- `Lifecycle`(`LifecycleRegistry`) 存储了具有生命周期变化的组件的生命周期状态, 并且可以在生命周期状态发生变化时通知所有注册的 `LifecycleObserver` 对象. 通过 `addObserver()` 方法来添加 `LifecycleObserver` 对象, 通过 `removeObserver()` 方法来移除 `LifecycleObserver` 对象.
- `DefaultLifecycleObserver` 是一个接口, 用于观察具有生命周期变化的组件的生命周期事件, 从而在生命周期状态发生变化时执行相应的操作. 通过实现 `LifecycleObserver` 接口并重写 `onCreate()`, `onStart()`, `onResume()`, `onPause()`, `onStop()`, `onDestroy()` 等方法来执行相应的操作.
- `LifecycleEventObserver` 是一个接口, 用于观察具有生命周期变化的组件的生命周期事件, 从而在生命周期状态发生变化时执行相应的操作. 通过实现 `LifecycleEventObserver` 接口并重写 `onStateChanged()` 方法来执行相应的操作. 如果同时实现了 `DefaultLifecycleObserver` 接口, 则 `DefaultLifecycleObserver` 的方法会优先执行.

注意事项:

- 当 `onSaveInstanceState()` 被调用时, Android 认为当前的 UI 状态应该被保存, 因此不建议在这之后再更改 UI. 然而, `onStop()` 通常在 `onSaveInstanceState()` 之后调用, 此时 `Lifecycle` 会从 `RESUMED` 变为 `CREATED`, 分发 `ON_STOP` 事件. 如果在 `onSaveInstanceState()` 和 `onStop()` 之间对 UI 进行更改, 可能导致应用导航状态不一致. [这是个问题](https://developer.android.com/topic/libraries/architecture/lifecycle?hl=zh-cn#onStop-and-savedState)!

```kotlin
class MyObserver : DefaultLifecycleObserver {
    override fun onCreate(owner: LifecycleOwner) {
        // 在 onCreate() 方法中执行初始化操作
    }

    override fun onDestroy(owner: LifecycleOwner) {
        // 在 onDestroy() 方法中执行释放资源操作
    }
}

class MyActivity : AppCompatActivity() {
    private val myObserver = MyObserver()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        lifecycle.addObserver(myObserver) // getLifecycle()
    }

    override fun onDestroy() {
        super.onDestroy()
        lifecycle.removeObserver(myObserver)
    }
}
```

每个 `LifecycleOwner` 对象都有一个协程作用域, 可以通过 `lifecycleScope` 属性来获取; 每一个 `ViewModel` 对象都有一个协程作用域, 可以通过 `viewModelScope` 属性来获取.  
生命周期感知型组件的协程作用域用于在生命周期范围内启动协程, 以便在生命周期状态发生变化时取消协程.

如果需要在 `LifecycleOwner` 对象只要进入到指定的生命周期状态就执行某个操作, 可以使用 `repeatOnLifecycle()` 函数, 该函数会在 `LifecycleOwner` 对象进入到指定的生命周期状态时执行指定的操作, 并且会在 `LifecycleOwner` 对象退出指定的生命周期状态时取消操作.

```kotlin
class MyActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        lifecycleScope.launch {

            // 随状态变化而反复执行
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                // 在 STARTED 状态下执行操作
            }

            // 单次长时间操作, 随状态变化可恢复运行直到运行完成
            whenStarted {
                // 在第一次 STARTED 状态下执行操作
            }

            whenResumed {
                // 在第一次 RESUMED 状态下执行操作
            }

            whenCreated {
                // 在第一次 CREATED 状态下执行操作
            }
        }
    }
}

class MyFragment : Fragment() {
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        viewLifecycleOwner.lifecycleScope.launch {
            viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {
                // 在 STARTED 状态下执行操作
            }
        }
    }
}

class MyViewModel : ViewModel() {
    init {
        viewModelScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                // 在 STARTED 状态下执行操作
            }
        }
    }
}
```

#### ViewModel(未完成)

`ViewModel` 是一个用于持久存储界面相关状态数据, 处理界面业务逻辑的类. 防止因为 `activity` 或 `fragment` 的重建而导致数据丢失. 同时, `ViewModel` 的作用域被限定为 `ViewModelStoreOwner` 的生命周期范围内, 通常是 `activity` 或 `fragment` 的生命周期范围内. 只有在 `activity` 或 `fragment` 在非配置更改的情况下被销毁时, `ViewModel` 才会被销毁, 比如调用 `finish()` 方法.

```kotlin
class MyViewModel : ViewModel() {
    private val _data = MutableStateFlow<String>()
    val data: StateFlow<String> = _data.asStateFlow()

    fun updateData(newData: String) {
        _data.value = newData
    }
}

class MyActivity : AppCompatActivity() {
    private val viewModel: MyViewModel by viewModels() // 使用 by viewModels() 代理属性来获取 ViewModel 实例, 这通常在 onCreate() 之前

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        viewModel = ViewModelProvider(this).get(SimpleViewModel::class.java) // 使用 ViewModelProvider 手动创建 ViewModel 实例


        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.data.collect { data ->
                    // 更新界面数据
                }
            }
        }
    }
}
```

因为 `ViewModelProvider` 只能通过默认的无参构造函数来创建 `ViewModel` 实例. 当 `ViewModel` 需要依赖外部组件时, 可以通过构造函数注入或 Hilt 库进行依赖注入, 并只能通过 `ViewModelProvider.Factory` 来创建 `ViewModel` 实例.

```kotlin
class MyViewModel @ViewModelInject constructor(
    private val repository: MyRepository
) : ViewModel() {
    private val _data = MutableStateFlow<String>()
    val data: StateFlow<String> = _data.asStateFlow()

    fun updateData(newData: String) {
        _data.value = newData
    }
}

class MyViewModelFactory @Inject constructor(
    private val repository: MyRepository
) : ViewModelProvider.Factory {
    override fun <T : ViewModel?> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(MyViewModel::class.java)) {
            return MyViewModel(repository) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}

class MyActivity : AppCompatActivity() {
    private val viewModel: MyViewModel by viewModels { MyViewModelFactory(repository) } // 使用 by viewModels() 代理属性来获取 ViewModel 实例, 这通常在 onCreate() 之前

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        var factory = MyViewModelFactory(repository)
        viewModel = ViewModelProvider(this, factory).get(SimpleViewModel::class.java) // 使用 ViewModelProvider 手动创建 ViewModel 实例

        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.data.collect { data ->
                    // 更新界面数据
                }
            }
        }
    }
}

```

可以通过 `SavedStateHandle` 在 `ViewModel` 中保存和恢复与界面状态相关的数据, 避免因为系统因内存不足等原因终止应用程序时导致的数据丢失, 从而在重启应用程序时恢复数据.

#### LiveData(未完成)

`LiveData` 是一种可观察的数据存储器类, 可以感知 `LifecycleOwner` 的生命周期状态, 并且只在 `LifecycleOwner` 处于活动状态时通知观察者.  
`MutableLiveData` 是 `LiveData` 的子类, 用于存储可变数据, 并且可以通过 `setValue()` 或 `postValue()` 方法来更新数据.

```kotlin
class MyViewModel : ViewModel() {
    private val _data = MutableLiveData<String>()
    val data: LiveData<String> = _data

    fun updateData(newData: String) {
        _data.value = newData
    }
}

class MyActivity : AppCompatActivity() {
    private val viewModel: MyViewModel by viewModels()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        val observer = Observer<String> { data ->
            // 更新界面数据

        }
        viewModel.data.observe(this, observer)
    }
}
```

[将协程与 LiveData 一起使用](<https://developer.android.com/topic/libraries/architecture/coroutines?hl=zh-cn#livedata:~:text=项> 浪费资源。-,将协程与 LiveData 一起使用,-使用 LiveData 时)

#### StateFlow

`StateFlow` 是一种可观察的数据存储器类, 可以感知 `LifecycleOwner` 的生命周期状态, 并且只在 `LifecycleOwner` 处于活动状态时通知观察者.  
`MutableStateFlow` 是 `StateFlow` 的子类, 用于存储可变数据, 并且可以通过 `value` 属性来更新数据.

```kotlin
class MyViewModel : ViewModel() {
    private val _data = MutableStateFlow<String>("")
    val data: StateFlow<String> = _data.asStateFlow()

    fun updateData(newData: String) {
        _data.value = newData
    }
}

class MyActivity : AppCompatActivity() {
    private val viewModel: MyViewModel by viewModels()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.data.collect { data ->
                    // 更新界面数据
                }
            }
        }
    }
}
```

#### DataStore

#### Room

#### WorkManager

### 依赖管理

- 通过构造函数注入或 Hilt 库进行依赖注入
- 依赖注入使类能够定义其依赖项而不构造它们. 在运行时, 另一个类负责提供这些依赖项.
- 服务定位器: 服务定位器模式提供了一个注册表, 类可以从中获取其依赖项而不构造它们.

Dagger&Hilt 中常见的注解及其功能的详细介绍:

- `@HiltAndroidApp`: 用于标记应用程序的 `Application` 类以在应用程序启动时触发 `Hilt` 的代码生成, 基于 Dagger 生成和管理依赖注入的必要组件.
- `@AndroidEntryPoint`: 用于标记 `Activity`, `Fragment`, `View`, `Service`, `BroadcastReceiver` 等 Android 组件, 使其成为的依赖注入的入口点, 表示他们需要被注入依赖项.
- `@HiltViewModel`: 用于标记 `ViewModel` 类, 以告知依赖注入框架为 `ViewModel` 类提供依赖注入.
- `@Inject`: 用于标记构造函数, 字段, 方法或属性, 表示它们是依赖注入的目标, 从而自动为这些目标注入所需的依赖项. (除了默认的一些依赖, 其他依赖项都需要通过 `@Module` 来告知如何提供)
- `@Module`: 标记一个 `object` 类为依赖注入模块, 模块中的方法可以通过 `@Provides` 注解告知依赖注入框架如何提供依赖项.
- `@InstallIn`: 用于标记 `@Module` 类, 以指定该模块的生命周期和作用域. 如 `ApplicationComponent`, `ActivityComponent`, `FragmentComponent`, `ServiceComponent`, `BroadcastReceiverComponent` 等.
- `@Provides`: 用于标记 `@Module` 类中的方法, 以告知依赖注入框架如何提供依赖项.
- `@Singleton`: 用于标记依赖项的作用域, 表示该依赖项在所在的依赖注入模块的整个生命周期中只会被创建一次.
- `@Binds`: 标记一个 `abstract` 抽象类为依赖注入模块, 模块中的抽象方法可以通过 `@Binds` 注解告知依赖注入框架如何将抽象接口方法的依赖项与具体实现绑定.
- `@Qualifier`: 标记一个 `annotation` 注解类来自定义依赖项类型注解, 以通过注解的形式告知依赖注入框架何区分相同类型的不同依赖项实现.
- `@Named`: 内置的用于标记依赖项的类型注解, 以通过注解的形式告知依赖注入框架何区分相同类型的不同依赖项实现.
- `@ViewModelInject`: 内置的用于标记 `ViewModel` 类的构造函数, 以告知依赖注入框架为 `ViewModel` 类提供依赖注入.
- `@EntryPoint`: 定义 Hilt 组件外部的依赖项的入口点. 可以让非 Hilt 管理的类也能获取依赖项.
- `@ApplicationContext`: 内置的用于标记 `Context` 类型的依赖项, 以告知依赖注入框架注入的是应用程序的 `Context` 对象.
- `@ActivityRetainedScoped`: 内置的用于定义依赖项的生命周期与 `Activity` 保持一致.

```kotlin
@HiltAndroidApp
class MyApplication : Application()

@Qualifier
@Retention(AnnotationRetention.BINARY)
annotation class MyQualifier

@Module
@InstallIn(SingletonComponent::class)
object MyModule {
    @Provides
    @Singleton
    fun provideMyDependency(): MyDependency {
        return MyDependency()
    }

    @Provides
    @Named("MyDependency")
    fun provideNamedDependency(): MyDependency {
        return MyDependency()
    }

    @Provides
    @MyQualifier
    fun provideQualifiedDependency(): MyDependency {
        return MyDependency()
    }
}

@Module
@InstallIn(ApplicationComponent::class)
abstract class MyAbstractModule {
    @Binds
    abstract fun bindMyDependency(impl: MyDependencyImpl): MyDependency
}

@AndroidEntryPoint
class MyActivity : AppCompatActivity() {
    @Inject
    @Named("MyDependency")
    lateinit var myDependency: MyDependency
}

@HiltViewModel
class MyViewModel @Inject constructor(
    @MyQualifier private val myDependency: MyDependency
) : ViewModel()

@EntryPoint
@InstallIn(ApplicationComponent::class)
interface MyEntryPoint {
    fun myDependency(): MyDependency
}

class MyService : Service() {
    private val myDependency: MyDependency by lazy {
        EntryPointAccessors.fromApplication(this, MyEntryPoint::class.java).myDependency()
    }
}
```

### 项目测试

> [!cite] > [Android 测试模块](https://developer.android.com/topic/modularization/patterns#test-modules) > [Android 测试](https://developer.android.com/training/testing?hl=zh-cn)

- 测试内容

    - 对 ViewModel (包括 Flow) 进行单元测试
    - 对数据层实体进行单元测试. 即对代码库和数据源进行单元测试
    - 进行界面导航测试 (可在持续集成环境中用作回归测试)
    - 测试 StateFlow 和 LiveData 的行为

        - 尽可能对 value 属性进行断言
        - 如果使用 WhileSubscribed, 您应该创建一个 collectJob

### 模块组织

- 项目模块化: 将应用程序拆分为多个模块, 以便更容易管理和维护, 以下是从高到低的模块组织结构:

    - 应用模块(app): 包含界面入口点, 依赖于功能模块, 支持产品变种(`productFlavors`), 编译为不同的二进制文件, 如不同设备或不同版本的 APK 文件, 以及不同的构建类型(`buildTypes`), 如调试和发布版本.
    - 功能模块(feature): 包含一系列相关的屏幕. 对于导航栏, 每个功能可能对应一个目的地. 依赖于数据模块和通用模块.
    - 通用模块(core): 包含应用程序中多个模块之间共享的代码, 如工具类、扩展函数、自定义视图等.
    - 数据模块(data): 包含存储库(`Repository`)、数据源(`DataSource`)和模型类(`Model`), 用于封装特定领域的所有数据和业务逻辑, 将存储库公开为外部 API.
    - 测试模块(test): 包含单元测试和 UI 测试, 用于测试应用程序的各个部分.

- 注意事项:

    - 模块间需要相互依赖并通信时, 可以通过将相关逻辑放在另一个中介模块中进行解耦, 以避免直接依赖. 同时此中介模块可以被其他任何需要此逻辑的模块复用.
    - 高级模块(业务逻辑)不应该直接依赖于低级模块的具体实现, 而是应该依赖于其抽象接口. 这样可以方便低级模块的替换, 扩展和测试. 具体项目中可以同时创建一个 `api` 模块和一个 `impl` 模块, `api` 模块定义接口, `impl` 模块实现接口.

()[![https://developer.android.com/static/topic/libraries/architecture/images/mad-arch-ui-udf-in-action.png?hl=zh-cn](https://developer.android.com/static/topic/libraries/architecture/images/mad-arch-ui-udf-in-action.png?hl=zh-cn)]

### 架构代码样例

```kotlin

data class Author(
    val id: String,
    val name: String,
)

data class LoginUiState(
    val isLoading: Boolean = false,
    val errorMessage: String? = null,
    val isUserLoggedIn: Boolean = false
)

class LoginViewModel : ViewModel() {
    private val _uiState = MutableStateFlow(LoginUiState())
    val uiState: StateFlow<LoginUiState> = _uiState.asStateFlow()
    /* ... */
}

class LoginActivity : AppCompatActivity() {
    private val viewModel: LoginViewModel by viewModels()

    override fun onCreate(savedInstanceState: Bundle?) {
        /* ... */

        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.uiState.collect { uiState ->
                    if (uiState.isUserLoggedIn) {
                        // Navigate to the Home screen.
                    }
                    ...
                }
            }
        }
    }
}

private const val DOB_VALIDATION_KEY = "dobValidationKey"

class DobValidationFragment : Fragment() {

    private var validationInProgress: Boolean = false
    private val viewModel: DobValidationViewModel by viewModels()

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        val binding = // ...
        validationInProgress = savedInstanceState?.getBoolean(DOB_VALIDATION_KEY) ?: false

        binding.continueButton.setOnClickListener {
            viewModel.validateDob()
            validationInProgress = true
        }

        viewLifecycleOwner.lifecycleScope.launch {
            viewModel.uiState
                .flowWithLifecycle(viewLifecycleOwner.lifecycle)
                .collect { uiState ->
                    // Update other parts of the UI ...

                    // If the input is valid and the user wants
                    // to navigate, navigate to the next screen
                    // and reset `validationInProgress` flag
                    if (uiState.isDobValid && validationInProgress) {
                        validationInProgress = false
                        navController.navigate(...) // Navigate to next screen
                    }
                }
        }

        return binding
    }

    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)
        outState.putBoolean(DOB_VALIDATION_KEY, validationInProgress)
    }
}



data class NewsItem(
    val title: String,
    val body: String,
    val bookmarked: Boolean = false,
    val publicationDate: String,
    val onBookmark: () -> Unit
)

data class Message(val id: Long, val message: String)
data class NewsUiState(
    val isSignedIn: Boolean = false, // 状态属性
    val isPremium: Boolean = false,
    val isFetchingArticles: Boolean = false, // 加载状态
    val newsItems: List<NewsItem> = listOf(), // 数据
    val userMessages: List<Message> = listOf() // 反馈信息
)
val NewsUiState.canBookmarkNews: Boolean get() = isSignedIn && isPremium // 其他属性的派生属性
interface NewsRepository{}

class NewsViewModel : ViewModel() {
    private val repository: NewsRepository
    private val formatDateUseCase: FormatDateUseCase,
    private val _uiState = MutableStateFlow(NewsUiState())
    val uiState: StateFlow<NewsUiState> = _uiState.asStateFlow()
    val newsListUiItems = repository.latestNews.map { news ->
        NewsItemUiState(
            title = news.title,
            body = news.body,
            bookmarked = news.bookmarked,
            publicationDate = formatDateUseCase(news.publicationDate),
            // Business logic is passed as a lambda function that the
            // UI calls on click events.
            onBookmark = {
                repository.addBookmark(news.id)
            }
        )
    }

    private var fetchJob: Job? = null

    fun fetchArticles(category: String) {
        fetchJob?.cancel()
        fetchJob = viewModelScope.launch {
            try {
                val newsItems = repository.newsItemsForCategory(category)
                _uiState.update {
                    it.copy(newsItems = newsItems)
                }
            } catch (ioe: IOException) {
                // Handle the error and notify the UI when appropriate.
                _uiState.update {
                    val messages = getMessagesFromThrowable(ioe)
                    it.copy(userMessages = messages)
                 }
            }
        }
    }

    fun refreshNews() {
        viewModelScope.launch {
            // If there isn't internet connection, show a new message on the screen.
            if (!internetConnection()) {
                _uiState.update { currentUiState ->
                    currentUiState.copy(userMessages = arrayOf(["No Internet connection"]))
                }
                return@launch
            }

            // Do something else.
        }
    }

    fun userMessageShown() {
        _uiState.update { currentUiState ->
            currentUiState.copy(userMessage = null)
        }
    }

}

class NewsActivity : AppCompatActivity() {
    private lateinit var binding2: ActivityLoginBinding
    private lateinit var binding: ActivityLatestNewsBinding
    private val viewModel: NewsViewModel by viewModels()

    override fun onCreate(savedInstanceState: Bundle?) {
        ...

        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                // 界面根据新数据, 更新要显示的数据
                viewModel.uiState
                    .map { it.isFetchingArticles }
                    .distinctUntilChanged()
                    .collect { progressBar.isVisible = it }
                // 根据状态的更改, 界面进行响应
                viewModel.uiState.collect { uiState ->
                    // 根据一些信息的更改, 界面进行一些通知
                    uiState.userMessage?.let {
                        // TODO: Show Snackbar with userMessage.

                        // Once the message is displayed and
                        // dismissed, notify the ViewModel.
                        viewModel.userMessageShown()
                    }
                }
            }
        }

        binding.expandButton.setOnClickListener {
            binding.expandedSection.visibility = View.VISIBLE
        }

        binding.refreshButton.setOnClickListener {
            viewModel.refreshNews()
        }

        binding2.helpButton.setOnClickListener {
            navController.navigate(...) // Open help screen
        }
    }
}

data class ArticleApiModel(
    val id: Long,
    val title: String,
    val content: String,
    val publicationDate: Date,
    val modifications: Array<ArticleApiModel>,
    val comments: Array<CommentApiModel>,
    val lastModificationDate: Date,
    val authorId: Long,
    val authorName: String,
    val authorDateOfBirth: Date,
    val readTimeMin: Int
)

data class Article(
    val id: Long,
    val title: String,
    val content: String,
    val publicationDate: Date,
    val authorName: String,
    val readTimeMin: Int
)

class NewsRemoteDataSource(
  private val newsApi: NewsApi,
  private val ioDispatcher: CoroutineDispatcher
) {
    /**
     * Fetches the latest news from the network and returns the result.
     * This executes on an IO-optimized thread pool, the function is main-safe.
     */
    suspend fun fetchLatestNews(): List<ArticleHeadline> =
        // Move the execution to an IO-optimized thread since the ApiService
        // doesn't support coroutines and makes synchronous requests.
        withContext(ioDispatcher) {
            newsApi.fetchLatestNews()
        }
    }

// Makes news-related network synchronous requests.
interface NewsApi {
    fun fetchLatestNews(): List<ArticleHeadline>
}

// NewsRepository is consumed from other layers of the hierarchy.
class NewsRepository(
    private val newsRemoteDataSource: NewsRemoteDataSource,
        // This could be CoroutineScope(SupervisorJob() + Dispatchers.Default).
    private val externalScope: CoroutineScope
) {
    suspend fun fetchLatestNews(): List<ArticleHeadline> =
        newsRemoteDataSource.fetchLatestNews()
    // Mutex to make writes to cached values thread-safe.
    private val latestNewsMutex = Mutex()

    // Cache of the latest news got from the network.
    private var latestNews: List<ArticleHeadline> = emptyList()

    suspend fun getLatestNews(refresh: Boolean = false): List<ArticleHeadline> {
        return if (refresh) {
            externalScope.async {
                newsRemoteDataSource.fetchLatestNews().also { networkResult ->
                    // Thread-safe write to latestNews.
                    latestNewsMutex.withLock {
                        latestNews = networkResult
                    }
                }
            }.await()
        } else {
            return latestNewsMutex.withLock { this.latestNews }
        }
    }
}

class RefreshLatestNewsWorker(
    private val newsRepository: NewsRepository,
    context: Context,
    params: WorkerParameters
) : CoroutineWorker(context, params) {

    override suspend fun doWork(): Result = try {
        newsRepository.refreshLatestNews()
        Result.success()
    } catch (error: Throwable) {
        Result.failure()
    }
}

private const val REFRESH_RATE_HOURS = 4L
private const val FETCH_LATEST_NEWS_TASK = "FetchLatestNewsTask"
private const val TAG_FETCH_LATEST_NEWS = "FetchLatestNewsTaskTag"

class NewsTasksDataSource(
    private val workManager: WorkManager
) {
    fun fetchNewsPeriodically() {
        val fetchNewsRequest = PeriodicWorkRequestBuilder<RefreshLatestNewsWorker>(
            REFRESH_RATE_HOURS, TimeUnit.HOURS
        ).setConstraints(
            Constraints.Builder()
                .setRequiredNetworkType(NetworkType.TEMPORARILY_UNMETERED)
                .setRequiresCharging(true)
                .build()
        )
            .addTag(TAG_FETCH_LATEST_NEWS)

        workManager.enqueueUniquePeriodicWork(
            FETCH_LATEST_NEWS_TASK,
            ExistingPeriodicWorkPolicy.KEEP,
            fetchNewsRequest.build()
        )
    }

    fun cancelFetchingNewsPeriodically() {
        workManager.cancelAllWorkByTag(TAG_FETCH_LATEST_NEWS)
    }
}

```

## UI

应用的界面 (UI) 就是您在屏幕上所看到的内容 (文本、图片、按钮和许多其他类型的元素) 及其在屏幕上的布局方式.

### 界面状态保存

### 临时存放

Jetpack Compose 可以使用在项目的  Android 自动生成的 `R`  类中通过资源 ID 访问 Android 项目中定义的资源.

- `painterResource()`  函数会加载可绘制图片资源, 并将资源 ID (在本例中为  `R.drawable.androidparty` ) 作为实参.
- `stringResource()`

`onCreate()`  函数中的  [setContent()](https://developer.android.com/reference/kotlin/androidx/compose/ui/platform/ComposeView?hl=zh-cn#setContent(kotlin.Function0))[setContent()](https://developer.android.com/reference/kotlin/androidx/compose/ui/platform/ComposeView?hl=zh-cn#setContent(kotlin.Function0))  函数用于通过可组合函数定义布局.

可组合函数 Jetpack Compose 是用于构建 Android 界面的新款工具包. 任何标有  `@Composable`  注解的函数都可通过  `setContent()`  函数或其他可组合函数进行调用. 该注解可告知 Kotlin 编译器 Jetpack Compose 使用的这个函数会生成 UI.

注解

```kotlin
@Composable
@Preview
```

修饰符 [Modifier](https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier?hl=zh-cn)[Modifier](https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier?hl=zh-cn)  用于扩充或修饰可组合项, 如修饰组件的布局.

- 内边距修饰符 (`Modifier.padding`) 在  `Text`  可组合项的周围添加空间.

```kotlin
Modifier.padding(
    start = 16.dp,
    top = 16.dp,
    end = 16.dp,
    bottom = 16.dp
)

Modifier
    .padding(16.dp)
    .align(alignment = Alignment.End)
```

- 背景颜色修饰符 `Modifier.background`

![_](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-add-images/img/df69881d07b064d0.gif?hl=zh-cn)

基本标准布局元素是  `Column`、`Row,`  和  `Box`.

- [Box](https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/package-summary?hl=zh-cn#Box(androidx.compose.ui.Modifier,androidx.compose.ui.Alignment,kotlin.Boolean,kotlin.Function1))[Box](https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/package-summary?hl=zh-cn#Box(androidx.compose.ui.Modifier,androidx.compose.ui.Alignment,kotlin.Boolean,kotlin.Function1))  布局是 Compose 中的标准布局元素之一. 使用  `Box`  布局可将元素堆叠在一起. `Box`  布局还可用于配置它所包含的元素的特定对齐方式.

应用在某些情况下可能会被翻译成其他语言, 一些固定的 `String`  数据类型可以提取到资源文件中进行管理, 避免硬编码导致无法进行翻译.

@JvmOverloads constructor 用于自动在 java 中生成各种重载的构造函数

[ConstraintLayout 之 ConstraintSet - enzo 的博客](https://enzowyf.github.io/constraintset.html)

// 设置控件尺寸  
// constrainWidth/constrainHeight  
// constrainDefaultWidth/constrainDefaultHeight  
// constrainMaxWidth/constrainMaxHeight  
// constrainMinWidth/constrainMinHeight

// 设置控件间直接约束关系

// 控件 start 的某边与 end 的某边对齐, margin 用于设置边与边中间间距  
// connect(int startID, int startSide, int endID, int endSide, int margin)  
// connect(int startID, int startSide, int endID, int endSide)

// 控件 center 置于另两个控件 first 和 second 之间, bias(0~1) 用于设置位置偏移比例  
// center(int centerID, int firstID, int firstSide, int firstMargin, int secondID, int secondSide, int secondMargin, float bias)  
// 控件 center 水平居中于另一个控件 centerID, leftId/rightId 用于设置左右边界控件  
// centerHorizontally(int centerID, int leftId, int leftSide, int leftMargin, int rightId, int rightSide, int rightMargin, float bias)

// 方向: ConstraintSet.TOP/BOTTOM/START/END/LEFT/RIGHT/BASELINE(TextView)

// 控件 viewId 与 toView 水平居中  
// centerHorizontally(int viewId, int toView)  
// 控件 viewId 与 toView 垂直居中  
// centerVertically(int viewId, int toView)

// 修改控件属性  
// setVisibility/setAlpha/setRotation  
// setRotationX/setRotationY  
// setScaleX/setScaleY/setTransformPivot/setTransformPivotX/setTransformPivotY  
// setTranslation/setTranslationX/setTranslationY/setTranslationZ  
// setElevation

RecyclerView ( `RecyclerView` 和 `RecyclerView.LayoutManager` )

- 数据驱动：需要一个数据源来提供要显示的数据, 见 `RecyclerView.Adapter` 和 `RecyclerView.ViewHolder`
- 可重用性：支持视图的重用机制, 通过重用池来减少内存开销, 见 `onCreateViewHolder` 和 `onBindViewHolder`
- 布局管理：支持多种布局, 通过不同的布局管理器来控制视图的显示方式 (如网格、列表等) , 见 `LinearLayoutManager` 、 `GridLayoutManager` 、 `StaggeredGridLayoutManager`
- 自定义单元格：允许自定义单元格, 以便显示复杂的内容. 创建自定义的 `ViewHolder` 子类, 然后在 `Adapter` 中使用这个 `ViewHolder`, 在 `onCreateViewHolder` 和 `onBindViewHolder` 方法中绑定 `ViewHolder`.

### 基础组件

`AbsListView` 是一个抽象类, 不能用作应用程序布局中的 `View` 元素, 尽管您可以将其用作 `Base Class` 来实现您自己的 `View`. 在  
`AbsoluteLayout` 要被弃用了. 允许您指定其子级的确切位置 (x/y 坐标) 的布局. 与没有绝对定位的其他类型的布局相比, 绝对布局不太灵活且更难以维护.  
`AbsSeekBar` 和 `AbsSpinner` 全是抽象类.  
`ActionMenuView`, 操作菜单视图, 支持接收菜单项单击事件的接口(看到有人当做底部菜单栏使用的).  
`Adapter` 适配器就像数据源和用户界面之间的桥梁. 它从各种数据源读取数据, 将其转换为 `View` 对象, 并将其提供给链接的 `Adapter` 视图以创建 UI 组件.  
`AdapterView` 适配器视图可用于以列表或网格等形式有效地显示由适配器提供的大量数据. `Adapter` 获取数据并根据该数据创建一个 `View , 然后将该`View `提供给`AdapterView `. 然后`AdapterView `以想要的方式显示数据.`AlphabetIndexer `实现`SectionIndexer `接口的适配器的辅助类. 如果适配器中的项目通过简单的基于字母的排序进行排序, 则此类提供了一种使用二分搜索对大型列表进行快速索引的方法. 在`ListView `或`RecyclerView `中, 可以使用`AlphabetIndexer `来为列表提供分节导航.`AnalogClock `被弃用了`BaseAdapter`

- `ArrayAdapter` 通过此类可以从数组获取 `AdapterView`,
- `CursorAdapter`
- `SimpleAdapter`
- `ResourceCursorAdapter`
- `SimpleCursorAdapter`

`AutoCompleteTextView` 可编辑的文本视图, 在用户键入时自动显示完成建议. 建议列表显示在下拉菜单中, 用户可以从中选择一个项目来替换编辑框的内容. 建议列表是从数据适配器获取的  
`CalendarView` 用于显示和选择日期的日历小部件.  
`CheckBox`, 创建一个复选框选项, 每个复选框都是单独管理的, 必须为每个复选框注册点击监听器.  
`CheckedTextView`, 扩展 `TextView` 支持 `Checkable` 界面和显示. 也就是说文本支持选中后复选支持.  
`Chronometer` 基于 `TextView` 实现的计时器. 控制和展示计时时间.  
`CompoundButton` 复合按钮, 抽象类, 具有两种状态的按钮, 选中和未选中(开和关). 当按下或单击按钮时, 状态会自动更改. 主要派生出了 `CheckBox`, `RadioButton`, `Switch`, `ToggleButton`  
`DialerFilter` 被弃用  
`DigitalClock` 被弃用  
`EdgeEffect` 用于在可滑动控件边缘提供视觉反馈, 例如 `ScrollView` 在滑动到边界时显示的弧形颜色效果.  
`EditText` 用于输入和修改文本的用户界面元素, 支持输入类型选择, 文本类型, 密码类型等.  
`ExpandableListView` 可扩展列表视图, 显示垂直滚动的两级列表中的项目的视图, 与 `ListView` 的不同之处在于允许两个级别：可以单独展开以显示其子级的组.  
`Filter` 过滤器使用过滤模式来异步约束数据, 细节待定.  
`FrameLayout` 框架布局, 可以添加多个子视图进行叠放, 新添加的视图, 会覆盖在旧视图上面.  
`Gallery` 被弃用了. 可以参考新的 `HorizontalScrollView` 和 `ViewPager`  
`GridLayout` 矩形网格布局, 可以指定网格的列数和行数. `GridLayout` 基本上将其子级放置在矩形网格中. 该网格有一组许多细线, 将视图区域分隔成单元格, N 列的网格, 那么我们将有 N+1 个从 0 开始的网格索引. 子项占据一个或多个连续的单元格, 由其 `rowSpec` 和 `columnSpec` 布局参数定义, 占据相同单元格的子项, 可能会产生重叠.  
`GridView` 网格视图, 将多个子项显示在支持滚动的二维网格的视图. 数据通过 Adapter 适配器与 GridView 连接, 并将每条数据插入到将在 GridView 中显示的适当项目中.  
`HeaderViewListAdapter`, 一个基类, 目前不需要学习.  
`HorizontalScrollView` 水平滚动视图, 也只支持水平滚动, 需要在其中放置一个包含要滚动的全部内容的子项, 在水平方向上, 呈现用户可以滚动浏览的顶级项目的水平数组.  
`ImageButton` 图像按钮, 显示一个带有图像 (而不是文本) 的按钮, 用户可以按下或单击该按钮.  
`ImageSwitcher` 图像切换器, 当在两个 `ImageView` 上设置新图像时, `ViewSwitcher` 在两个 `ImageView` 之间切换. 添加到 `ImageSwitcher` 的视图必须都是 `ImageView`.  
`ImageView` 图像视图, 显示图片资源, 例如 `Bitmap` 或者 `Drawable` 资源. I  
`LinearLayout` 线性布局, 将其他视图水平排列在单列中或垂直排列在单行中的布局.  
`ListPopupWindow` 列表弹出窗口, `ListPopupWindow` 将自身锚定到主视图并显示一个选项列表, 能够显示 `ListAdapter` 中的项目. , 进行包括定位、滚动父项以适应下拉菜单、与 IME (如果存在) 进行合理交互等.  
`ListView` 显示可垂直滚动的视图集合, 其中每个视图都位于列表中前一个视图的正下方.  
`Magnifier` 放大镜, `Android` 放大镜小部件. 可由附加到窗口的任何视图使用.  
`MediaController` 媒体控制器. 如果拥有 “android.permission.MEDIA_CONTENT_CONTROL” 权限或者是启用的通知侦听器, 或者直接从会话所有者获取 `MediaSession.Token`, 则可以通过 `MediaSessionManager` 创建 `MediaController`. 允许应用程序与正在进行的媒体会话交互. 媒体按钮和其他命令可以发送到会话. 可以注册回调以接收来自会话的更新, 例如元数据和播放状态变化.  
`MultiAutoCompleteTextView`,可编辑的文本视图, 扩展 `AutoCompleteTextView`, 可以显示用户正在键入的文本子字符串的补全建议, 而不只是整个内容. `AutoCompleteTextView` 仅提供有关整个文本的建议. 但是 `MultiAutoCompleteTextView` 为文本的子字符串提供了多种建议.  
`NumberPicker` 数字选择器, 一个小部件, 使用户能够从预定义范围中选择一个数字, 支持显示为可编辑输入字段, 上面有一个递增按钮, 下面有一个递减按钮. 也支持将当前值显示为可编辑输入字段, 上面的值较小, 下面的值较大. 点击较小或较大的值可以通过向上或向下动画数轴来选择该值, 以使所选值成为当前值. 向上或向下滑动允许当前值多次递增或递减. 长按较小和较大值还可以快速更改当前值. 点击当前值可以输入所需的值. 还支持将当前值显示为滚动垂直选择器, 所选值位于中心, 上方和下方是前一个和后一个数字, 并由分隔线分隔. 通过垂直滑动来更改该值.  
`OverScroller` 过滚, 封装了滚动能力, 同时支持超出滚动操作范围的能力.  
`PopupMenu` 弹出菜单, `PopupMenu` 在锚定到视图的模式弹出窗口中显示菜单. 如果有空间, 弹出窗口将出现在锚视图下方；如果没有空间, 则弹出窗口将出现在锚视图上方. 如果 `IME` 可见, 则弹出窗口不会与其重叠, 直到触摸它为止. 触摸弹出窗口外部会将其关闭.  
`PopupWindow` 弹出窗口. 此类表示可用于显示任意视图的弹出窗口. 弹出窗口是一个浮动容器, 出现在当前活动的顶部.  
`ProgressBar` 进度条. 指示操作进度的用户界面元素. 进度条支持两种表示进度的模式：确定和不确定. 不确定模式是进度条的默认模式, 显示循环动画, 但不指示具体的进度量. 当想要显示已发生特定数量的进度时, 请对进度栏使用确定模式. 例如, 正在检索的文件的剩余百分比、写入数据库的批次中的记录数量或正在播放的音频文件的剩余百分比.  
`QuickContactBadge`, 显示为一个小徽章, 用户单击该徽章即可快速创建联系人, 例如将电话号码或电子邮件添加到联系人列表.

- AbsListView
- AbsListView.LayoutParams
- AbsoluteLayout
- AbsoluteLayout.LayoutParams
- AbsSeekBar
- AbsSpinner
- ActionMenuView

    - ActionMenuView.LayoutParams

- AdapterView
- AdapterView.AdapterContextMenuInfo
- AdapterViewAnimator
- AdapterViewFlipper
- AlphabetIndexer
- AnalogClock
- ArrayAdapter
- AutoCompleteTextView
- BaseAdapter
- BaseExpandableListAdapter
- Button
- CalendarView
- CheckBox
- CheckedTextView
- Chronometer
- CompoundButton
- CursorAdapter
- CursorTreeAdapter
- DatePicker
- DialerFilter
- DigitalClock
- EdgeEffect
- EditText
- ExpandableListView

    - ExpandableListView.ExpandableListContextMenuInfo

- Filter

    - Filter.FilterResults

- FrameLayout

    - FrameLayout.LayoutParams

- Gallery

    - Gallery.LayoutParams

- GridLayout

    - GridLayout.Alignment
    - GridLayout.LayoutParams
    - GridLayout.Spec

- GridView
- HeaderViewListAdapter
- HorizontalScrollView
- ImageButton
- ImageSwitcher
- ImageView
- LinearLayout

    - LinearLayout.LayoutParams

- ListPopupWindow
- ListView

    - ListView.FixedViewInfo

- Magnifier

    - Magnifier.Builder

- MediaController
- MultiAutoCompleteTextView

    - MultiAutoCompleteTextView.CommaTokenizer

- NumberPicker
- OverScroller
- PopupMenu
- PopupWindow
- ProgressBar
- QuickContactBadge
- RadioButton
- RadioGroup

    - RadioGroup.LayoutParams

- RatingBar
- RelativeLayout

    - RelativeLayout.LayoutParams

- RemoteViews

    - RemoteViews.DrawInstructions
    - RemoteViews.DrawInstructions.Builder
    - RemoteViews.RemoteCollectionItems
    - RemoteViews.RemoteCollectionItems.Builder
    - RemoteViews.RemoteResponse
    - RemoteViews.RemoteViewOutlineProvider

- RemoteViewsService
- ResourceCursorAdapter
- ResourceCursorTreeAdapter
- Scroller
- ScrollView
- SearchView
- SeekBar
- ShareActionProvider
- SimpleAdapter
- SimpleCursorAdapter
- SimpleCursorTreeAdapter
- SimpleExpandableListAdapter
- SlidingDrawer
- Space
- Spinner
- StackView
- Switch
- TabHost

    - TabHost.TabSpec

- TableLayout

    - TableLayout.LayoutParams

- TableRow

    - TableRow.LayoutParams

- TabWidget
- TextClock
- TextSwitcher
- TextView

    - TextView.SavedState

- TimePicker
- Toast

    - Toast.Callback

- ToggleButton
- Toolbar

    - Toolbar.LayoutParams

- TwoLineListItem
- VideoView
- ViewAnimator
- ViewFlipper
- ViewSwitcher
- ZoomButton
- ZoomButtonsController
- ZoomControls
- InlineContentView
- InlinePresentationSpec

    - InlinePresentationSpec.Builder

### androidx 扩展组件

- ActionBar

    - ActionBar.LayoutParams
    - ActionBar.Tab

- ActionBarDrawerToggle
- AlertDialog

    - AlertDialog.Builder

- AppCompatActivity
- AppCompatDelegate
- AppCompatDialog
- AppCompatDialogFragment
- AppCompatViewInflater
- AppLocalesMetadataHolderService
- ActionMenuView

    - ActionMenuView.LayoutParams

- AppCompatAutoCompleteTextView
- AppCompatButton
- AppCompatCheckBox
- AppCompatCheckedTextView
- AppCompatEditText
- AppCompatImageButton
- AppCompatImageView
- AppCompatMultiAutoCompleteTextView
- AppCompatRadioButton
- AppCompatRatingBar
- AppCompatSeekBar
- AppCompatSpinner
- AppCompatTextView
- AppCompatToggleButton
- LinearLayoutCompat

    - LinearLayoutCompat.LayoutParams

- ListPopupWindow
- PopupMenu
- SearchView
- ShareActionProvider
- SwitchCompat
- ThemedSpinnerAdapter.Helper
- Toolbar

    - Toolbar.LayoutParams
    - Toolbar.SavedState

- TooltipCompat

### androidx 碎片组件(Fragment)

`Fragment`是 `Activity` 中使用的一种可重用 UI 组件, 可以在 `Activity` 中被添加、替换、移除, 也可以在 `Fragment` 中嵌套其他 `Fragment`, 有自己的生命周期, 可以与 `Activity` 共享生命周期.

- `Fragment` 生命周期回调方法: `onCreate()` , `onCreateView()` , `onViewCreated()` , `onViewStateRestored()` , `onStart()` , `onResume()` , `onPause()` , `onStop()` , `onSaveInstanceState()` , `onDestroyView()` , `onDestroy()`
- `Fragment` 生命周期状态: `CREATED`, `STARTED`, `RESUMED`, `DESTROYED`. 可以由 `getLifecycle().getCurrentState()` 获取当前状态
- `Fragment` 视图状态: `INITIALIZED` , `CREATED` , `STARTED` , `RESUMED` , `DESTROYED`. 可以由 `getViewLifecycleOwner().getLifecycle().getCurrentState()` 获取当前状态

实际开发中, `Fragment` 需要一个托管它的视图容器, 通常是一个 `FrameLayout` 等布局容器. 新的 API 提供了 `FragmentContainerView` 来代替 `FrameLayout`, 支持更好的视觉效果设置, 和额外的编辑器功能.

可以根据不同的场景获取不同的 `FragmentManager` 管理实例, 来管理场景内 `Fragment` 的添加、替换、移除等操作. `FragmentManager` 通过事务(`FragmentTransaction`) 和回退栈(`BackStack`) 来管理 `Fragment` 的状态和生命周期.

回退栈是一个后进先出的栈, 用于存储 `Fragment` 的状. 在应用的任意时刻, 只能有一个 `FragmentManager` 可以控制 `Fragment` 的回退栈, 所以在多 `Fragment` 的情况下, 需要使用 `setPrimaryNavigationFragment()` 方法在不同的导航片段之间切换主要导航控制权, 以便正确管理回退栈. 吃外如果需要支持多个回退栈, 可以使用 `saveBackStack()` 和 `restoreBackStack()` 方法来保存和恢复回退栈, 比如在导航栏切换时.

事务是一组针对 `Fragment`的操作集合, 通过 `beginTransaction()` 或 kotlin 扩展方法 `commit` 来创建和提交事务, 可以包括任意数量的操作. 事务执行时可以通过 `addToBackStack()` 方法在回退栈中保存事务, 这样可以通过 `popBackStack()` 方法来回退到上一个状态. 没添加到回退栈的事务会被立即执行, 但不会保存状态, 比如删除任务会立即删除和销毁, 无法回撤.

如果设备发生了配置变化 (如屏幕旋转) , Activity 及其所有 Fragment 都会被销毁并重新创建, 此时需要注意 `Fragment` 的实例初始化问题.

- Fragment

    - DialogFragment
    - PreferenceFragmentCompat
    - ListFragment

```kotlin
class MyFragment : Fragment() {
    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        return inflater.inflate(R.layout.fragment_my, container, false)
    }
}

class MyActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        if (savedInstanceState == null) {
            supportFragmentManager.beginTransaction()
                .add(R.id.fragment_container, MyFragment())
                .commit()
            // 或者
            supportFragmentManager.commit {
                add<MyFragment>(R.id.fragment_container)
            }
        }
    }
}
```

- FragmentContainer: 一个抽象类, 用于管理 Fragment 的容器, 通常是一个 ViewGroup
- FragmentContainerView: 一个 ViewGroup, 用于管理 Fragment 的容器
- FragmentManager:

    - 在 Activity 中通过 `getSupportFragmentManager()` 获取管理实例
    - 在 Fragment 中通过 `getChildFragmentManager()` 获取管理实例
    - 在 Child Fragment 中通过 `getParentFragmentManager()` 获取管理实例
    - 通过 `beginTransaction()` 创建事务, 类型为 `FragmentTransaction`
    - 通过 `commit()` 提交事务
    - 通过 `popBackStack()` 弹出回退栈
    - 通过 `addToBackStack()` 添加到回退栈
    - 通过 `add`, `replace`, `remove`, `hide`, `show` 等方法操作 Fragment
    - 通过 `findFragmentById()` 和 `findFragmentByTag()` 查找 Fragment
    - 通过 `getFragments()` 获取当前所有 Fragment
    - 通过 `setReorderingAllowed()` 设置是否允许事务操作的重新排序
    - 通过 `setCustomAnimations` 设置自定义动画, 应用于调用位置后续的所有 `Fragment` 操作

        - `setCustomAnimations(enter: Int, exit: Int, popEnter: Int, popExit: Int)`

- Fragment.SavedState
- FragmentActivity
- FragmentController
- FragmentFactory: 用于创建 Fragment 实例的工厂, 可以通过自定义工厂来控制 Fragment 的实例创建过程. 默认情况下, Fragment 会通过反射机制创建实例, 通过 `FragmentFactory` 可以自定义创建逻辑.
- FragmentHostCallback
- FragmentKt
- FragmentManager.FragmentLifecycleCallbacks
- FragmentManagerKt
- FragmentManagerNonConfig
- FragmentPagerAdapter
- FragmentStatePagerAdapter
- FragmentTabHost
- FragmentTransaction
- FragmentTransactionKt
- FragmentViewModelLazyKt
- ViewKt

```kotlin
class MainActivity : AppCompatActivity() {
    // 创建 Fragment 实例
    val fragment = MyFragment()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        if (savedInstanceState == null) {

            supportFragmentManager.commit {
                setReorderingAllowed(true)
                add<MyFragment>(R.id.fragment_container_view)
            }
        }
    }
}
```

### androidx 导航组件(Navigation)

特点:

- 固定起始目的地
- 通过堆栈管理目的地
- 向上和后退按钮功能一致
- 深度链接支持(深度链接时, 现有返回堆栈都将被删除, 基于导航图重建新的返回堆栈)

组成:

- Host: `NavHostFragment` 和 `NavHost`, 用来存储和展示所有导航目的地对象的 `Fragment` 容器组件, 使用时需要手动指定导航图

    - `navGraph` 属性绑定导航图
    - `defaultNavHost` 属性设置为 true, 以便使得此导航组件首先处理系统返回键事件.

- Graph: `NavGraph`, 定义导航目的地连接关系的数据结构, 构成一个导航图

    - 目的地类型: `fragment`, `activity`, `dialog`.

        - `fragment`, 目的对象充满整个 Host 区域
        - `activity`, 退出导航图所在的 `Activity`, 启动一个新的 `Activity`
        - `dialog`, 展示在之前的内容上方

- Controller: `NavController`, 管理目的地之间导航, 处理深层链接, 处理返回堆栈等的协调员

    - 保存导航图并公开允许您的应用程序在图中的目的地之间移动的方法
    - 使用导航组件时，您可以使用 NavController 类创建导航控制器。 NavController 是中央导航 API。它跟踪用户访问过的目的地，并允许用户在目的地之间移动。

- Destination: `NavDestination`, 导航图中的节点, 通常在构建导航图时创建
- Route: 任何可序列化的数据类型, 通过 Route 进行导航到达目的地

目的地类型有三种: `Hosted` , `Dialog` , `Activity`

- `Hosted` 会使得目的内容占满整个导航内容区域
- `Dialog` 会使得目的内容展示在之前的内容上方
- `Activity` 会退出导航图所在的 Activity, 启动一个与导航组件分开管理的新 Android 活动

### androidx 可重用视图(RecycleView)

> [!cite]
> [RecyclerView源码分析(二)—缓存机制](https://juejin.cn/post/6844904104641167368)
> [【进阶】RecyclerView源码解析(二)](https://www.jianshu.com/p/e44961f8add5)

`RecycleView` 是一个高度可定制的视图组件, 用于显示大量数据, 支持多种布局, 支持动画, 支持分页加载, 支持数据变化通知, 支持点击事件, 支持拖拽和滑动删除等功能.

`RecycleView` 可以动态的显示大量数据, 通过 `Adapter` 适配器将数据绑定到 `ViewHolder` 视图持有者上, `LayoutManager` 布局管理器控制视图绘制方式, `ItemDecoration` 控制视图左右额外间距, `ItemAnimator` 控制视图动画效果. 同时其内部的 `Recycler` 会通过四级缓存机制来重用视图, 以减少内存开销.

#### `RecycleView` 优化点

- 视图绑定优化
    - bindViewHolder() 方法运行在 UI 线程, 应避免耗时操作(如日期格式化).
    - 监听事件可以全局创建一个, 所有视图共用一个监听器, 放在 onCreateViewHolder() 中, 减少对象创建消耗.
- 数据更新优化
    - 使用 DiffUtil 进行局部刷新, 尽量避免 notifyDataSetChanged() 全局刷新带来的性能损耗.
    - 通过 setHasStableIds(true) + 重写 getItemId() 赋予 Item 唯一 ID, 使得焦点固定, 避免数据更新时闪烁.
- 布局优化
    - 减少嵌套层级, 降低 layout traversal 的复杂度
    - 高度固定的视图, 使用 setHasFixedSize(true) 来避免 requestLayout() 浪费资源.
- 预取与缓存优化
    - Prefetch 功能(API ≥ 21), 通过 setInitialPrefatchItemCount() 设置预取个数, 优化滑动性能.
    - 调整 RecyclerView 缓存大小: 默认 cacheView 大小为 2, 可适当增大, 用空间换取时间.
    - 当多个 RecyclerView 使用相同 Adapter 时, 可通过 setRecycledViewPool() 共用一个 RecycledViewPool, 减少 ViewHolder 创建的开销.

#### `ViewHolder`

视图持有者是一个用于存储实际视图的容器, 用于支持 `RecycleView` 中视图的重用机制, 内部包含了依附的 RecyclerView `mOwnerRecyclerView` 和目前绑定的适配器 `mBindingAdapter`, 视图相关数据(如引用 `itemView`, 类型 `itemViewType`, 位置`mPosition`, 唯一性 ID `mItemId`), 以及用于标记视图状态的标志位 `mFlags`. 同时提供了以下方法, 方便获取视图的信息:

- `getLayoutPosition()`: 获取视图在布局中的位置, 与屏幕展示位置一致. 可能由于适配器新数据没处理和展示完导致与适配器实际位置不一致.
- `getBindingAdapterPosition()`: 获取视图在所绑定的直接适配器中的内部相对位置. 可能由于 `notifyDataSetChanged()` 等方法导致位置失效.
- `getAbsoluteAdapterPosition()`: 获取视图在整个 `RecyclerView` 中顶层适配器中的绝对位置.

#### `Adapter`

适配器是数据源和视图之间的桥梁, 使用时需要继承 `RecyclerView.Adapter` 类, 同时实现一些必须或定制的方法:

- `onCreateViewHolder()`: 必须, 通过提供的视图类型(整型值)创建新的 `ViewHolder` 视图持有者, 视图类型来自于 `getItemViewType()` 方法, 可以控制展示不同的视图.
- `onBindViewHolder()`: 必须, 通过提供的位置, 将数据绑定到 `ViewHolder` 视图持有者上, 用于更新视图的展示内容.
- `getItemCount()`: 必须, 返回数据集的大小, 用于确定需要展示多少个视图.
- `getItemViewType()`: 可选, 返回视图类型(整型值), 用于创建不同的视图.
- `onViewAttachedToWindow()`: 可选, 当视图被添加到窗口时调用, 可以重新启动动画或之前停止的动作等.
- `onViewRecycled()`: 可选, 当视图被回收时调用, 可以清除旧图片资源, 监听器等, 优化资源占用和内存泄漏.
- `registerAdapterDataObserver()`: 可选, 注册数据变化监听器, 比如空数据时显示空视图, 数据加载失败时显示错误视图等.
- `onAttachedToRecyclerView()`: 可选, 当适配器附加到 `RecyclerView` 时调用, 可以为当前适配器设置特定的 `RecyclerView` 功能, 如更换滑动对齐方式等.

此外, 适配器还提供了一些可以外部调用的方法, 用于通知数据变化或设置状态:

- `notifyDataSetChanged()`: 通知数据集发生变化, 重新绑定所有数据.
- `notifyItemRangeChanged()`: 通过提供的数据起始位置, 数据数量, 通知此范围内的数据发生变化, 重新绑定数据. 此外可以通过 `payloads` 参数, 通知部分数据发生变化, 进行更精细化的数据更新.
- `notifyItemRangeInserted()`: 通过提供的数据起始位置, 数据数量, 通知此范围内的数据为新插入的数据, 实现数据插入效果.
- `notifyItemRangeRemoved()`: 通过提供的数据起始位置, 数据数量, 通知此范围内的数据被移除, 实现数据删除效果.
- `setStateRestorationPolicy()`: 设置状态恢复策略, 用于控制视图状态的恢复, 默认为 `ALLOW`, 可以设置为 `PREVENT` 阻止状态恢复, 或者 `PREVENT_WHEN_EMPTY` 当数据为空时阻止状态恢复, 有数据后再恢复状态.

#### `LayoutManager`

布局管理器是用于控制 `RecyclerView` 中视图的布局方式, 常见的布局方式有:

- `LinearLayoutManager`: 线性布局管理器, 支持垂直和水平两种布局方式. 一般用于可滑动查看的列表数据展示.
- `GridLayoutManager`: 网格布局管理器, 支持网格布局方式, 可以设置列数. 一般用于网格数据展示.
- `StaggeredGridLayoutManager`: 瀑布流布局管理器, 支持瀑布流布局方式, 可以设置列数和方向. 一般用于大小不一, 或高度和宽度不均的数据展示.

布局路径:

- 测量: `RecyclerView.OnMeasure` -> `RecyclerView.LayoutManager` -> `LayoutManager.onMeasure` -> `RecyclerView.setMeasuredDimension`
- 布局: `RecyclerView.OnLayout` -> `RecyclerView.dispatchLayoutStep1` -> `RecyclerView.dispatchLayoutStep2` -> `LayoutManager.onLayoutChildren` -> `RecyclerView.dispatchLayoutStep3`
    - `dispatchLayoutStep1`: 对应 `STEP_START` 布局状态
        - 收集动画数据: 记录条目在布局前的状态（位置、属性）, 为比较新旧状态生成动画提供依据;
        - 处理预测性布局: 预测条目在最终布局中的位置, 确保动画（如移动、删除）平滑过渡;
        - 协调适配器变更: 解析数据变化, 确定需要执行的动画类型, 并初始化相关上下文.
    - `dispatchLayoutStep2`: 对应 `STEP_LAYOUT` 布局状态
        - 数据同步与实际布局: 应用所有数据变更, 完成子视图的最终布局;
        - 状态恢复: 确保配置变更(如横竖屏切换)后恢复滚动位置等状态;
        - 动画准备: 为 dispatchLayoutStep3() 的动画阶段提供正确的布局信息(如最终位置).
    - `dispatchLayoutStep3`: 对应 `STEP_ANIMATIONS` 布局状态
        - 动画执行: 根据新旧数据和布局信息差异, 触发条目增删改动画(如移动、渐变、交叉动画);
        - 资源回收: 清理不可见或废弃的视图, 优化内存使用;
        - 状态重置: 重置 RecyclerView 恢复到稳定状态, 为下次布局做准备;
        - 回调与通知: 完成布局后的事件回调(如滚动、焦点恢复).
- 绘制: `RecyclerView.draw` -> `View.draw` -> `RecyclerView.onDraw` -> `ItemDecoration.onDraw` -> `View.dispatchDraw`(子视图绘制)

自定义布局管理器时需要继承 `RecyclerView.LayoutManager` 类, 同时实现一些必须或定制的方法(目前只是一部分, 后续遇到需要自定义布局时再完善):

- `onLayoutChildren()`: 必须, 用于布局子视图, 通过提供的 `RecyclerView.Recycler` 回收池和 `RecyclerView.State` 状态, 布局子视图, 用于初始化和更新视图.
- `onMeasure()`: (TODO)
- `isAutoMeasureEnabled()`: 可选, 返回是否启用自动测量, 默认为 false.
- `supportsPredictiveItemAnimations()`: 可选, 返回是否支持预测项动画, 默认为 false.
- `collectAdjacentPrefetchPositions()`: 可选, 收集相邻预取位置, 用于提前加载视图, 只在启用预取时调用, 默认为空实现.
- `collectInitialPrefetchPositions()`: 可选, 收集初始预取位置, 用于提前加载视图, 只在启用预取时调用, 默认为空实现.
- `onAttachedToWindow()`: 可选, 当布局管理器附加到 `RecyclerView` 时调用, 可以为当前布局管理器设置特定的 `RecyclerView` 功能, 如更换滑动对齐方式等.
- `onDetachedFromWindow()`: 可选, 当布局管理器从 `RecyclerView` 分离时调用, 可以清除旧图片资源, 监听器等, 优化资源占用和内存泄漏.

此外, 布局管理器还提供了一些可以外部调用的方法, 用于控制视图的布局方式:

- `setItemPrefetchEnabled()`: 设置是否启用预取, 用于提前加载视图, 默认为 true.

#### `ItemDecoration`

用于在 `RecyclerView` 中为子视图添加边距或装饰.

- `getItemOffsets()`: 用于为子视图添加边距, 通过提供的 `Rect` 对象, 为子视图设置上下左右的边距. 注意 子视图并不知道自己的边距, 即其并不在子视图 padding 计算中.
- `onDraw()`: 用于在子视图上绘制装饰, 通过提供的 `Canvas` 画布对象, 在子视图上绘制装饰.
- `onDrawOver()`: 用于在子视图上绘制装饰, 通过提供的 `Canvas` 画布对象, 在子视图上绘制装饰, 与 `onDraw()` 方法不同的是, `onDrawOver()` 方法绘制的装饰会覆盖在子视图上, 不会影响子视图的点击事件.

#### `ItemAnimator`

`RecyclerView.ItemAnimator` 用于在 `RecyclerView` 中展示视图不同状态变更时的动画效果, 通过 `animateAppearance()`, `animateChange()`, `animatePersistence()`, `animateDisappearance()` 四个方法控制, 通过 `runPendingAnimations()` 方法来执行动画效果. 每个方法都会提供 `RecyclerView.ViewHolder` 视图持有者和 `ItemHolderInfo` 信息, 用于为视图设置动画效果. `SimpleItemAnimator` 是 `ItemAnimator` 的再封装, 提供了更移动的 API.

- `animateAppearance()`: 视图出现在屏幕时的动画效果.
- `animateDisappearance()`: 视图从屏幕消失的动画效果.
- `animatePersistence()`: 视图布局改变(数据没改变)时的动画效果.
- `animateChange()`: 视图数据改变时的动画效果.
- `runPendingAnimations()`: 执行所有等待的动画效果.

#### `Recycler`

回收池用于管理 `RecyclerView` 缓存和回收的 `ViewHolder`, 以支持其视图重用机制.

存(插入或删除):  `mAttachedScrap`
存(滑动): `mChangedScrap` -> `mCachedViews`

- `mAttachedScrap`: 一级缓存, 用于存储因为布局改变暂时回收的视图持有者.
- `mChangedScrap`: 一级缓存, 用于存储因为数据改变暂时回收的视图持有者.
- `mCachedViews`: 二级缓存, 用于存储完全脱离屏幕布局, 且可以直接重用的视图持有者.
- `mViewCacheExtension`: 三级缓存, 用户自定义的扩展缓存, 直接存储对应位置和类型的视图 `View`. 默认无.
- `mRecyclerPool`: 四级缓存, 可自定义的, 能支持用于多个 `RecyclerView` 的全局化缓存池, 存储和管理 `ScrapData` 数据结构. 默认不共享, 单 `RecyclerView` 使用.

#### 基本使用

```kotlin
val recyclerView: RecyclerView = findViewById(R.id.recycler_view)
val dataset = arrayOf("January", "February", "March")
val adapter = CustomAdapter(dataset)
val itemDecoration = DividerItemDecoration(this, DividerItemDecoration.VERTICAL)
recyclerView.adapter = adapter
recyclerView.layoutManager = LinearLayoutManager(this)
recyclerView.addItemDecoration(itemDecoration)

data class DataClass(
    val text: String,
    val viewType: Int
    )

class CustomAdapter(private val dataset: Array<DataClass>) : RecyclerView.Adapter<CustomAdapter.ViewHolder>() {
    class ViewHolder(val textView: TextView) : RecyclerView.ViewHolder(textView)

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val textView = TextView(parent.context)

        return when (viewType) {
            0 -> ViewHolder(textView)
            1 -> ViewHolder(textView)
            2 -> ViewHolder(textView)
            else -> ViewHolder(textView)
        }
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        holder.textView.text = dataset[position].text
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int, payloads: MutableList<Any>
    ) {
        if (payloads.isEmpty()) {
            super.onBindViewHolder(holder, position, payloads)
        } else {
            val item = payloads[0] as DataClass
            holder.textView.text = item.text
        }
    }

    override fun getItemViewType(position: Int): Int {
        return dataset[position].viewType
    }

    override fun getItemCount() = dataset.size
}

```

#### 扩展 DiffUtil

`DiffUtil` 是一个用于计算两个数据集之间差异的工具类, 通过 `DiffUtil.Callback` 回调类, 用于提供两个数据集的比较, 以及如何更新数据集的方法. `DiffUtil` 会通过 `calculateDiff()` 方法计算两个数据集之间的差异, 并返回一个 `DiffUtil.DiffResult` 对象, 用于通过 `dispatchUpdatesTo` 自动调用 `Adapter` 的更新方法.

- `getOldListSize()`: 返回旧数据集的大小.
- `getNewListSize()`: 返回新数据集的大小.
- `areItemsTheSame()`: 返回两个数据集中的数据是否相同.
- `areContentsTheSame()`: 返回两个数据集中的数据内容是否相同.
- `getChangePayload()`: 返回两个数据集中的数据内容差异.
- `dispatchUpdatesTo()`: 通过提供的 `Adapter` 对象, 自动调用 `Adapter` 的更新方法.

```kotlin
data class DataClass(
    val text: String,
    val viewType: Int
    )

class CustomAdapter(private var dataset: List<DataClass>) : RecyclerView.Adapter<CustomAdapter.ViewHolder>() {
    class ViewHolder(val textView: TextView) : RecyclerView.ViewHolder(textView)

    fun updateData(newData: List<DataClass>) {
        val diffResult = DiffUtil.calculateDiff(object : DiffUtil.Callback() {
            override fun getOldListSize() = dataset.size
            override fun getNewListSize() = newData.size
            override fun areItemsTheSame(oldItemPosition: Int, newItemPosition: Int) =
                dataset[oldItemPosition] == newData[newItemPosition]
            override fun areContentsTheSame(oldItemPosition: Int, newItemPosition: Int) =
                dataset[oldItemPosition] == newData[newItemPosition]
        })
        dataset = newData
        diffResult.dispatchUpdatesTo(this)
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val textView = TextView(parent.context)
        return ViewHolder(textView)
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        holder.textView.text = dataset[position].text
    }

    override fun getItemCount() = dataset.size
}
```

### androidx 分页组件(paging)

> [!cite]
> [Paging 3.0](https://juejin.cn/post/6898133386218045453?searchId=202503241617260A81A495A89AC150A74F)

`Paging` 是基于 `RecyclerView` 和 `Flow` 的专注于分页数据加载的库, 与 `RecyclerView` 解耦, 同时提供了标准化的分页生命周期管理, 开发者只需关注数据加载规则.

#### 架构设计(MVVM)

| 架构层       | Paging 组件                                     | 职责说明                                 |
|--------------|--------------------------------------------------|------------------------------------------|
| Model    | `PagingSource` / `RemoteMediator`               | 定义分页加载逻辑（本地/远程），数据来源   |
| ViewModel | `Pager` + `PagingConfig` + `Flow<PagingData>`   | 构建分页流，管理加载状态与缓存            |
| View     | `PagingDataAdapter` / `LoadStateAdapter` / `LoadState` | 展示数据，监听加载状态，处理刷新/重试等 |

---

#### 组件介绍

- 引入 `PagingSource<Key : Any, Value : Any>` 将业务数据抽象为统一的, 支持分页的异步数据源.
    - 泛型参数 `<Key, Value>`: `Key` 用于唯一页码标识, `Value` 用于表示数据项类型. 其中 `Key` 必须实现 `Any` 接口, 以支持分页数据的唯一标识.
    - `load(params: LoadParams<Key>)`: 指定如何从数据源中加载特定页的数据, 并返回一个分页数据结果 `LoadResult`.
    - `LoadParams<Key>`: 封装加载请求参数的密封类, 包含请求加载的项目数量 `loadSize`, 是否启用了占位符 `placeholdersEnabled`, 请求加载的页码标识 `key`. 具体类型 `Refresh`: 刷新, `Prepend`: 前一页, `Append`: 后一页.
    - `LoadResult<Key, Value>`: 封装加载结果的密封类. 分具体类型 `Error(throwable: Throwable)`: 加载失败, 携带异常信息; `Invalid`: 无效加载, 终止请求数据源, 并自动触发 `invalidate()`; `Page(data: List<Value>, prevKey: Key?, nextKey: Key?), itemsBefore: Int, itemsAfter: Int`: 加载成功, 携带数据列表, 前一页码, 后一页码, 前面的数据数量, 后面的数据数量.
    - `Page<Key, Value>`: 封装加载成功的分页数据, 包含业务数据列表 `data`, 前一页码 `prevKey`, 后一页码 `nextKey`, 前面的数据数量 `itemsBefore`, 后面的数据数量 `itemsAfter`. 其中 `prevKey` 和 `nextKey` 可以为 null, 表示没有前一页或后一页.
    - `getRefreshKey(state: PagingState<Key, Value>)`: 用于在刷新时提供当前页的页码标识(Key).
        - `PagingState` 用于保存当前数据状态快照, 包含已加载的分页数据列表 `pages`, 最近浏览的业务数据 item 位置 `anchorPosition`, 初始化数据流时的配置 `config`, 首项前的占位符数量 `leadingPlaceholderCount` 等.
        - 一般通过 `anchorPosition` 可以获取离 anchor 最近的分页数据对象 `Page`, 然后通过其 `prevKey`, `nextKey` 计算出此页的页码标识作为刷新时的页码标识. 刷新此页数据.

- 引入 `RemoteMediator<Key : Any, Value : Any>` 实现本地业务数据与远程业务数据之间的协同工作.
    - `load(loadType: LoadType, state: PagingState<Key, Value>)`: 核心方法，响应分页边界条件/刷新事件，返回加载结果 `MediatorResult`.
    - `LoadType`: 加载类型, `REFRESH`: 刷新, `PREPEND`: 前一页, `APPEND`: 后一页
    - `PagingState<Key, Value>`: 分页系统的数据状态快照, 内部包含已加载的分页数据列表 `pages`, 最近访问的列表位置 `anchorPosition`, 初始化数据流时的配置 `config`, 首项前的占位符数量 `leadingPlaceholderCount`.
    - `MediatorResult`: 封装加载结果的密封类. 分具体类型 `Error(throwable: Throwable)`: 加载失败, 携带异常信息; `Success(endOfPaginationReached: Boolean)`: 加载成功, 携带是否到达分页末尾.

- 引入 `Pager` 分页器, 基于相关配置, 结合 `PagingSource` 和 `RemoteMediator`, 构建分页数据流, 如数据冷流 `Flow<PagingData<...>>`.
    - 通过 `PagingConfig` 配置分页加载数据的参数, 如初始加载数量 `initialLoadSize`, 后续每页加载数量 `pageSize`, 预加载距离 `prefetchDistance`. 注意当 `initialLoadSize` 和 `pageSize` 相等时才能固定初始加载数量.
    - 通过 `PagingData` 用于表示业务分页数据的快照, 通过 `Flow` 传递, 包含分页数据和加载状态.
        - 注意冷流获取的 `PagingData` 实例不能重复使用(消费), 不然可能会出错 底层业务数据更新时, 需要通过 `PagingSource.invalidate`, `AsyncPagingDataDiffer.refresh`, `PagingDataAdapter.refresh()` 重新生成新的 `PagingData` 实例.
        - 如果需要重用实例, 可以在使用 `Flow` 时通过 `cachedIn()` 方法进行缓存和多播, 确保每个观察者拿到一个新的、独立的 `PagingData` 实例.
    - 通过 `PageFetcher` 进行分页数据的加载和缓存.(TODO)
    - 引入加载状态 `LoadState: 加载中, 没加载, 失败`, 用于实现 UI 状态与数据的同步更新.(TODO)

- 通过 `PagingDataAdapter` 提供针对 `RecyclerView` 的分页展示支持. 支持实现绑定和自动 Diff 计算, 同时支持设置头部和尾部适配器, 以及加载状态适配器 `LoadStateAdapter`.
    - 硬性要求传递 `DiffUtil.ItemCallback` 对象, 用于计算数据差异.
    - `submitData` 方法用于提交新的 `PagingData` 数据, 以此自动计算数据差异, 更新视图.
    - `retry` 方法用于重试加载失败 `LoadState.Error` 的数据.\
    - `refresh` 方法用于重新加载数据(如下拉刷新).
    - `getItem` 方法用于获取指定位置的数据, 数据类型对应创建 `PagingDataAdapter` 时的泛型类型.
    - `loadStateFlow` 属性用于监听分页数据的加载状态 `LoadState` 的 `StateFlow` 热数据流.
    - `onPagesUpdatedFlow` 属性用于监听分页页面结构变化的 `SharedFlow` 热数据流.
    - `withLoadStateHeaderAndFooter` 基于 `ConcatAdapter`, `LoadState` 和 `LoadStateAdapter` 实现头部和尾部适配器的设置. 可自动处理加载状态的显示和隐藏.

- 通过 `LoadStateAdapter` 提供针对 `RecyclerView` 的加载状态适配器支持. 用于实现加载状态的展示和隐藏, 以及重试加载失败数据的功能.

#### 使用示例

```kotlin
// 相关依赖
// implementation "androidx.paging:paging-runtime-ktx:3.1.1"
// implementation "androidx.paging:paging-compose:3.1.1" // 如果使用 Compose
// implementation "org.jetbrains.kotlinx:kotlinx-coroutines-android:1.6.4"
// implementation "androidx.room:room-ktx:2.5.2"
// kapt "androidx.room:room-compiler:2.5.2"
// implementation "com.squareup.retrofit2:retrofit:2.9.0"

// 数据模型 & API 定义
data class ApiResponse(
    val items: List<Item>,
    val nextPage: Int?
)

@Entity(tableName = "items")
data class Item(
    @PrimaryKey val id: String,
    val name: String,
    val page: Int // 记录所属页码用于分页
)

interface ApiService {
    @GET("items")
    suspend fun getItems(
        @Query("page") page: Int,
        @Query("size") size: Int
    ): ApiResponse
}

// 数据库 & DAO 定义
@Database(entities = [Item::class], version = 1)
abstract class AppDatabase : RoomDatabase() {
    abstract fun itemDao(): ItemDao
}

@Dao
interface ItemDao {
    @Query("SELECT * FROM items ORDER BY page ASC")
    fun getPagingSource(): PagingSource<Int, Item>

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertAll(items: List<Item>)

    @Query("DELETE FROM items")
    suspend fun clearAll()
}

// RemoteMediator (协调本地/远程)
class ItemRemoteMediator(
    private val api: ApiService,
    private val db: AppDatabase
) : RemoteMediator<Int, Item>() {

    override suspend fun load(
        loadType: LoadType,
        state: PagingState<Int, Item>
    ): MediatorResult {
        try {
            // 根据加载类型计算下一页页码
            val page = when (loadType) {
                LoadType.REFRESH -> 1
                LoadType.PREPEND -> return MediatorResult.Success(endOfPaginationReached = true)
                LoadType.APPEND -> {
                    val lastItem = state.lastItemOrNull()
                    lastItem?.page?.plus(1) ?: 1
                }
            }

            // 从网络加载数据
            val response = api.getItems(page, state.config.pageSize)
            
            // 写入数据库
            db.withTransaction {
                if (loadType == LoadType.REFRESH) {
                    db.itemDao().clearAll()
                }
                db.itemDao().insertAll(response.items.map { it.copy(page = page) })
            }

            return MediatorResult.Success(
                endOfPaginationReached = response.nextPage == null
            )
        } catch (e: Exception) {
            return MediatorResult.Error(e)
        }
    }
}

// 实现 Adapter
class ItemAdapter : PagingDataAdapter<Item, ItemViewHolder>(ITEM_COMPARATOR) {

    companion object {
        private val ITEM_COMPARATOR = object : DiffUtil.ItemCallback<Item>() {
            override fun areItemsTheSame(oldItem: Item, newItem: Item): Boolean =
                oldItem.id == newItem.id

            override fun areContentsTheSame(oldItem: Item, newItem: Item): Boolean =
                oldItem == newItem
        }
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ItemViewHolder {
        val view = LayoutInflater.from(parent.context).inflate(R.layout.item_layout, parent, false)
        return ItemViewHolder(view)
    }

    override fun onBindViewHolder(holder: ItemViewHolder, position: Int) {
        val item = getItem(position)
        holder.bind(item)
    }
}

// 头部适配器（静态内容）
class HeaderAdapter : RecyclerView.Adapter<HeaderAdapter.HeaderViewHolder>() {

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): HeaderViewHolder {
        val view = LayoutInflater.from(parent.context)
            .inflate(R.layout.item_header, parent, false)
        return HeaderViewHolder(view)
    }

    override fun onBindViewHolder(holder: HeaderViewHolder, position: Int) {
        holder.bind("List Header")
    }

    override fun getItemCount(): Int = 1 // 只显示一个头部项

    class HeaderViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        fun bind(text: String) {
            itemView.findViewById<TextView>(R.id.headerText).text = text
        }
    }
}

// 页脚适配器（动态加载状态）
class FooterAdapter(private val retry: () -> Unit) : RecyclerView.Adapter<FooterAdapter.FooterViewHolder>() {

    private var loadState: LoadState = LoadState.NotLoading(endOfPaginationReached = false)

    fun setLoadState(newState: LoadState) {
        val previousState = loadState
        loadState = newState
        when {
            // 使用 DiffUtil 简化状态更新
            previousState is LoadState.Loading && newState is LoadState.NotLoading -> 
                notifyItemRemoved(0)
            newState is LoadState.Loading -> 
                notifyItemInserted(0)
            previousState.endOfPaginationReached != newState.endOfPaginationReached -> 
                notifyItemChanged(0)
        }
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): FooterViewHolder {
        val view = LayoutInflater.from(parent.context)
            .inflate(R.layout.item_footer, parent, false)
        return FooterViewHolder(view, retry)
    }

    override fun onBindViewHolder(holder: FooterViewHolder, position: Int) {
        holder.bind(loadState)
    }

    override fun getItemCount(): Int = if (loadState is LoadState.NotLoading && loadState.endOfPaginationReached) 0 else 1

    class FooterViewHolder(view: View, retry: () -> Unit) : RecyclerView.ViewHolder(view) {
        private val progressBar = view.findViewById<ProgressBar>(R.id.progressBar)
        private val errorText = view.findViewById<TextView>(R.id.errorText)
        private val retryButton = view.findViewById<Button>(R.id.retryButton)

        init {
            retryButton.setOnClickListener { retry() }
        }

        fun bind(loadState: LoadState) {
            when (loadState) {
                is LoadState.Loading -> {
                    progressBar.visibility = View.VISIBLE
                    errorText.visibility = View.GONE
                    retryButton.visibility = View.GONE
                }
                is LoadState.Error -> {
                    progressBar.visibility = View.GONE
                    errorText.text = loadState.error.localizedMessage
                    errorText.visibility = View.VISIBLE
                    retryButton.visibility = View.VISIBLE
                }
                is LoadState.NotLoading -> {
                    progressBar.visibility = View.GONE
                    errorText.visibility = View.GONE
                    retryButton.visibility = View.GONE
                }
            }
        }
    }
}

// 在 ViewModel 中配置 Pager
class ItemViewModel(
    private val api: ApiService,
    private val db: AppDatabase
) : ViewModel() {

    val pagingDataFlow = Pager(
        config = PagingConfig(
            pageSize = 20,
            prefetchDistance = 5,
            enablePlaceholders = false
        ),
        remoteMediator = ItemRemoteMediator(api, db),
        pagingSourceFactory = { db.itemDao().getPagingSource() }
    ).flow.cachedIn(viewModelScope)
}

// 在 Activity/Fragment 中使用
class MainActivity : AppCompatActivity() {
    private lateinit var viewModel: ItemViewModel
    private val headerAdapter = HeaderAdapter()
    private val itemAdapter = ItemAdapter()
    private val footerAdapter = FooterAdapter { itemAdapter.retry() } // 重试时触发分页重载

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        // 使用 ConcatAdapter 组合三个 Adapter
        val concatAdapter = ConcatAdapter(
            headerAdapter,
            itemAdapter.withLoadStateHeaderAndFooter(
                header = FooterAdapter { itemAdapter.retry() },
                footer = footerAdapter
            )
        )

        val recyclerView = findViewById<RecyclerView>(R.id.recycler_view)
        recyclerView.adapter = concatAdapter

        // 监听分页数据（保持原有逻辑）
        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.pagingDataFlow.collectLatest { pagingData ->
                    itemAdapter.submitData(pagingData)
                }
            }
        }

        // 监听加载状态并更新 Footer
        itemAdapter.addLoadStateListener { loadStates ->
            footerAdapter.setLoadState(loadStates.append) // 监听追加状态

            // 原有全局状态处理保持不变
            when (loadStates.refresh) {
                is LoadState.Loading -> showLoading()
                is LoadState.Error -> showError((loadStates.refresh as LoadState.Error).error)
                is LoadState.NotLoading -> hideLoading()
            }
        }
    }
}
```

### 自定义视图

> [!cite]
>
> [Android 事件分发机制完全解析](https://blog.csdn.net/guolin_blog/article/details/9097463)

通常的自定义 View 流程:

- 继承自 `View` 或者 `ViewGroup` 类

```kotlin
/**
 * 自定义 View
 * params context 应用上下文
 * params attrs 属性集合, 用于在 xml 中使用自定义组件时, 为组件传递自定义属性(不使用时, 可以传递 null)
 * params defStyleAttr 默认样式, 用于在 xml 中使用自定义组件时, 为组件传递默认样式. 可以通过在 xml 中设置 style 属性来覆盖默认样式.
 */
class MyView(context: Context, attrs: AttributeSet, defStyleAttr: Int) : View(context, attrs, defStyleAttr) {
    // 1. 定义属性
    private var mText: String = ""

    // 2. 初始化属性
    init {
        val typedArray = context.obtainStyledAttributes(attrs, R.styleable.MyView, defStyleAttr, 0)
        mText = typedArray.getString(R.styleable.MyView_text) ?: ""
        typedArray.recycle()
    }
}

// 使用
<com.example.MyView
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    app:text="Hello World!" />

val myView = MyView(context).apply {
    text = "Hello World!"
    layoutParams = ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT)
}
```

- 重写 `override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int)` 方法, 在其中测量自定义 View 及其子 View 的大小, 并通过 `setMeasuredDimension(width, height)` 方法设置自定义 View 的最终大小.
- 重写 `override fun onLayout(changed: Boolean, left: Int, top: Int, right: Int, bottom: Int)` 方法, 由 ViewGroup 调用, 在其中布局确定自定义 View 及其子 View 在父布局中的位置.
- 重写 `override fun onDraw(canvas: Canvas?)` 方法, 在其中绘制自定义 View 的内容, 一般通过 `Canvas` 对象来绘制图形, 文字, 图片等.
- 重写 `override fun onTouchEvent(event: MotionEvent?): Boolean` 方法, 在其中处理自定义 View 的触摸事件

#### `onMeasure` 方法

> [!cite]
>
> [onMeasure 详解](https://blog.csdn.net/dmk877/article/details/49558367)

每个视图都有一个 `onMeasure` 方法, 用于测量视图的大小, 并通过 `setMeasuredDimension(width, height)` 方法设置视图的最终大小. 视图的大小由两部分组成: 宽度和高度, 其最终大小会受到父视图的测量要求 `MeasureSpec`(大小和模式), 视图自身的 `LayoutParams` 以及视图内容等因素的影响.

- `MeasureSpec.EXACTLY` 精确模式, 视图大小是确定的, 由 `MeasureSpec.getSize()` 获取. 对应布局属性 `match_parent` 或者 `具体数值dp`
- `MeasureSpec.AT_MOST` 最大模式, 视图大小不能超过 `MeasureSpec.getSize()`, 通常是父视图的大小. 对应布局属性 `wrap_content`.
- `MeasureSpec.UNSPECIFIED` 未指定模式, 视图大小不受限制, 可以任意大小. 通常用于 `ScrollView` 中的子视图.

```java
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),
            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));
}

private void setMeasuredDimension(int measuredWidth, int measuredHeight) {
    mMeasuredWidth = measuredWidth;
    mMeasuredHeight = measuredHeight;
}
```

最根源的父视图是 `Activity` 绑定的 `Window` 视窗内的 `DecorView`. `Window` 视窗用于包含和管理应用的窗口内容有关的所有视图; `DecorView` 是一个继承自 `FrameLayout` 类型的根布局, 它的大小一般是手机屏幕的大小.

```java
public class Activity ... { ...
    mWindow = new PhoneWindow(this, window, activityConfigCallback);
    public void setContentView(@LayoutRes int layoutResID) {
        mWindow.setContentView(layoutResID);
        initWindowDecorActionBar();
    }
}

public class PhoneWindow ... { ...
    public void setContentView(int layoutResID) {
        installDecor();
    }

    private void installDecor() {
        if (mDecor == null) {
            mDecor = new DecorView(context, -1, this, getAttributes());;
        }
        if (mContentParent == null) {
            ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);
            mContentParent = generateLayout(mDecor);
        }
    }
}
```

此外 `PhoneWindow` 又有一个 `mContentParent: FrameLayout` 容器, 用于存放实际的应用内容区域的视图, 大小通常是 `DecorView` 的大小减去状态栏和导航栏的高度.

`DecorView extends FrameLayout -> ViewGroup -> View` 也是个视图, 同时它也就有自己的 `onMeasure` 方法来测量自己的大小. 但是 `DecorView` 并没有父视图, 那么它的大小是怎么确定的呢?

首先每一个 `View` 都会通过 `measure(widthMeasureSpec, heightMeasureSpec)` 方法来测量自己的大小, 因此只需要搞清楚这里的 `widthMeasureSpec` 和 `heightMeasureSpec` 的来源即可. 这里需要去追溯到 `ViewRootImpl`.

在 `PhoneWindow` 创建的同时, 会创建一个 `ViewRootImpl` 对象自动与 `DecorView` 绑定, 用于管理当前窗口内部视图树内所有视图的绘制和事件分发. 而 `DecorView` 就可以通过 `getViewRootImpl()` 通过得到的 `ViewRootImpl` 对象来触发 `ViewRootImpl` 的 `performTraversals()` 方法来重新测量自己的大小.

```java
public class PhoneWindow ... { ...
    private void openPanel(final PanelFeatureState st, KeyEvent event) {
        ...
        final WindowManager wm = getWindowManager();
        wm.addView(st.decorView, lp);
        ...
    }
}

// WindowManagerImpl
public final class WindowManagerGlobal { ...
    public void addView(View view, ViewGroup.LayoutParams params, ...) {
        ViewRootImpl root;
        root = new ViewRootImpl(view.getContext(), display);
        mViews.add(view);
        mRoots.add(root);
        ...
    }
}
```

`ViewRootImpl` 会在自己的 `performTraversals()` 方法中计算 `DecorView` 需要的根测量规格 `childWidthMeasureSpec` 或 `childHeightMeasureSpec`.

简单来说这两个测量规格的计算取决于窗口的类型, 如果是特殊窗口类型, 直接使用设备的宽高, 如果是 `WRAP_CONTENT` 类型, 则扣除系统栏的高度后, 当前窗口在屏幕上显示的实际矩形区域, 其他情况直接使用 `WindowManager` 获取的屏幕尺寸. 具体的计算还有更多细节.

然后 `ViewRootImpl` 会利用计算好的根测量规格调用 `performMeasure()` 方法来执行 `DecorView` 的 `measure(...)` 方法, 从而使得 `DecorView` 根据根测量规格来测量自己的大小.

```java
public final class ViewRootImpl ... {
    private void performTraversals() {
        ...
        int desiredWindowWidth;
        int desiredWindowHeight;
        Rect frame = mWinFrame;
        if (mFirst) {
            final Configuration config = mContext.getResources().getConfiguration();
            if (shouldUseDisplaySize(lp)) {
                Point size = new Point();
                mDisplay.getRealSize(size);
                desiredWindowWidth = size.x;
                desiredWindowHeight = size.y;
            } else if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT
                    || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
                desiredWindowWidth = dipToPx(config.screenWidthDp);
                desiredWindowHeight = dipToPx(config.screenHeightDp);
            } else {
                desiredWindowWidth = frame.width();
                desiredWindowHeight = frame.height();
            }
        } else {
            desiredWindowWidth = frame.width();
            desiredWindowHeight = frame.height();
        }

        // Ask host how big it wants to be
        windowSizeMayChange |= measureHierarchy(mView, layoutParams, contextResources,
                desiredWindowWidth, desiredWindowHeight);
    }

    private boolean measureHierarchy(host, lp, res, desiredWindowWidth, desiredWindowHeight) {
        ...
        final DisplayMetrics packageMetrics = res.getDisplayMetrics();
            childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);
            childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);
            performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);
        ...
    }

    private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) {
        mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);
    }
}
```

其中 `measure(...)` 方法中有一个默认的根据测量规格计算大小的实现, 即 `onMeasure()` 方法, 它会直接使用所提供的测量规格提供的大小. (因为一般传入的模式不会是 `MeasureSpec.UNSPECIFIED`)

#### `onLayout` 方法

每个视图都有一个 `onLayout` 方法, 用于布局当前视图相对于父视图的位置, 并通过 `setFrame(left, top, right, bottom)` 方法设置视图的最终位置. 视图的位置由四个坐标值组成: 左上角的 x 坐标和 y 坐标, 右下角的 x 坐标和 y 坐标, 其最终位置取决于设置的坐标, 分别对应以下四个属性:

- `mLeft——View.getLeft()`: 当前视图的左边界到父视图的左边界的距离
- `mTop——View.getTop()`: 当前视图的顶部到父视图顶部的距离
- `mRight——View.getRight()`: 当前视图的右边界到父视图的左边界的距离
- ``mBottom——View.getBottom(): 当前视图的底部到父视图的顶部的距离

```java
public void layout(int l, int t, int r, int b) {
    ...
    int oldL = mLeft;
    int oldT = mTop;
    int oldB = mBottom;
    int oldR = mRight;
    boolean changed = setFrame(l, t, r, b);
    if (changed) {
        onLayout(changed, l, t, r, b);
    }
}

protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
}

protected boolean setFrame(int left, int top, int right, int bottom) {
    boolean changed = false;

    if (mLeft != left || mRight != right || mTop != top || mBottom != bottom) {
        changed = true;

        int oldWidth = mRight - mLeft;
        int oldHeight = mBottom - mTop;
        int newWidth = right - left;
        int newHeight = bottom - top;
        boolean sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight);

        invalidate(sizeChanged);

        mLeft = left;
        mTop = top;
        mRight = right;
        mBottom = bottom;
        mRenderNode.setLeftTopRightBottom(mLeft, mTop, mRight, mBottom);
    }
    return changed;
}


```

最根源的父视图是 `Activity` 绑定的 `Window` 视窗内的 `DecorView`. 与 `onMeasure` 方法的介绍类似, `DecorView` 可以通过触发绑定的 `ViewRootImpl` 对象的 `performTraversals()` 方法来重新布局自己的子视图. 默认的根布局区域就是 `onMeasure` 方法中确定的测量大小所占区域.

```java
public final class ViewRootImpl ... {
    private void performTraversals() {
        windowSizeMayChange |= measureHierarchy(mView, layoutParams, contextResources,
                desiredWindowWidth, desiredWindowHeight);

        if (mWidth != frame.width() || mHeight != frame.height()) {
            mWidth = frame.width();
            mHeight = frame.height();
        }
        performLayout(lp, mWidth, mHeight);
    }

    private void performLayoutWindowManager.LayoutParams lp, int desiredWindowWidth,
            int desiredWindowHeight {
        mView.layout(0, 0, mView.getMeasuredWidth(), mView.getMeasuredHeight());

        // 这里如果布局失败, 会尝试使用 desiredWindowWidth 和 desiredWindowHeight 参数重新计算视图大小, 并重新布局
    }
}
```

#### `onDraw` 方法

#### `invalidate` 方法

#### `dispatchTouchEvent` 方法

![_](https://img2018.cnblogs.com/blog/653161/201903/653161-20190321113420853-1974821013.png)

> [!cite]
> [Android 事件分发机制解析](https://juejin.cn/post/7102248400019521544")

每当用户触摸屏幕时, 系统会首先将触摸事件封装成 `MotionEvent` 对象, 并通过当前 `Activity` 将事件传递给 `DecorView` 中的根视图 `ViewGroup` 对象, 由根视图对象将此事件传递给其子视图, 一直到最终的目标视图.

包括 `Activity`, `Window`, `ViewGroup`, `View` 在内的所有类型对象都有一个 `dispatchTouchEvent` 方法, 用于分发触摸事件. 以下介绍每种对象的 `dispatchTouchEvent` 方法的实现逻辑:

- `Activity.dispatchTouchEvent`

    - 会首先在 `ACTION_DOWN` 事件到来时, 调用 `onUserInteraction` 方法, 默认为空实现, 可以重写此方法来记录用户交互事件
    - 然后将事件传递给绑定的 `Window` 对象处理, 如果事件被消费, 则返回 true, 否则继续去调用 `Activity.onTouchEvent` 方法.

- `Window.dispatchTouchEvent`

    - 一般会将事件直接传递给绑定的 `DecorView: ViewGroup` 对象处理.

- `ViewGroup.dispatchTouchEvent`

    - 进行设置输入一致性验证, 辅助功能标志, 安全性检查等. (不重要)
    - 清除所有之前的触摸目标, 并调用重置触摸状态, 防止之前的触摸事件影响当前事件.
    - 首先进行事件拦截的判断和处理. 事件拦截, 会导致事件不再向子视图传递.

        - 拦截条件 1: 1. 是 `ACTION_DOWN` 事件, 或者已有子视图在处理触摸事件; 2. `FLAG_DISALLOW_INTERCEPT` 标志未被设置为 true; 拦截成功后会调用 `onInterceptTouchEvent` 方法. 后续不会再进行向子视图的触摸事件分发.
        - 拦截条件 2: 不是 `ACTION_DOWN` 事件, 且没有任何子视图在处理当前触摸事件. 也视为拦截成功. 后续不会再进行向子视图的触摸事件分发.

    - 然后判断事件是否被取消, 通过 `FLAG_CANCEL_FORCED` 标志或事件类型是否是 `ACTION_CANCEL` 来判断. 事件被取消会导致事件不再向子视图传递.
    - 判断是否需要进行多点触控事件的处理, 通过 `FLAG_SPLIT_MOTION_EVENTS` 标志和是否不是鼠标事件来判断.
    - 进行事件分发判断和处理

        - 当事件是 `ACTION_DOWN`(初始按下) 或 `ACTION_POINTER_DOWN`(多点触控新增的手指按下) 或 `ACTION_HOVER_MOVE`(按下后移动) 时

            - 先逆序查找所有可以接收事件的子视图 (确认视图能否接收事件) 并调用子视图的 `dispatchTouchEvent` 方法传递事件, 直到有子视图消费事件或者事件被取消. 如果事件被消费了, 将可接收子视图保存在链表结构头部, 为多点触控事件做准备.
            - 如果没有子视图消费事件, 但是事件是多点触控和触摸后移动事件, 则尝试将要处理的事件分发给第一次按下时保存的所有可以处理事件的子视图链表中的尾部视图.

        - 如果是其他事件, 则直接从头到尾遍历所有可以接收事件的子视图, 并调用子视图的 `dispatchTouchEvent` 方法传递事件, 直到有子视图消费事件或者事件被取消.

- `View.dispatchTouchEvent`

    - 进行设置输入一致性验证, 辅助功能标志, 安全性检查等. (不重要)
    - 如果视图启用了滚动条并且事件是相关的滚动操作, 会先尝试处理滚动条拖拽事件 `handleScrollBarDragging` 方法, 消费后继续向下.
    - 如果设置了触摸事件监听器, 会先调用监听器的 `onTouch` 方法处理事件, 消费后直接返回.
    - 调用视图自身的 `onTouchEvent` 方法处理事件, 消费后直接返回.
    - 未消费事件, 返回 false.

##### `onTouchEvent` 方法

##### `onInterceptTouchEvent` 方法

##### `handleScrollBarDragging` 方法

##### `requestDisallowInterceptTouchEvent` 方法

通过设置 `FLAG_DISALLOW_INTERCEPT` 标志来控制父视图是否拦截触摸事件.

##### `setMotionEventSplittingEnabled` 方法

通过设置 `FLAG_SPLIT_MOTION_EVENTS` 标志来控制是否分割多点触控事件.

#### `getMeasuredWidth` 和 `getWidth` 方法的区别

- `getMeasureWidth()` 方法在 `measure()` 过程结束后就可以获得到它的值.
- `getWidth()` 方法要在 `layout()`过程结束后才能获取到.

自定义控件的时候在 `onLayout` 方法中一般采用 `getMeasuredWidth` 来获得控件的宽度.  
在除了 `onLayout` 之外的方法中采用 `getWidth` 方法来获取控件的宽度.

```java
public class View ... {
    public final int getMeasuredWidth() {
        return mMeasuredWidth & MEASURED_SIZE_MASK;
    }

    public final int getWidth() {
        return mRight - mLeft;
    }
}
```

#### TextPaint

`TextPaint` 是 `Paint` 的子类, 用于绘制文本的画笔. `TextPaint` 除了继承了 `Paint` 的所有属性和方法外, 还有一些专门用于绘制文本的属性和方法.

- `TextPaint.setTextSize(float textSize)`: 设置文本大小
- `TextPaint.setTypeface(Typeface typeface)`: 设置字体样式
- `TextPaint.setUnderlineText(boolean underlineText)`: 设置是否显示下划线
- `TextPaint.setStrikeThruText(boolean strikeThruText)`: 设置是否显示删除线

文本的基本信息 `Paint.FontMetrics`:

- `baseline`: 基线, 文本绘制的基准线, 用于绘制文本的起始位置
- `ascent`: 文本中字符的最高点到基线的距离
- `descent`: 文本中字符的最低点到基线的距离
- `top`: 文本中字符可以达到的最高点到基线的距离
- `leading`:

文本居中的计算方法: `int baseline = viewHeight / 2 + (fontMetrics.descent - fontMetrics.ascent) / 2 - fontMetrics.descent;`

### 动画和过渡

> [!cite]
>
> [https://developer.android.com/guide/fragments/animate](https://developer.android.com/guide/fragments/animate) > [Frame Animation（逐帧动画）](https://developer.aliyun.com/article/567019)

#### Frame 动画(帧动画)

帧动画: 通过一系列的图片帧来实现动画效果, 适用于帧数较少的动画效果

- 动画文件定义位置: `res/drawable/`
- 动画定义类型: `AnimationDrawable`
- 在 `Activity` 的 `onCreate()` 方法期间无法调用 `AnimationDrawable` 上调用的 `start()` 方法. 可以从 `Activity` 中的 `onStart()` 方法或者 `onWindowFocusChanged()` 方法中调用 `start()` 方法, 以避免动画启动时界面未绘制完成的问题.
- 使用时以 `ImageView` 为载体, 通过 `ImageView.setBackgroundResource()` 方法设置动画资源, 并通过将背景转换为 `AnimationDrawable` 对象来启动动画

```kotlin
// rocket_thrust_anim.xml
<?xml version="1.0" encoding="utf-8"?>
<animation-list
    xmlns:android="http://schemas.android.com/apk/res/android"
    <-- 动画是否只播放一次 --/>
    android:oneshot="false"
    >
    <item android:drawable="@drawable/rocket_thrust1" android:duration="200" />
    <item android:drawable="@drawable/rocket_thrust2" android:duration="200" />
    <item android:drawable="@drawable/rocket_thrust3" android:duration="200" />
</animation-list>

<ImageView
    android:id="@+id/rocket_image"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:background="@drawable/rocket_thrust_anim" />

// 使用
val rocketImage = findViewById<ImageView>(R.id.rocket_image).apply {
    setBackgroundResource(R.drawable.rocket_thrust)
    rocketAnimation = background as AnimationDrawable
}

rocketImage.setOnClickListener({ rocketAnimation.start() })
```

#### 插值器和求值器

每一个动画都有一个插值器和一个求值器, 插值器控制动画的进度, 求值器控制动画的属性值.

插值器（Interpolator）决定了动画的进度如何随时间变化. 时间是线性的, 但是动画的进度不一定是线性的, 插值器就是用来控制动画进度的, 在固定的时间内, 可以让它先快后慢, 先慢后快 或者提前到达终点进行回弹等.

默认可用的插值器:

- `@android:anim/linear_interpolator` | `LinearInterpolator`: 线性匀速
- `@android:anim/decelerate_interpolator` | `DecelerateInterpolator`: 减速
- `@android:anim/accelerate_interpolator` | `AccelerateInterpolator`: 加速
- `@android:anim/overshoot_interpolator` | `OvershootInterpolator`: 快速超出终点一小步后回弹到终点
- `@android:anim/anticipate_interpolator` | `AnticipateInterpolator`: 先回退一小步再加速
- `@android:anim/accelerate_decelerate_interpolator` | `AccelerateDecelerateInterpolator`: 先加速后减速
- `@android:anim/anticipate_overshoot_interpolator` | `AnticipateOvershootInterpolator`: 先回退一小步再加速, 最后超出重点一小步后回弹到终点
- `@android:anim/bounce_interpolator` | `BounceInterpolator`: 加速到终点后持续弹跳直至停止
- `@android:anim/cycle_interpolator` | `CycleInterpolator`: 周期运动
- `pathInterpolator` | `PathInterpolator`: 自定义路径插值器, 支持为二次贝塞尔曲线和三次贝塞尔曲线创建插值器

```xml
// 默认插值器的参数设置
<linearInterpolator xmlns:android="http://schemas.android.com/apk/res/android" /> // 无法自定义参数
<decelerate_interpolator xmlns:android="http://schemas.android.com/apk/res/android" android:factor="2" /> // 可设置减速因子
<accelerate_interpolator xmlns:android="http://schemas.android.com/apk/res/android" android:factor="2" /> // 可设置加速因子
<overshootInterpolator xmlns:android="http://schemas.android.com/apk/res/android" android:tension="2" /> // 可设置超出终点后的张力(回拉力)
<anticipate_interpolator xmlns:android="http://schemas.android.com/apk/res/android" android:tension="2" /> // 可设置回退一小步的张力
<accelerateDecelerateInterpolator xmlns:android="http://schemas.android.com/apk/res/android" /> // 无法自定义参数
<anticipateOvershootInterpolator xmlns:android="http://schemas.android.com/apk/res/android" android:tension="2" android:extraTension="2" /> // 可设置回退一小步的张力和超出终点后的张力
<bounceInterpolator xmlns:android="http://schemas.android.com/apk/res/android" /> // 无法自定义参数
<cycleInterpolator xmlns:android="http://schemas.android.com/apk/res/android" android:cycles="2" /> // 可设置周期数
<pathInterpolator xmlns:android="http://schemas.android.com/apk/res/android"
    android:controlX1="0.1" android:controlY1="0.2" android:controlX2="0.3" android:controlY2="0.4"
/> // 可设置路径插值器的控制点坐标
```

```kotlin
// 自定义插值器
class MyInterpolator : Interpolator {
    override fun getInterpolation(input: Float): Float {
        return input * input
    }
}

// 使用自定义插值器
val objectAnimator = ObjectAnimator.ofFloat(view, "translationX", 0f, 100f).apply {
    duration = 1000
    interpolator = MyInterpolator()
}
objectAnimator.start()

// 使用路径插值器
val path = Path().apply {
    moveTo(0f, 0f) // moveTo() 方法用于将画笔移动到指定位置
    lineTo(100f, 100f) // lineTo() 方法用于从当前位置画一条直线到指定位置
    cubicTo(100f, 0f, 200f, 200f, 300f, 100f) // cubicTo() 方法用于绘制三次贝塞尔曲线
    arcTo(0f, 0f, 100f, 100f, 0f, 270f, true) // arcTo() 方法用于绘制弧形
}
val pathInterpolator = PathInterpolator(path)
```

求值器（TypeEvaluator）决定了动画属性值在起始值和结束值之间随进度 (fraction) 而如何变化. 动画期间, 求值器会根据当前时间对应的动画进度来计算出当前属性值, 并将其传递给动画监听器, 从而实现动画效果.

默认可用的求值器:

- `IntEvaluator`: 用于整型属性值的求值
- `FloatEvaluator`: 用于浮点型属性值的求值
- `ArgbEvaluator`: 用于颜色属性值的求值
- `RectEvaluator`: 用于矩形属性值的求值
- `PointEvaluator`: 用于点属性值的求值
- `IntArrayEvaluator`: 用于整型数组属性值的求值
- `FloatArrayEvaluator`: 用于浮点型数组属性值的求值

```kotlin
// 自定义求值器
class PointFEvaluator : TypeEvaluator<PointF> {
    override fun evaluate(fraction: Float, startValue: PointF, endValue: PointF): PointF {
        val x = startValue.x + (endValue.x - startValue.x) * fraction
        val y = startValue.y + (endValue.y - startValue.y) * fraction
        return PointF(x, y)
    }
}

// 使用自定义求值器
val startPoint = PointF(0f, 0f)
val endPoint = PointF(500f, 500f)

val animator = ValueAnimator.ofObject(PointFEvaluator(), startPoint, endPoint)
animator.duration = 1000
animator.addUpdateListener { animation ->
    val point = animation.animatedValue as PointF
    view.translationX = point.x
    view.translationY = point.y
}
animator.start()
```

#### android.view.animation（视图动画, 补间动画, 平移, 缩放, 旋转, 透明度）

> [!cite]
>
> [Tween(补间动画)完全解析](https://blog.csdn.net/dmk877/article/details/51912104)

视图动画: 通过对视图的属性进行动画操作, 适用于简单的动画效果

- 动画文件定义位置: `res/anim/`
- 动画定义方式

  ```xml
  <translate xmlns:android="http://schemas.android.com/apk/res/android"
      // 平移动画
      android:fromXDelta="0" // 起始位置 x 坐标 (px值, 百分比值, 百分比 p 值)
      android:toXDelta="100" // 结束位置 x 坐标
      android:fromYDelta="0" // 起始位置 y 坐标
      android:toYDelta="100" // 结束位置 y 坐标
  
  // 百分比 p 值表示相对于父容器宽或高的百分比值, 0% 表示起始位置, 100% 表示结束位置
  />
  
  <scale xmlns:android="http://schemas.android.com/apk/res/android"
      // 缩放动画
      android:fromXScale="1.0" // 起始 x 缩放比例, 0-1 缩小, 1-∞ 放大
      android:toXScale="0.5" // 结束 x 缩放比例
      android:fromYScale="1.0" // 起始 y 缩放比例
      android:toYScale="0.5" // 结束 y 缩放比例
  
      android:pivotX="50%" // 视图缩放的中心 x 坐标 (px 值, 百分比值, 百分比 p 值)
      android:pivotY="50%" // 视图缩放的中心 y 坐标
  />
  
  <rotate xmlns:android="http://schemas.android.com/apk/res/android"
      // 旋转动画
      android:fromDegrees="0" // 起始角度
      android:toDegrees="360" // 结束角度
      android:pivotX="50%" // 旋转中心 x 坐标 (px 值, 百分比值, 百分比 p 值)
      android:pivotY="50%" // 旋转中心 y 坐标
  />
  
  <alpha xmlns:android="http://schemas.android.com/apk/res/android"
      // 透明度动画
      android:fromAlpha="1.0" // 起始透明度
      android:toAlpha="0.0" // 结束透明度
  />
  
  <set xmlns:android="http://schemas.android.com/apk/res/android"
      // 组合动画
      android:shareInterpolator="true" // 是否共享插值器, false 时需要为每个子动画设置插值器
      // 可以通过 startOffset 属性自定义每个动画开始前的延迟时间, 默认一起开始
  >
  
      <alpha
          ...
      />
  
      <scale
          ...
      />
  
      ...
  
  </set>
  
  <any
      // 通用属性
      android:duration="1000" // 动画持续时间
      android:startOffset="1000" // 动画开始前的延迟时间
      android:fillBefore="true" // 动画结束后是否回到初始状态, 默认为 true
      android:fillEnabled="true" // 是否启用 fillBefore, 默认为 true
      android:fillAfter="true" // 动画结束后是否保持结束状态, 默认为 false, 优先于 fillBefore
      android:repeatCount="infinite" // 动画重复次数, 默认为 0, 0 为不重复, -1 为无限重复
      android:repeatMode="reverse" // 动画重复模式, 默认为 restart, reverse 为反向重复
      android:interpolator="@android:anim/accelerate_decelerate_interpolator" // 动画插值器
  />
  ```

- 动画启动方式 (xml)

  ```kotlin
  
  // View
  val imageView = findViewById<ImageView>(R.id.image)
  val animation = AnimationUtils.loadAnimation(this, R.anim.bounce_animation)
  imageView.startAnimation(animation)
  
  // Fragment
  val fragmentManager = supportFragmentManager(Activity 情况下) | getParentFragmentManager()(Fragment 情况下)
  FragmentTransaction transaction = fragmentManager.beginTransaction();
  transaction.setCustomAnimations(R.anim.enter_animation, R.anim.exit_animation);
  transaction.replace(R.id.fragment_container, new MyFragment());
  transaction.addToBackStack(null)
  transaction.commit();
  
  // Activity
  val intent = Intent(context, TargetActivity::class.java)
  val options = ActivityOptions.makeCustomAnimation(context, R.anim.enter_anim, R.anim.exit_anim)
  startActivity(intent, options.toBundle())
  ```

- 动画启动方式(代码) 暂无

#### android.animation (属性动画)

属性动画: 通过对视图的属性进行动画操作, 适用于复杂的动画效果.

- 针对属性值进行动画操作, 因此适用于任何对象的任何属性, 而不仅限于平移, 缩放, 旋转, 透明度等.
- 动画操作可以针对于对象本身, 而不是如补间动画那样只是改变了视图对象的显示效果.
- 属性动画支持所有的通用属性, 如动画持续时间, 动画插值器等.
- 动画文件定义位置: `res/animator/`
- 使用时需要每个动画都需要绑定目标对象的属性名称, 并通过 `setTarget()` 方法绑定目标对象, 然后再通过 `start()` 方法启动动画.
- 23 之后的安卓版本可以使用 `PropertyValuesHolder` 和 `Keyframe` 来进阶定义动画效果, 比如为动画添加关键帧, 设置关键帧的插值器, 为 `objectAnimator` 添加多个属性值等.
- 对于修改后不自动触发 `invalidate()` 方法的属性, 需要手动调用 `invalidate()` 方法来刷新视图.
- 具有与视图动画几乎相同的通用属性, 如 `duration`, `startOffset`, `fillBefore`, `fillEnabled`, `fillAfter`, `repeatCount`, `repeatMode`, `interpolator` 等.

  ```xml
  <any
      // 通用属性
      android:duration="1000" // 动画持续时间
      android:startOffset="1000" // 动画开始前的延迟时间
      android:fillBefore="true" // 动画结束后是否回到初始状态, 默认为 true
      android:fillEnabled="true" // 是否启用 fillBefore, 默认为 true
      android:fillAfter="true" // 动画结束后是否保持结束状态, 默认为 false, 优先于 fillBefore
      android:repeatCount="infinite" // 动画重复次数, 默认为 0, 0 为不重复, -1 为无限重复
      android:repeatMode="reverse" // 动画重复模式, 默认为 restart, reverse 为反向重复
      android:interpolator="@android:anim/accelerate_decelerate_interpolator" // 动画插值器
  />
  ```

##### `ValueAnimator` 定义

构造时直接传入起始值, 中间值(可选, 可多个), 结束值. 使用时需要通过动画监听器来监听动画过程中属性值的变化, 并在监听器中根据当前属性值来更新目标对象的属性值(如视图的位置), 从而实现动画效果.

- 可以通过不同的工厂方法创建不同类型的 `ValueAnimator` 对象, 如 `ofInt()`, `ofFloat()`, `ofObject()`.

```kotlin
// 创建 ValueAnimator 对象
val valueAnimator = ValueAnimator.ofInt(0, 100)
val valueAnimator = ValueAnimator.ofFloat(0f, 100f)
val valueAnimator = ValueAnimator.ofObject(PointFEvaluator(), startPoint, endPoint)
```

```xml
<animator xmlns:android="http://schemas.android.com/apk/res/android"
    android:valueFrom="1"
    android:valueTo="0"
    android:valueType="floatType" | "intType" | "objectType"
/>
```

##### `ObjectAnimator` 定义

`ObjectAnimator` 是 `ValueAnimator` 的子类, 用于对对象的属性进行动画操作. 构造时需要传入目标对象, 属性名称, 起始值, 中间值(可选, 可多个), 结束值. 使用时直接调用 `start()` 方法启动动画.

- 对象属性必须可以 `get` 和 `set`. 例如, 如果属性名称是 `foo`, 则需要有一个 `getFoo()` 方法和一个 `setFoo()` 方法.

```kotlin
// 创建 ObjectAnimator 对象
val objectAnimator = ObjectAnimator.ofInt(view, "translationX", 0, 100)
val objectAnimator = ObjectAnimator.ofFloat(view, "translationX", 0f, 100f)
val objectAnimator = ObjectAnimator.ofObject(view, "point", PointFEvaluator(), startPoint, endPoint)
val path = Path().apply {
    arcTo(0f, 0f, 100f, 100f, 0f, 359f, true) // 一个圆形路径
}
val objectAnimator = ObjectAnimator.ofFloat(view, View.X, View.Y, path)
```

```xml
<objectAnimator xmlns:android="http://schemas.android.com/apk/res/android"
    android:propertyName="translationX" // 动画属性名称
    android:valueFrom="0" // 起始值
    android:valueTo="100" // 结束值
    android:valueType="floatType" | "intType" | "objectType"
/>
```

##### `TimeAnimator` 定义

`TimeAnimator` 是 `ValueAnimator` 的子类, 用于监听动画过程中的时间变化. 使用时需要通过动画监听器来监听动画过程中时间的变化, 并在监听器中根据当前时间来更新目标对象的属性值, 从而实现动画效果. 注意动画监听器有两种, 一种是专属 `TimeAnimator`的 `TimeListener` 用于监听动画过程中时间的变化, 另一种是 `AnimatorListener` 用于监听动画的开始, 结束, 取消, 重复等事件.

```kotlin
// 创建 TimeAnimator 对象
val animator = TimeAnimator().apply {
    // 添加动画监听器
    setTimeListener { animation, totalTime, deltaTime ->
        view.layout(deltaTime.toInt(), deltaTime.toInt(), deltaTime.toInt() + view.width, deltaTime.toInt() + view.height)
    }
}
```

##### `AnimatorSet` 定义

借助 `AnimatorSet` 可以将多个动画组合在一起, 并设置它们的执行顺序, 重复次数, 重复模式等. 使用时需要通过 `play()` 方法将多个动画添加到 `AnimatorSet` 中, 然后通过 `start()` 方法启动动画.

```kotlin
// 创建 ObjectAnimator 对象
val objectAnimator1 = ...
val objectAnimator2 = ...
val objectAnimator3 = ...
val objectAnimator4 = ...
val objectAnimator5 = ...

// 创建 AnimatorSet 对象
val animator = AnimatorSet().apply {
    // 手动设置动画执行顺序
    play(objectAnimator1).before(objectAnimator2)
    play(objectAnimator3).with(objectAnimator2)
    play(objectAnimator4).with(objectAnimator2)
    play(objectAnimator5).after(objectAnimator4)
    // 设置动画重复次数
    repeatCount = ValueAnimator.INFINITE
    // 设置动画重复模式
    repeatMode = ValueAnimator.REVERSE
}

// 嵌套和统一设置方法
val animatorSet1 = AnimatorSet().apply {
    playTogether(objectAnimator2, objectAnimator3, objectAnimator4)
}
val animator = AnimatorSet().apply {
    playSequentially(objectAnimator1, animatorSet1, objectAnimator5)
}
```

```xml
<set xmlns:android="http://schemas.android.com/apk/res/android"
    // 组合动画
    android:shareInterpolator="true" // 是否共享插值器, false 时需要为每个子动画设置插值器
    android:ordering="together" // 动画执行顺序, together 为同时执行, sequential 为顺序执行. 也可以通过 startOffset 属性自定义每个动画开始前的延迟时间
>

    <animate ... />
    <objectAnimator ... />
    <set ... />

</set>
```

##### 关键帧 (Keyframe)

关键帧: 用于为属性动画添加关键帧, 设置关键帧的插值器, 为 `objectAnimator` 添加多个属性值等.

- 关键帧使用方式 (xml)

  ```xml
  <animator xmlns:android="http://schemas.android.com/apk/res/android">
      <propertyValuesHolder>
          <keyframe android:fraction="0" android:value="1"/>
          <keyframe android:fraction=".2" android:value=".4"/>
          <keyframe android:fraction="1" android:value="0"/>
      </propertyValuesHolder>
  </animator>
  
  <objectAnimator xmlns:android="http://schemas.android.com/apk/res/android">
      <propertyValuesHolder android:propertyName="x" >
          <keyframe android:fraction="0" android:value="800" />
          <keyframe android:fraction=".2"
                  android:interpolator="@android:anim/accelerate_interpolator"
                  android:value="1000" />
          <keyframe android:fraction="1"
                  android:interpolator="@android:anim/accelerate_interpolator"
                  android:value="400" />
      </propertyValuesHolder>
      <propertyValuesHolder android:propertyName="y" >
          <keyframe/>
          <keyframe android:fraction=".2"
                  android:interpolator="@android:anim/accelerate_interpolator"
                  android:value="300"/>
          <keyframe android:interpolator="@android:anim/accelerate_interpolator"
                  android:value="1000" />
      </propertyValuesHolder>
  </objectAnimator>
  ```

- 关键帧使用方式 (代码)

  ```kotlin
  val keyframe1 = Keyframe.ofFloat(0f, 1f)
  val keyframe2 = Keyframe.ofFloat(0.2f, 0.4f)
  val keyframe3 = Keyframe.ofFloat(1f, 0f)
  
  val propertyValuesHolder = PropertyValuesHolder.ofKeyframe("scaleX", keyframe1, keyframe2, keyframe3)
  val animator = ValueAnimator.ofPropertyValuesHolder(propertyValuesHolder)
  
  val keyframe1 = Keyframe.ofFloat(0f, 800f)
  val keyframe2 = Keyframe.ofFloat(0.2f, 1000f)
  val keyframe3 = Keyframe.ofFloat(1f, 400f)
  val propertyValuesHolderX = PropertyValuesHolder.ofKeyframe("x", keyframe1, keyframe2, keyframe3)
  val keyframe1 = Keyframe.ofFloat(0f, 0f)
  val keyframe2 = Keyframe.ofFloat(0.2f, 300f)
  val keyframe3 = Keyframe.ofFloat(1f, 1000f)
  val propertyValuesHolderY = PropertyValuesHolder.ofKeyframe("y", keyframe1, keyframe2, keyframe3)
  val animator = ObjectAnimator.ofPropertyValuesHolder(tagetView, propertyValuesHolderX, propertyValuesHolderY)
  ```

##### 属性动画启动

- 动画监听器有两种, 一种是专属 `ValueAnimator`的 `AnimatorUpdateListener` 用于监听动画过程中属性值的变化, 另一种是 `AnimatorListener` 用于监听动画的开始, 结束, 取消, 重复等事件.

```kotlin

// 代码动画启动
val animator = ...
animator.start()

// xml 动画定义需要加载和启动
val animator = AnimatorInflater.loadAnimator(context, R.animator.animator_file) as ValueAnimator | ObjectAnimator | AnimatorSet
animator.setTarget(view)

animator.apply {
    // 设置动画持续时间
    duration = 1000
    // 设置动画插值器
    interpolator = AccelerateDecelerateInterpolator()
    // 添加动画监听器
    addUpdateListener {
        val value = it.animatedValue as Int | Float | PointF
        // 修改目标对象的属性值
    }

    addListener(object : AnimatorListener {
        // 重载方法
    })
}

animator.start()

// 布局动画启动

viewGroup = <LinearLayout android:animateLayoutChanges="true" > </LinearLayout> // xml
viewGroup = code && viewGroup.layoutTransition.enableTransitionType(LayoutTransition.CHANGING) // 代码

val layoutTransition = LayoutTransition()
layoutTransition.setAnimator(LayoutTransition.APPEARING, animator)
layoutTransition.setAnimator(LayoutTransition.DISAPPEARING, animator)
layoutTransition.setAnimator(LayoutTransition.CHANGE_APPEARING, animator)
layoutTransition.setAnimator(LayoutTransition.CHANGE_DISAPPEARING, animator)
layoutTransition.setAnimator(LayoutTransition.CHANGING, animator)
viewGroup.layoutTransition = layoutTransition

```

##### 针对视图的更简易的属性动画启动方式

```kotlin
// 代码动画启动
view.animate().translationX(100f).translationY(100f).rotation(360f).alpha(0.5f).setDuration(1000).start()
```

#### 矢量图动画

矢量图动画: 通过对矢量图的属性进行动画操作, 例如旋转它或更改路径数据以将其变形为不同的图像.

- 动画文件定义位置: `res/drawable/` & `res/animator/`
- 动画定义方式 (xml)

  ```xml
  <!-- res/drawable/vectordrawable.xml  定义矢量图 -->
  <vector xmlns:android="http://schemas.android.com/apk/res/android"
      android:height="64dp"
      android:width="64dp"
      android:viewportHeight="600"
      android:viewportWidth="600">
      <group
          android:name="rotationGroup"
          android:pivotX="300.0"
          android:pivotY="300.0"
          android:rotation="45.0" >
          <path
              android:name="v"
              android:fillColor="#000000"
              android:pathData="M300,70 l 0,-70 70,70 0,0 -70,70z" />
      </group>
  </vector>
  
  <!-- res/animator/animatorvectordrawable.xml  定义矢量图动画 -->
  <animated-vector xmlns:android="http://schemas.android.com/apk/res/android"
  android:drawable="@drawable/vectordrawable" >
      <target
          android:name="rotationGroup"
          android:animation="@animator/rotation" />
      <target
          android:name="v"
          android:animation="@animator/path_morph" />
  </animated-vector>
  
  <!-- res/animator/rotation.xml  定义旋转动画 -->
  <objectAnimator
      android:duration="6000"
      android:propertyName="rotation"
      android:valueFrom="0"
      android:valueTo="360" />
  
  <!-- res/animator/path_morph.xml  定义路径变形动画 -->
  <set xmlns:android="http://schemas.android.com/apk/res/android">
      <objectAnimator
          android:duration="3000"
          android:propertyName="pathData"
          android:valueFrom="M300,70 l 0,-70 70,70 0,0   -70,70z"
          android:valueTo="M300,70 l 0,-70 70,0  0,140 -70,0 z"
          android:valueType="pathType" />
  </set>
  ```

#### Transition (过渡动画)

过渡动画: 用于在两个视图之间进行动画切换, 适用于视图之间的切换效果.

#### 状态列表动画

状态列表动画: 用于在视图的不同状态之间进行动画切换, 适用于视图的状态切换效果.

- 动画文件定义位置: `res/xml/`
- 动画定义方式 (xml)

  ```xml
  <?xml version="1.0" encoding="utf-8"?>
  <selector xmlns:android="http://schemas.android.com/apk/res/android">
      <!-- the pressed state; increase x and y size to 150% -->
      <item android:state_pressed="true">
          <set>
              <objectAnimator android:propertyName="scaleX"
                  android:duration="@android:integer/config_shortAnimTime"
                  android:valueTo="1.5"
                  android:valueType="floatType"/>
              <objectAnimator android:propertyName="scaleY"
                  android:duration="@android:integer/config_shortAnimTime"
                  android:valueTo="1.5"
                  android:valueType="floatType"/>
          </set>
      </item>
      <!-- the default, non-pressed state; set x and y size to 100% -->
      <item android:state_pressed="false">
          <set>
              <objectAnimator android:propertyName="scaleX"
                  android:duration="@android:integer/config_shortAnimTime"
                  android:valueTo="1"
                  android:valueType="floatType"/>
              <objectAnimator android:propertyName="scaleY"
                  android:duration="@android:integer/config_shortAnimTime"
                  android:valueTo="1"
                  android:valueType="floatType"/>
          </set>
      </item>
  </selector>
  ```

- 动画定义方式 (代码)

  ```kotlin
  
  ```

- 动画启动方式 (xml)

  ```xml
  <Button android:stateListAnimator="@xml/animate_scale"
      ... />
  ```

- 动画启动方式 (代码)

  ```kotlin
  val button = findViewById<Button>(R.id.button)
  val stateListAnimator = AnimatorInflater.loadStateListAnimator(this, R.xml.animate_scale)
  button.stateListAnimator = stateListAnimator
  ```

#### 动画实用工具类(圆形揭示动画)

`ViewAnimationUtils` 提供了一些实用的方法来创建和操作动画.

- `createCircularReveal()`: 创建一个圆形揭示动画, 从一个视图的中心开始揭示到视图的边缘.

  ```kotlin
  val view = findViewById<View>(R.id.view)
  // 获取视图的中心坐标
  val cx = view.width / 2
  val cy = view.height / 2
  // 计算揭示动画的半径
  val initialRadius = Math.hypot(cx.toDouble(), cy.toDouble()).toFloat()
  val anim = ViewAnimationUtils.createCircularReveal(view, cx, cy, initialRadius, 0f)
  anim.addListener(object : AnimatorListenerAdapter() {
      override fun onAnimationStart(animation: Animator) {
          view.visibility = View.INVISIBLE
      }
  })
  anim.start()
  ```

#### 动态动画 (dynamicanimation)

`DynamicAnimation` 是一个用于创建动态动画的类, 用于模拟物理运动, 例如弹簧, 摩擦力等. `DynamicAnimation` 有两个子类, 分别是 `SpringAnimation` 和 `FlingAnimation`. `SpringAnimation` 用于模拟弹簧运动, `FlingAnimation` 用于模拟惯性运动.

- 需要引入额外的依赖库

  ```gradle
  dependencies {
      implementation 'androidx.dynamicanimation:dynamicanimation:1.0.0'
  }
  ```

- `ViewProperty` 用于指定需要进行动画操作的属性, 如 `TRANSLATION_X`, `TRANSLATION_Y`, `TRANSLATION_Z`, `ROTATION`, `ROTATION_X`, `ROTATION_Y`, `SCALE_X`, `SCALE_Y`, `X`, `Y`, `Z`, `ALPHA`.
- `FlingAnimation` 用于模拟惯性运动, 例如滑动效果.

  ```kotlin
  val view = findViewById<View>(R.id.view)
  // 计算触摸速度
  val velocityX = 1000f
  val maxScroll = 1000f
  val flingAnimation = FlingAnimation(view, DynamicAnimation.TRANSLATION_X)
  flingAnimation.setStartVelocity(velocityX) // 以每秒像素为单位的速度
  flingAnimation.setMinValue(0f)
  flingAnimation.setMaxValue(maxScroll)
  flingAnimation.setFriction(1.1f) // 摩擦力, 定义了动画中速度降低的速度
  flingAnimation.start()
  ```

- `SpringAnimation` 用于模拟弹簧运动, 例如弹簧的拉伸和压缩效果.

  ```kotlin
  val view = findViewById<View>(R.id.view)
  val springAnimation = SpringAnimation(view, DynamicAnimation.TRANSLATION_Y, 0f)
  springAnimation.spring.stiffness = SpringForce.STIFFNESS_LOW
  springAnimation.spring.dampingRatio = SpringForce.DAMPING_RATIO_HIGH_BOUNCY
  springAnimation.addUpdateListener { animation, value, velocity ->
      // 更新视图的属性值
  }
  springAnimation.addEndListener { animation, canceled, value, velocity ->
      // 动画结束时的回调
      flingAnimation.start()
  }
  springAnimation.start()
  ```

## 网络库(HttpURLConnection, OkHttp, Retrofit, 内部库)

网络请求库 = 网络请求 + 数据解析 + 线程切换(异步) + 异常处理

### HttpURLConnection

> [!TODO]

### OkHttp

> [!cite] > [【OkHttp】OkHttp Get 和 Post 请求 ( 同步 Get 请求 | 异步 Get 请求 | 同步 Post 请求 | 异步 Post 请求 )-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/2249988) > [网络请求框架 OkHttp3 全解系列 (一) ：OkHttp 的基本使用-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/1667338) > [由浅入深, 聊聊 OkHttp 的那些事(易懂, 不繁琐) - 掘金](https://juejin.cn/post/7199431845367922745?searchId=20240806152219108948FAF7C05048547D) > [Android 主流网络请求框架 OkHttp 全方位详析 - 掘金](https://juejin.cn/post/7345756317557817354?searchId=20240806152219108948FAF7C05048547D) > [从 OKHttp 框架看代码设计](https://juejin.cn/post/6844903449469943821?searchId=2024080615223180876F5097A608E5EACE) > [HTTP 客户端连接, 选择 HttpClient 还是 OkHttp？](https://juejin.cn/post/6844904040644476941?searchId=2024080615223180876F5097A608E5EACE) > [OkHttp 的完整指南](https://juejin.cn/post/7068162792154464264?searchId=2024080615223180876F5097A608E5EACE) > [雨露均沾的 OkHttp—WebSocket 长连接 (使用篇) - 掘金](https://juejin.cn/post/6847009772198166536?searchId=2024080615223180876F5097A608E5EACE) > [官方推荐使用的 OkHttp4 网络请求库全面解析！](https://juejin.cn/post/7212536164057776184?searchId=2024080615223180876F5097A608E5EACE) > [OkHttp 拦截器的一些骚操作 - 掘金](https://juejin.cn/post/6844903606718562317?searchId=2024080615223180876F5097A608E5EACE) > [一篇文章带你走通 OkHttp+Retrofit+Rxjava - 掘金](https://juejin.cn/post/6844903464082866190?searchId=2024080615223180876F5097A608E5EACE) > [使用 Retrofit 2.0 + OkHttp 3.0 实现缓存处理 - 掘金](https://juejin.cn/post/6844903444285751309?searchId=2024080615223180876F5097A608E5EACE) > [OKHttp 源码解析(一)--初阶-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/1199021)

- 简洁易用的 API：通过构建 Request 对象和使用 Call 对象来发起同步或异步的网络请求.
- 支持现代的 HTTP 协议, 包括 HTTP/2 和 SPDY
- 连接池和缓存：OkHttp 内置了连接池和响应缓存, 可以有效地管理和复用网络连接, 并提供可配置的缓存机制, 减少重复的网络请求.
- 自动重试 ：在请求失败时自动重试请求, 从而提高请求可靠性.
- 拦截器：提供拦截器机制, 允许在发送请求和接收响应的过程中进行自定义处理, 例如添加公共参数、日志记录等.
- 支持 gzip 压缩 ：支持接受和解压 GZIP 压缩的响应数据, 减小网络传输的数据量, 提升网络性能.

#### 使用

![_](%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91.assets/file-20240806154800379.png)

```kotlin
val client = OkHttpClient.Builder() // 1. 创建 OkHttpClient 实例
    .connectTimeout(5000L, java.util.concurrent.TimeUnit.MILLISECONDS)
    .readTimeout(5000L, java.util.concurrent.TimeUnit.MILLISECONDS)
    .writeTimeout(5000L, java.util.concurrent.TimeUnit.MILLISECONDS)
    .retryOnConnectionFailure(true)
    .followRedirects(true)
    .followSslRedirects(true)
    .cache(null) // 设置缓存
    .authenticator(null) // 设置身份验证器
    .certificatePinner(null) // 设置证书锁定器
    .connectionPool(null) // 设置连接池
    .connectionSpecs(listOf()) // 设置连接规范
    .cookieJar(null) // 设置 Cookie 管理器
    .dispatcher(null) // 设置分发器
    .dns(null) // 设置 DNS 解析器
    .eventListenerFactory(null) // 设置事件监听器工厂
    .proxy(null) // 设置代理
    .protocols(listOf()) // 设置支持的协议
    .proxyAuthenticator(null) // 设置代理身份验证器
    .proxySelector(null) // 设置代理选择器
    .socketFactory(null) // 设置 Socket 工厂
    .hostnameVerifier(null) // 设置主机名验证器
    .build()

val getRequest = Request.Builder() // 2. 创建 Request 对象
    .url("https://reqres.in/api/users?page=2")
    .header("name", "value")
    .addHeader("name", "value")
    .cacheControl(null) // 设置缓存控制
    .build()

// 3. 同步请求
val response1 = client.newCall(getRequest).execute().use { response ->
    response.body?.string() ?: ""
}

// 3. 异步请求, 如果当前 request 已执行, 抛出错误
val response2 = client.newCall(get).enqueue(object : Callback {
    override fun onFailure(call: Call?, e: IOException) {
        //
    }

    override fun onResponse(call: Call?, response: Response) {
        val content = response.body?.string() ?: ""
    }
})
```

#### 原理

> [!cite] > [由浅入深, 聊聊 OkHttp 的那些事(易懂, 不繁琐) - 掘金](https://juejin.cn/post/7199431845367922745?searchId=20240806152219108948FAF7C05048547D) > [面试官：听说你熟悉 OkHttp 原理？ - 掘金](https://juejin.cn/post/6844904087788453896?searchId=20240806152219108948FAF7C05048547D)

![_](%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91.assets/file-20240806152547281.png)

> [!TODO]

### Retrofit

> [!TODO]

### 内部库

## 临时

### Git – 断点续传 git 大项目

假设要从 GitHub 拉取 OpenCV：[https://github.com/opencv/opencv 进行编译](https://github.com/opencv/opencv进行编译), 可以按照以下的方法.

1. 首先新建一个项目文件夹, 初始化空白 git 仓库

   ```bash
   mkdir opencv
   cd opencv
   git init
   ```

2. 添加远程仓库

   ```bash
   git remote add origin https://github.com/opencv/opencv
   ```

3. 拉取所有分支、标签和完整历史记录

   ```bash
   git fetch origin --prune --tags +refs/heads/*:refs/remotes/origin/*
   
   origin：指定远程仓库名.
   --prune：删除本地没有的远程分支.
   --tags：获取所有标签.
   +refs/heads/*:refs/remotes/origin/*：获取远程仓库的所有分支, 并将其映射到本地的 refs/remotes/origin/ 下, 一般可以不加此选项
   ```

4. 如果第 3 步中断或者失败, 则重复执行第 3 步, 直到完成下载
5. 下载完成之后, 检出需要的分支或标签, 如 master

   ```bash
   git branch -r
   git tag
   git checkout master
   ```

6. 更新所有本地分支和远程分支的映射关系

   ```bash
   git pull origin --all
   ```

7. 再执行 `git checkout master` 命令

在 Linux 系统下, 可以写一个 shell 脚本, 自动循环进行 `git fetch`.

### 为什么减少依赖很重要？

这段内容强调了在开发 Android 应用时, 应该尽量减少对 Android 框架类 (如 Context、Toast 等) 的直接依赖, 将这些依赖隔离在少数核心组件中. 这样做的主要目的是提高代码的可测试性和模块化, 降低耦合度.

1. 提高可测试性：当类依赖于 Android 框架时 (例如需要一个 Context 实例) , 在编写单元测试时, 必须模拟这些依赖对象, 这可能会增加复杂性. 如果业务逻辑不依赖于 Android 框架类, 那么编写单元测试就变得更加容易, 因为你只需要测试纯粹的业务逻辑, 而不必处理 Android 特有的依赖.
2. 降低耦合度：如果类依赖于 Android 框架, 它们就只能在 Android 环境中运行 (例如设备或模拟器). 通过减少这种依赖性, 代码可以更独立、更灵活, 可以在不同的环境中复用, 且不容易受到 Android 特定 API 的限制.  
   举例说明  
   不良的依赖设计  
   考虑以下示例, 一个 UserManager 类直接依赖于 Context 来获取资源或展示 Toast：

```kotlin
class UserManager(private val context: Context) {

    fun showWelcomeMessage() {
        // 使用 Context 来显示 Toast 消息
        Toast.makeText(context, "Welcome!", Toast.LENGTH_SHORT).show()
    }
}
```

在这个设计中, UserManager 类直接依赖于 Context, 这会带来以下问题：

- 难以测试：在测试时, 你需要提供一个 Context 实例, 这可能会使测试更加复杂和笨重.
- 耦合性高：UserManager 只能在 Android 环境中使用, 因为它需要一个 Context 实例.  
  改进后的设计  
  现在我们将 UserManager 中与 Android 相关的操作抽离到一个单独的接口中, 这样就可以减少对 Android 类的直接依赖：

```kotlin
interface MessageDisplayer {
    fun showMessage(message: String)
}

class ToastMessageDisplayer(private val context: Context) : MessageDisplayer {
    override fun showMessage(message: String) {
        Toast.makeText(context, message, Toast.LENGTH_SHORT).show()
    }
}

class UserManager(private val messageDisplayer: MessageDisplayer) {

    fun showWelcomeMessage() {
        // 使用抽象接口来显示消息
        messageDisplayer.showMessage("Welcome!")
    }
}
```

在这个改进的设计中：

- MessageDisplayer：定义了一个抽象接口, 它不依赖于 Android 框架. 这个接口可以有不同的实现, 比如 ToastMessageDisplayer 用于 Android 环境.
- ToastMessageDisplayer：是 MessageDisplayer 的具体实现, 负责实际显示 Toast 消息. 它依赖 Context, 但这种依赖被隔离在了这个具体的类中.
- UserManager：现在只依赖于 MessageDisplayer 接口, 而不是直接依赖 Context. 这使得 UserManager 可以轻松地进行单元测试, 因为你可以传递一个简单的 MessageDisplayer mock 对象.  
  在测试中的优势  
  在测试 UserManager 时, 你不再需要依赖 Context 或 Android 特有的类：

```kotlin
class FakeMessageDisplayer : MessageDisplayer {
    var message: String? = null

    override fun showMessage(message: String) {
        this.message = message
    }
}

fun testShowWelcomeMessage() {
    val fakeMessageDisplayer = FakeMessageDisplayer()
    val userManager = UserManager(fakeMessageDisplayer)

    userManager.showWelcomeMessage()

    assert(fakeMessageDisplayer.message == "Welcome!")
}
```

在这个测试中, FakeMessageDisplayer 是 MessageDisplayer 的一个简单实现, 允许你检查 UserManager 的行为而不需要 Context.  
总结  
减少对 Android 类的直接依赖, 通过使用接口或抽象类来隔离 Android 相关操作, 可以让你的应用更加模块化和可测试. 你可以将业务逻辑与 Android 特有的实现细节分开, 使代码更灵活、更容易测试, 也更符合 SOLID 原则中的单一职责和依赖倒置原则.

### 文件读写和权限说明

> [!todo] > [记一个 Android 14 适配引发的 Android 存储权限问题](https://www.cnblogs.com/joy99/p/17809113.html) > [Android 文件读写最全解析](https://www.cnblogs.com/joy99/p/17809113.html) > [Android 数据存储五种方式使用与总结.md](<https://github.com/helen-x/AndroidInterview/blob/master/android/Android> 数据存储五种方式使用与总结.md)

sharedPreferences: 基于 XML 文件存储的键值对数据, 根据第一个参数 name 获得相应的 SharedPreferences 对象

- MODE_PRIVATE: 只能被本应用程序读、写
- MODE_WORLD_READABLE: 其他应用程序可以读, 但不能写
- MODE_WORLD_WRITEABLE: 其他应用程序可以读, 写
- MODE_MULTI_PROCESS: 当多个进程同时读写同一个 SharedPreferences 时, 会检查文件是否修改

## Android 多线程

任务执行和管理: `Thread` | `Runnable` | `Executors` | `WorkManager` (`AsyncTask` 弃用了) | `ThreadPoolExecutor`  
任务反馈及交互: `Callable` | `Future` | `FutureTask` | `Handler` | `HandlerThread` |

### 直接创建和管理线程及其任务

子类化 `Thread`. 通过复写 `run` 方法自定义线程任务, 同时可以通过创建的线程对象管理线程, 如 运行、睡眠、挂起、停止.

```kotlin
class MyThread(name: String) : Thread(name) {
    private var ticket = 100
    override fun run() {
        while (ticket > 0) {
            ticket--
            Thread.sleep(1000)
        }
    }
}

// 创建线程对象并启动
val mt = MyThread("线程名称")
mt.start()

// 使用匿名类创建和启动线程
Thread("线程名称") {
    var ticket = 100
    while (ticket > 0) {
        ticket--
        println("线程名称: 卖掉了1张票, 剩余票数为: $ticket")
        Thread.sleep(1000) // 卖票速度是1秒一张
    }
}.start()
```

### 任务与线程分离, 实现线程复用和资源共享

通过实现 `Runnable` 任务接口, 只需要定义一个 `run` 方法来自定义线程任务(即只关注于任务). 通过创建 `Runnable` 任务对象, 并将 `Runnable` 对象传递给一个或多个线程对象, 使得线程对象可以执行 `Runnable` 对象定义的线程任务, 同时共享此 `Runnable` 对象中的资源. 线程的管理仍是通过线程对象自身进行, 但是无需子类化 `Thread`.

```kotlin
class MyRunnable : Runnable {
    private var ticket = 100
    override fun run() {
        while (ticket > 0) {
            ticket--
            Thread.sleep(1000)
        }
    }
}

// 创建线程对象并启动任务
val myRunnable = MyRunnable()
val thread1 = Thread(myRunnable)
val thread2 = Thread(myRunnable)
thread1.start()
thread2.start()

// 使用匿名 Runnable 创建和启动线程
val runnable = Runnable {
    var ticket = 100
    while (ticket > 0) {
        ticket--
        Thread.sleep(1000)
    }
}

Thread(runnable, "线程名称1").start()
Thread(runnable, "线程名称2").start()

// 使用 lambda 表达式创建和启动线程, lambda 表达式会被自动转换成 Runnable.
Thread {
    var ticket = 100
    while (ticket > 0) {
        ticket--
        Thread.sleep(1000)
    }
}.start()
```

### 使用线程池简化线程创建和生命周期管理

将任务提交给线程池, 根据需要分配线程来执行任务.

`Executor` 是一个接口, 只限制了实现任务提交到线程池和任务执行的功能.  
`ExecutorService` 是在 `Executor` 的基础上进一步定义的接口, 提供了控制任务执行和更高级的任务提交功能.

- `shutdown()` 方法停止提交任务, 并允许先前提交的任务继续执行, 直到执行完成.
- `shutdownNow()` 方法停止提交任务, 并阻止等待先前提交的任务, 尝试停止当前正在执行的任务.
- `submit(...)` 方法提交任务, 并返回一个可用于取消任务执行和存放任务结果的 `Future` 对象.
- `invokeAny` 和 `invokeAll` 执行一组任务, 然后等到至少一个或全部任务完成.  
  `ScheduledExecutorService` 是在 `ExecutorService` 基础上进一步定义的接口, 提供了延迟和周期性执行任务的功能.
- `schedule(...)` 方法, 用于延迟执行任务.
- `scheduleAtFixedRate(...)` 方法, 用于周期性执行任务.
- `scheduleWithFixedDelay(...)` 方法, 用于周期性执行任务, 但是在任务完成后的固定延迟后再次执行.

完整的实现了 `ExecutorService` 或 `ScheduledExecutorService` 的线程池服务类型有:

- `ForkJoinPool`
- `ScheduledExecutorService`
- `ThreadPoolExecutor`

    - `ScheduledThreadPoolExecutor`

`Executors` 是一个工具类, 提供了方便的工厂方法来创建以上列举的不同类型的线程池服务对象.

```kotlin
// 固定大小的线程池, 适用于需要限制线程数量, 且需要复用线程执行大量短期任务的场景
val executor = Executors.newFixedThreadPool(3) // ExecutorService
// 可缓存的线程池, 优先复用已有线程, 不足时根据需要创建新线程, 适用于执行大量生存期很短的异步任务
val executor = Executors.newCachedThreadPool()
// 只有一个线程, 所有任务按照提交顺序执行
val executor = Executors.newSingleThreadExecutor()
executor.execute { Thread.sleep(1000) } // 模拟任务执行时间
executor.shutdown()

// 定时任务线程池, 适用于需要延迟执行或周期性执行任务的场景
val scheduler = Executors.newScheduledThreadPool(2)
scheduler.schedule({ Thread.sleep(1000) }, 2, TimeUnit.SECONDS) // 延迟2秒后执行
scheduler.scheduleAtFixedRate({ Thread.sleep(1000) }, 1, 3, TimeUnit.SECONDS) // 延迟1秒后, 每3秒执行一次
scheduler.shutdown()

// 自定义线程池
val threadPool = ThreadPoolExecutor(
    2, // 核心线程数
    4, // 最大线程数
    60, // 空闲线程存活时间
    TimeUnit.SECONDS, // 时间单位
    LinkedBlockingQueue<Runnable>(2) // 任务队列
)
threadPool.execute { Thread.sleep(1000) } // 模拟任务执行时间
threadPool.shutdown()
```

### 异步获取任务结果

`ExecutorService` 和 `ScheduledExecutorService` 两种任务执行器类型的 `submit` 或 `schedule` 等方法均可以通过传递一个 `Callable` 任务对象来返回一个表示异步计算结果的 `Future` 或 `ScheduledFuture` 对象. 通过 `Future` 对象可以取消其所绑定的任务, 获取任务执行状态, 以及获取任务执行结果.

```kotlin
val executor = Executors.newSingleThreadExecutor()
val callableTask = Callable {
    Thread.sleep(1000)
    "Callable 任务执行结果"
}
val future: Future<String> = executor.submit(callableTask)
println("任务执行结果: ${future.get()}")
executor.shutdown()

Thread 可以通过 FutureTask 将任务进行封装, 其可以同时作为 Runnable 任务对象和 Future 对象作为任务载体, 同时获取和控制线程状态.
val futureTask = FutureTask<String> {
    "Hello"
}
Thread(futureTask).start()
val result = futureTask.get()
```

### 不同任务线程间进行消息传递

在线程中通过 `Handler`、`MessageQueue` 和 `Looper` 实现在不同线程间传递消息和执行任务.

- `MessageQueue` 用于在线程内部存储待处理的消息 `Message` 和任务 `Runnable`. 一种基于单链表的数据结构实现的消息队列, 支持对内部 `Message` 的插入 `enqueueMessage`、取出 `next`、移除 `removeMessages` 等操作. 此外, `MessageQueue` 与 `Looper` 绑定, 当创建 `Looper` 时, 会自动创建一个 `MessageQueue` 对象, 并将其绑定到当前线程, 不需要手动创建.
- `Looper` 负责循环处理消息队列中的消息. 每个线程可以通过内部调用 `Looper.prepare()` 创建一个 `Looper` 对象, 并通过 `Looper.loop()` 方法启动消息处理循环, 注意只能创建一个 `Looper` 对象, 主线程默认已经创建了一个 `Looper` 对象. 启动消息处理循环后, `Looper` 会不断从消息队列中取出消息, 并将其分发给目标 `Handler` 处理, 直到消息队列为空. 未处理完成或手动退出消息处理循环前, 线程会一直处于阻塞状态.
- `Handler` 用于发送和处理消息 `Message` 和任务 `Runnable`. 每个线程可以有多个 `Handler` 对象, 但是每个 `Handler` 对象只能绑定到一个指定的 `Looper` 对象(默认为当前线程的 `Looper`). 通过 `Handler` 的 `sendMessage` 方法向绑定的 `Looper` 的消息队列中发送消息, 通过 `Handler` 的 `post` 方法向消息队列中发送任务. 支持消息的延迟发送.
- `Message` 用于封装消息内容, 包括 `arg1` 和 `arg2` 两个存储整数的参数、`obj` 存储接收者对象的引用、`what` 存储消息类型或用户定义的消息代码、`target` 存储消息接收者的 `Handler` 对象、`callback` 存储消息处理回调函数等.

```kotlin
import android.os.Handler
import android.os.Looper
import android.os.Message

fun main() {
    // 主线程的 Handler, 用于发送消息到后台线程
    val mainHandler = Handler(Looper.getMainLooper())

    val backgroundThread = BackgroundThread()
    backgroundThread.start()

    mainHandler.post {
        println("主线程发送消息到后台线程")
        val message = Message.obtain()
        message.what = 1
        message.obj = "Hello from the Main Thread!"
        backgroundThread.getHandler()?.sendMessage(message)
    }
}

class BackgroundThread : Thread() {
    private var backgroundHandler: Handler? = null

    override fun run() {
        Looper.prepare()
        backgroundHandler = MyHandler(Looper.myLooper()!!)
        Looper.loop()
    }

    fun getHandler(): Handler? {
        return backgroundHandler
    }
}

// 自定义后台线程的消息处理逻辑
class MyHandler(looper: Looper) : Handler(looper) {
    override fun handleMessage(msg: Message) {
        when (msg.what) {
            1 -> {
                println("后台线程处理消息: ${msg.obj}")
                val mainHandler = Handler(Looper.getMainLooper())
                mainHandler.post {
                    println("主线程收到消息: ${msg.obj}")
                }
            }
        }
    }
}


```

在线程中通过 `HandlerThread` 和 `Handler` 实现在不同线程间传递消息和执行任务.

- `HandlerThread` 是一个带有 `Looper` 的线程类, 用于在后台线程中执行任务和处理消息. `HandlerThread` 继承自 `Thread` 类, 通过 `Looper` 实现了消息循环处理机制, 可以通过 `getLooper()` 方法获取 `Looper` 对象, 通过 `quit()` 方法退出消息循环.
- `HandlerThread` 与 `Handler` 结合使用, 可以实现在后台线程中执行任务和处理消息, 通过 `HandlerThread` 的 `getLooper()` 方法获取 `Looper` 对象, 并通过 `Handler` 的构造方法传入 `Looper` 对象, 从而实现消息的发送和处理.

```kotlin
import android.os.Handler
import android.os.HandlerThread
import android.os.Looper
import android.os.Message

fun main() {
    // 主线程的 Handler, 用于发送消息到后台线程
    val mainHandler = Handler(Looper.getMainLooper())

    // 创建并启动 HandlerThread
    val backgroundThread = HandlerThread("BackgroundThread")
    backgroundThread.start()
    val backgroundHandler = Handler(backgroundThread.getLooper())

    //
    mainHandler.post {
        println("主线程发送消息到后台线程")
        val message = Message.obtain()
        message.what = 1
        message.obj = "Hello from the Main Thread!"
        backgroundHandler.sendMessage(message)
    }
}

class MyHandler(looper: Looper) : Handler(looper) {
    override fun handleMessage(msg: Message) {
        when (msg.what) {
            1 -> {
                println("后台线程处理消息: ${msg.obj}")
                // 处理完任务后, 将结果发送回主线程
                val mainHandler = Handler(Looper.getMainLooper())
                mainHandler.post {
                    println("主线程收到消息: ${msg.obj}")
                }
            }
        }
    }
}
```

## 路由框架

> [!Cite] > [ARouter](https://github.com/alibaba/ARouter) > [ActivityRouter](https://github.com/mzule/ActivityRouter) > [WMRouter](https://github.com/meituan/WMRouter) > [TheRouter](https://github.com/HuolalaTech/hll-wp-therouter-android) > [DRouter](https://github.com/didi/DRouter) > [BRouter](https://github.com/bilibili/BRouter) > [Custom Router](https://github.com/gdutxiaoxu/Router) > [Custom Router](https://github.com/waws80/Router) > [Custom Router](https://github.com/chenenyu/Router) > [Android 路由框架用法大全](https://juejin.cn/post/6984993972804550692) > [Android 组件化 —— 路由设计最佳实践](https://cloud.tencent.com/developer/article/1356515) > [Android 客户端路由框架的整理和思考](https://www.jianshu.com/p/15d8cc6cf19b) > [GRouter](https://github.com/taoweiji/grouter-android/)

| 功能模块             | ARouter 功能                                                   | 说明                                                             |
| -------------------- | -------------------------------------------------------------- | ---------------------------------------------------------------- |
| **页面跳转**         | 支持直接通过路径跳转到目标页面                                 | 通过 `@Route` 标注路径，简化跳转逻辑                             |
| **参数传递**         | 支持多种参数类型，包括基本数据类型、自定义对象等               | 参数通过 `@Autowired` 自动注入，简化开发                         |
| **转场动画**         | 支持跳转时自定义转场动画                                       | 可通过常规方式或 `ActivityOptionsCompat` 自定义动画              |
| **跳转拦截器**       | 可定义多个拦截器，按优先级执行                                 | 常用于登录检查、埋点等逻辑，简化重复代码                         |
| **全局降级策略**     | 自定义降级处理逻辑，支持页面未找到等情况                       | 降级策略提升用户体验，特别是路径失效或目标不存在时               |
| **服务注册与发现**   | 支持跨模块服务发现和依赖注入，模块间解耦                       | 通过 `@Route` 注解和 `IProvider` 接口实现服务发现                |
| **参数序列化**       | 支持自定义对象序列化，通过实现 `SerializationService` 接口实现 | 支持复杂数据结构和自定义对象的传递                               |
| **动态注册**         | 支持动态注册路由信息，适用于插件化架构                         | 通过 `addRouteGroup` 方法动态添加路由信息                        |
| **路径重写**         | 支持路径或 URL 的动态重写                                      | 通过实现 `PathReplaceService` 接口，对路径重写或重定向           |
| **自动生成文档**     | 支持自动生成路由文档                                           | 可生成 JSON 格式文档，用于团队协作                               |
| **多模块支持**       | 支持多模块工程，分组按需初始化                                 | 各模块的路由按组分类加载，节约资源                               |
| **Debug 与日志控制** | 支持调试模式和日志开关，便于开发调试                           | 可通过 `ARouter.openLog()` 和 `ARouter.openDebug()` 控制日志输出 |
| **增量编译**         | 支持增量编译，提高编译速度                                     | 可开启增量编译，但开启文档生成后会关闭增量编译                   |
| **IDE 插件支持**     | 提供 Android Studio 插件，便于路径跳转                         | 可通过 ARouter Helper 插件快速跳转到目标类，提高开发效率         |

### ARouter 解析

#### 设计理念

帮助 Android App 进行组件化改造, 支持模块间的路由、通信、解耦.

- 编译时基于注解处理器(apt)来生成路由表. 在每个组件的 build.gradle 文件中, 配置注解处理器的依赖和配置信息即可在编译时自动扫描组件内所有使用了预设注解(如 `@Route`)的类, 属性, 或方法, 然后根据注解中的信息生成一个路由表, 包含路径到目标类的映射关系和参数信息.
- 运行时基于反射机制创建目标类实例. 在运行时, 通过路由表中的路径信息获取到目标类的类名, 然后通过反射机制创建目标类的实例, 并将参数注入到目标类中, 最后调用目标类的方法.
- 支持 Activity, Fragment, Service, Provider, CONTENT_PROVIDER, BOARDCAST, METHOD 等多种路由类型.
- 支持直接解析标准 URL 进行跳转. 实现跨端统一跳转协议, 通过 URL 跳转到指定页面.
- 支持跳转时自定义转场动画. 实现多种场景下的转场动画.
- 支持定义多个拦截器, 按优先级顺序执行. 实现通过路径跳转到目标页面前的拦截处理, 常用于登录检查、埋点等逻辑, 简化重复代码.
- 支持自定义全局与局部降级处理逻辑. 实现当路径失效或目标不存在时的降级处理, 提升用户体验.
- 支持通过预设注解自动注入多种参数类型, 包括基本数据类型、自定义对象等. 实现通过路径跳转到目标页面, 无需手动解析传递的参数, 简化开发.
- 支持生成路由文档. 实现自动生成 JSON 格式文档, 用于团队协作.
- 支持增量编译(开启文档生成后无法增量编译).
- 提供 IDE 插件支持. 实现通过 ARouter Helper 插件快速跳转到目标类, 提高开发效率.
- 支持多模块工程. 实现路由按模块进行分组加载, 节约资源.

#### 使用介绍

- 添加依赖和配置

  ```gradle
  android {
      defaultConfig {
          ...
          javaCompileOptions {
              annotationProcessorOptions {
                  arguments = [AROUTER_MODULE_NAME: project.getName()]
              }
          }
      }
  }
  dependencies {
      implementation 'com.alibaba:arouter-api:1.5.1'
      kapt 'com.alibaba:arouter-compiler:1.2.2'
  }
  ```

- 在需要跳转的 Activity 上添加注解

  ```kotlin
  @Route(path = "/test/activity")
  class TestActivity : AppCompatActivity() {
      ...
  }
  ```

- 添加可传递参数

  ```kotlin
  @Route(path = "/test/activity")
  class TestActivity : AppCompatActivity() {
      @Autowired
      var name: String? = null
  
      // 自定义映射关系
      @Autowired(name = "girl")
      var boy: String? = null
  
      // json 与 object 映射(需要对象实现 Parcelable 接口)
      @Autowired
      var obj: TestObj? = null
      var map: Map<String, String>? = null
      var list: List<TestObj>? = null
  
      override fun onCreate(savedInstanceState: Bundle?) {
          super.onCreate(savedInstanceState)
          ARouter.getInstance().inject(this) // 自动注入参数
      }
  }
  ```

- 使用拦截器

  ```kotlin
  @Interceptor(priority = 1, name = "TestInterceptor")
  class TestInterceptor : IInterceptor {
      override fun process(postcard: Postcard, callback: InterceptorCallback) {
          // 拦截器处理逻辑
          callback.onContinue(postcard)
      }
  
      override fun init(context: Context) {
          // 拦截器的初始化，会在sdk初始化的时候调用该方法，仅会调用一次
      }
  }
  ```

- 自定义全局降级策略

  ```kotlin
  @Route(path = "/service/degrade")
  public class DegradeServiceImpl implements DegradeService {
  
      @Override
      public void onLost(Context context, Postcard postcard) {
          // 当找不到页面时执行的操作，例如跳转到一个错误页面或提示
      }
  
      @Override
      public void init(Context context) {
          // 初始化代码，可以为空
      }
  }
  ```

- 在 Application 中初始化 ARouter

  ```kotlin
  class App : Application() {
      override fun onCreate() {
          super.onCreate()
          ARouter.init(this)
      }
  }
  ```

- 跳转到指定 Activity

  ```kotlin
  // 简单跳转
  ARouter.getInstance().build("/test/activity").navigation()
  // 携带参数跳转
  ARouter.getInstance().build("/test/activity")
      .withString("key", "value")
      .navigation()
  // 通过类型跳转
  ARouter.getInstance().navigation(TestActivity::class.java)
  ```

#### 源码解析

##### 前置知识

- `编译期元数据` 是指在编译时生成的元数据, 用于描述源代码的结构和信息, 通常用于代码生成、代码检查、代码优化等场景.

    - `SourceVersion` 枚举表示 Java 语言的版本, 通常用于判断当前编译环境支持的 `Java` 版本。
    - `Elements` 是 Java 编译器提供的是一个工具接口, 提供了一系列用于获取和操作源代码元素信息的便捷方法, 包括类、方法、字段、注解等.

        - `TypeMirror` 是 Java 编译器提供的一个接口, 用于表示 Java 类型, 包括基本数据类型、数组、泛型、通配符、类型变量、方法类型等.
        - `getEnclosedElements` 方法用于获取指定元素直接包含的子元素, 如类或接口的字段、方法、构造函数和内部类型; 包的顶级类和接口; 模块的包。
        - `getEnclosingElement` 方法用于获取当前元素的直接上层结构, 如类的包、方法的类、字段的类等.

    - `Types` 是 Java 编译器提供的一个工具接口, 提供了对 Java 类型(如类、接口、枚举等)进行分析、比较、转换等操作的方法.

- `AnnotationProcessor` 是 Java 编译器的一个工具, 用于在编译时扫描和处理注解.

    - `AbstractProcessor` 是所有注解处理器的基类. 编写自定义注解处理器时继承该类, 并实现 `process` 方法即可在编译期间实现自定义的注解处理逻辑.
    - `Filer` 注解处理工具中提供的一个接口, 用于创建新文件、类文件、资源文件等.

        - `Writer` 是 Java IO 提供的一个抽象类, 用于写入字符流, 如 json 文件.

    - `Messager` 是注解处理工具中提供的一个接口, 用于输出信息、警告、错误等.
    - Options: `Map<String,String>` 是传递给注解处理器的配置参数信息.
    - `ProcessingEnvironment` 是传递给注解处理器的编译时环境信息, 可以通过该对象获取到 `Filer`、`Elements`、`Types` 等工具对象.
    - 注解处理器的处理是分轮次（round）进行的, 每轮都会重复调用 process 方法. 第一轮编译器扫描所有源文件, 并调用 process 方法, 之后判断当前轮次是否有新的源文件生成, 如果有则继续扫描, 否则结束处理.

- `AutoService` 是 Google 提供的一个库, 用于简化 `AnnotationProcessor` 的 SPI(Service Provider Interface) 注册.
- `JavaPoet` 是一个用于生成 Java 源代码的库, 通过 `JavaPoet` 可以在编译时生成 Java 代码, 用于生成路由表.

    - `ClassName` 用于表示类名, 如 `com.alibaba.arouter.facade.annotation.Route`.
    - `ParameterizedTypeName` 用于表示类型, 如 List`<String>`、Map<String, Integer> 等.
    - `ParameterSpec` 用于表示方法参数, 可以通过 `ParameterizedTypeName` 指定类型.
    - `MethodSpec` 用于表示方法, 可以通过 `ParameterSpec` 指定方法参数.

- 反射机制: Java 提供的用于在运行时获取类的信息、属性、方法、构造方法等, 并通过反射机制调用类的方法、获取属性值等.

    - `Class` 类用于表示类的信息, 包括类名、属性、方法、构造方法等.
    - `Field` 类用于表示类的属性信息, 包括属性名、属性类型、属性值等.
    - `Method` 类用于表示类的方法信息, 包括方法名、方法参数、方法返回值等.
    - `Constructor` 类用于表示类的构造方法信息, 包括构造方法参数、构造方法访问修饰符等.

##### arouter-annotation

声明了 ARouter 框架中使用的注解类型和一些枚举类

- `@Route(path: String, group: String = "", name: String = "", extras: Int = 0, priority: Int = -1)` 用于标注路由路径信息.
- `@Autowired(name: String = "", required: Boolean = false, desc: String = "")` 用于标注目的对象内部的属性, 用于自动注入参数.
- `@Interceptor(priority: Int, name: String = "")` 用于标注拦截器信息.
- `RouteType` 枚举类, 用于定义路由类型.

    - `ACTIVITY`, `FRAGMENT`: 页面路由类型, 用于打开某个页面.
    - `SERVICE`: 后台服务路由类型, 用于打开某个需要后台运行的服务.
    - `PROVIDER`: 接口服务提供者路由类型, 用于获取某个接口的具体实现.
    - `ContentProvider`: 内容提供者路由类型, 用于获取某个内容提供者的实例. 内容提供者可以提供数据给其他应用程序.
    - `BOARDCAST`: 广播路由类型, 用于发送广播.
    - `METHOD`: 方法路由类型, 用于调用某个方法.

- `RouteMeta` 数据类, 用于封装路由信息, 包括路径、组、名称、类型、优先级、降级策略、拦截器、参数等信息.

    - `type: RouteType`: 路由类型.
    - `rawType: Element`: 路由目标类原始信息
    - `destination: Class<?>`: 路由目标类具体
    - `path: String`: 路由跳转路径, 为 `@Route` 注解中的 `path` 属性.
    - `group: String`: 路由路径所在组, 一般为默认组(路径第一个 `/` 后的字符串, 没有则分组为 null).
    - `priority: int`: 路由优先级.
    - `extra: int`: 路由附加信息.
    - `paramsType: Map<String, Integer>`: 路由注入的所有参数类型.
    - `name: String`: 路由名称.
    - `injectConfig: Map<String, Autowired>`: 路由注入的所有参数配置.

- `TypeKind` 枚举类, 用于定义所支持的自动注入参数类型.
    - 基本类型: `BOOLEAN`, `BYTE`, `SHORT`, `INT`, `LONG`, `CHAR`, `FLOAT`, `DOUBLE`.
    - 其他类型: `STRING`, `SERIALIZABLE`, `PARCELABLE`, `OBJECT`.

##### arouter-compiler

实现了注解处理器, 用于在编译时扫描组件内所有使用了预设注解的类, 属性, 或方法, 然后根据注解中的信息生成一个路由表, 包含路径到目标类的映射关系和参数信息.

项目中要处理注解自动生成路由表代码, 则必须依赖 `arouter-compiler` 模块, 并在 `build.gradle` 文件中配置 `kapt` 插件. 以下是 `arouter-compiler` 中包含的注解处理器:

- `AutowiredProcessor` 支持解析 `@Autowired` 注解.
- `InterceptorProcessor` 支持解析 `@Interceptor` 注解.
- `RouteProcessor` 支持解析 `@Route` 和 `@Autowired` 注解.

注解处理器的处理顺序: `AutowiredProcessor` -> `InterceptorProcessor` -> `RouteProcessor`.

注解处理时分模块处理, 区分模块采用 `build.gradle` 文件中的 `AROUTER_MODULE_NAME` 参数定义的模块名称.

```gradle
javaCompileOptions {
    annotationProcessorOptions {
        arguments = [AROUTER_MODULE_NAME: project.getName(), AROUTER_GENERATE_DOC: "enable"]
    }
}
```

支持生成路由文档, 通过 `AROUTER_GENERATE_DOC` 参数开启文档生成. 最终生成的文档是一个 JSON 格式的文件, 包含了所有模块的路由信息. 文档生成的路径是在 `build/generated/source/apt` 目录下. 文件名为 `arouter-map-of-模块名.json`. 详细怎么生成的本文不进行讲解.

###### AutowiredProcessor

`@Autowired` 注解用于标注目的对象内部的属性, 用于自动注入参数. 注意点如下:

- 仅支持为 Activity, Fragment 类型的目的对象内部注入基本数据类型、自定义对象、集合类型、IProvider 类型等.
- IProvider 类型的参数注入默认通过其实际类类型(直接实现)或其接口类型(间接实现)来获取实例, 也可以通过 `@Autowired` 注解的 `name` 属性来指定实例名称, 用于区分同一接口的不同实现.
- 参数注入需要 `SerializationService` 服务支持, 用于序列化和反序列化参数. 内部已经有一个默认实现了, 也可以通过实现 `SerializationService` 接口和添加 `@Route` 注解来自定义序列化服务.

`AutowiredProcessor` 是 `@Autowired` 的注解处理器, 其最终目的是为每个需要注入参数的类型生成一个帮助类, 用于自动注入参数.

参数注入的注解处理过程主要分为两个步骤:

- 第一步是扫描所有使用了 `@Autowired` 注解的元素, 并根据元素的上层结构分类存储到内存中.

  ```java
  // 获取所有使用了 @Autowired 注解的元素
  Map<TypeElement, List<Element>> parentAndChild; // 用于存储父元素和子元素的映射关系
  Set<? extends Element> autowiredElements = roundEnv.getElementsAnnotatedWith(Autowired.class);
  for (Element element : autowiredElements) {
      TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
      List<Element> elements = autowiredMap.get(enclosingElement);
      parentAndChild[enclosingElement].add(element);
  }
  ```

- 第二步是为每个需要注入参数的类型生成一个帮助类, 用于自动注入参数.

  ```java
  // 遍历所有需要注入参数的类型, 生成帮助类
  for (parentElement, childElements : parentAndChild) {
      MethodSpec.Builder injectMethodBuilder: PUBLIC Override inject(Object target) // 统一注入方法的构造器
  
      injectMethodBuilder.addStatement("serializationService = ARouter.getInstance().navigation(SerializationService.class)"); // 内置序列化服务实现.
      injectMethodBuilder.addStatement("$T t = ($T)target", ClassName.get(parent), ClassName.get(parent)); // 强制类型转换为目标类型.
  
      // 生成注入代码
      for (Element element : childElements) {
          Autowired fieldConfig = element.getAnnotation(Autowired.class);
          String fieldName = element.getSimpleName().toString();
          String name = autowired.name();
          boolean required = autowired.required();
          String desc = autowired.desc();
          // iProvider 类型的参数注入时可以选择是否指定实例名称来支持多实现注入. 因此需要额外处理.
          when element is iProvider : 
              if (name.isEmpty()) {
                  injectMethodBuilder.addStatement(
                      "substitute." + fieldName + " = ARouter.getInstance().navigation($T.class)",
                      ClassName.get(element.asType())
                  );
                  // 示例: substitute.testProvider = ARouter.getInstance().navigation(TestProvider.class);
              } else {
                  injectMethodBuilder.addStatement(
                      "substitute." + fieldName + " = ($T)ARouter.getInstance().build($S).navigation()",
                      ClassName.get(element.asType()),
                      fieldConfig.name()
                  );
                  // 示例: substitute.testProvider = (TestProvider)ARouter.getInstance().build("testProvider").navigation();
              }
              // 判断是否必须注入, 必须则需要添加非空判断代码
              if (fieldConfig.required()) {
                  injectMethodBuilder.beginControlFlow("if (substitute." + fieldName + " == null)");
                  injectMethodBuilder.addStatement(
                      "throw new RuntimeException(\"The field '" + fieldName + "' is null, in class '\" + $T.class.getName() + \"!\")", ClassName.get(parent));
                      injectMethodBuilder.endControlFlow();
              }
              // 示例: if (substitute.testProvider == null) throw new RuntimeException("The field 'testProvider' is null, in class 'com.xxx.TestActivity'!");   
          when other:
              // 其他类型的参数注入
              String statement = "substitute." + fieldName + " = (${ClassName.get(element.asType())})" + "substitute."; // 这里强制类型转换其实只有 Serializable 类型需要, 其他类型都是自动转换的.
              when parentElement is Activity:
                  statement += "getIntent().";
              when parentElement is Fragment:
                  statement += "getArguments().";
              
              // 然后根据参数类型生成不同的注入代码
              when element.asType() is BOOLEAN:
                  statement += "getBoolean" + (isActivity ? "Extra" : "") + "($S, " + "substitute." + fieldName + ")";
                  injectMethodBuilder.addStatement(statement, StringUtils.isEmpty(fieldConfig.name()) ? fieldName : fieldConfig.name());
                  // 示例: substitute.testBoolean = substitute.getIntent().getBooleanExtra("testBoolean", substitute.testBoolean);
                  // 示例: substitute.name = substitute.getIntent().getExtras() == null ? substitute.name : substitute.getIntent().getExtras().getString("name", substitute.name);
              ...
              when element.asType() is OBJECT:
                  statement = "serializationService.parseObject(substitute." + (isActivity ? "getIntent()." : "getArguments().") + (isActivity ? "getStringExtra($S)" : "getString($S)") + ", new " + ".TypeWrapper" + "<$T>(){}.getType())";
                  // 如果解析的是对象类型, 需要额外添加一个 TypeWrapper 类型, 用于获取对象的类型信息.
                  injectMethodBuilder.beginControlFlow("if (null != serializationService)");
                  injectMethodBuilder.addStatement(
                      "substitute." + fieldName + " = " + statement,
                      (StringUtils.isEmpty(fieldConfig.name()) ? fieldName : fieldConfig.name()),
                      ClassName.get(element.asType())
                  );
                  injectMethodBuilder.nextControlFlow("else");
                  injectMethodBuilder.addStatement(
                      "$T.e(\"" + Consts.TAG + "\", \"You want automatic inject the field '" + fieldName + "' in class '$T' , then you should implement 'SerializationService' to support object auto inject!\")", AndroidLog, ClassName.get(parent));
                  injectMethodBuilder.endControlFlow();
                  // 示例: substitute.obj = serializationService.parseObject(substitute.getIntent().getStringExtra("obj"), new TypeWrapper<TestObj>(){}.getType());
              // 判断是否必须注入, 必须则需要添加非空判断代码
              if (fieldConfig.required()) {
                  ...
              }
              
      // 生成注入帮助类代码, 包含注入参数的帮助方法和用于序列化和反序列化参数的服务实现.
      TypeSpec.Builder helper = TypeSpec.classBuilder(parent.getSimpleName() + "$$ARouter$$Autowired")
          .addSuperinterface(ClassName.get(ISyringe))
          .addModifiers(PUBLIC);
      FieldSpec jsonServiceField = FieldSpec.builder(TypeName.get(SerializationService.asType()), "serializationService", Modifier.PRIVATE).build();
      helper.addField(jsonServiceField);
      helper.addMethod(injectMethodBuilder.build());
      // 生成帮助类文件
      // packageName 与 parentElement 的包名相同
      avaFile.builder(packageName, helper.build()).build().writeTo(mFiler);
      }
  }
  ```

###### InterceptorProcessor

`@Interceptor` 注解用于标注拦截器信息. 注意点如下:

- 拦截器注解只支持标注实现了 `IInterceptor` 接口的类型.
- 拦截器的优先级用于标识拦截器的执行顺序, 数值越小优先级越高. 不能出现相同优先级的拦截器.

`InterceptorProcessor` 是 `@Interceptor` 的注解处理器, 其最终目的是生成一个拦截器表, 实际是一个类文件, 包含了所有拦截器信息的映射关系.

拦截器表的生成过程主要分为两个步骤:

- 第一步是扫描所有使用了 `@Interceptor` 注解的类, 并将其拦截器信息存储到内存中.
- 根据拦截器的优先级排序, 生成一个拦截器表, 包含了所有拦截器的映射关系.

大概生成的类文件如下:

```java
public class ARouter$$Interceptors$$ModuleName implements IInterceptorGroup {
    @Override
    public void loadInto(Map<Integer, Class<? extends IInterceptor>> interceptors) {
        interceptors.put(7, Test1Interceptor.class);
        interceptors.put(90, TestInterceptor90.class);
    }
}
```

###### RouteProcessor

`@Route` 注解用于位支持类标注其路由信息(如路径、组、名称、优先级、附加标志位). 注意点如下:

- 路由注解只支持标注类, 包括 Activity, Fragment, Service, IProvider 类型.
- 路由信息必须包含路径信息, 同时以 `/` 开头.
- 路由信息的组信息用于模块内分组加载路由信息, 不提供则要求路径至少包含两级, 采用第一级作为组名.
- Activity 和 Fragment 额外支持 `@Autowired` 注解实现自动注入目的对象内部的属性值. 因此处理时需要额外处理 `@Autowired` 注解.

`RouteProcessor` 是 `@Route` 的注解处理器, 其最终目的是生成一个路由表, 实际是多个类文件, 包含了所有路由信息的映射关系和参数信息.

路由表的生成需要分模块和分组处理, 也就是两级映射和加载关系. 分模块确保模块之间的解耦, 方便单独开发. 分组则是为了按需加载(延迟加载)路由信息, 节约资源.

- 每个模块内部都会生成两个根映射表, 名称是 `ARouter$$Root$$模块名` 和 `ARouter$$Providers$$模块名`, 其内部分别包含了所有路由组到组内映射表的映射关系, 以及所有路由路径到 IProvider 类型的映射关系.
- 每个组内部都会生成一个组内映射表, 名称是 `ARouter$$Group$$组名`, 其内部包含了所有路由路径到对应目标类类型的映射关系.

所有根映射表和组内映射表共同构成了一个完整的路由表. 在 app 内初始化 ARouter 时, 会依次加载所有模块的根映射表, 然后根据根映射表中的组名加载对应的组内映射表, 最终获取到所有的从路径到目标类信息的映射关系, 用于后续的路由跳转(基于反射机制创建目标类实例).

路由表的生成过程主要分为两个步骤:

- 第一步是扫描所有使用了 `@Route` 注解的类, 并将其路由信息存储到内存中.

    - `groupMap: Map<String, List<RouteMeta>>` 用于分组存储不同组和其内包含的路由信息. <组名, 组内路由信息列表>
    - `rootMap: Map<String, String>` 用于存储根路由信息, 用于生成类文件时的顺序. <组名, 组内映射表类名>
    - `process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv)` 方法, 用于处理注解.

        - `annotations` 包含了本轮处理器感兴趣的注解类型集合. 每个 TypeElement 代表一个注解类型, 通过此信息可以从 roundEnv 中查找对应的元素.
        - `roundEnv` 提供了当前编译轮次的上下文信息, 可以通过它查询使用了特定注解的类、方法、字段等元素.

  ```java
  // 获取所有使用了 @Route 注解的元素
  Set<? extends Element> routeElements = roundEnv.getElementsAnnotatedWith(Route.class);
  
  // 分组存储所有的路由信息
  for (element : routeElements) {
      TypeMirror elementType; // 获取元素的类型
      Route routeAnnotation; // 获取元素的注解
      RouteMeta routeMeta; // 创建元素对应的路由信息
  
      when elementType is Activity or Fragment:
          Map<String, Integer> paramsType; // 存储所有要注入的参数的类型
          Map<String, Autowired> injectConfig; // 存储所有要注入的参数的配置(如名称、是否必须, 描述)
          injectParamCollector(element, paramsType, injectConfig); // 递归收集所有要注入的参数信息, 分别存储在 paramsType 和 injectConfig 中.
  
          routeMeta = new RouteMeta(route, element, ACTIVITY or Fragment, paramsType, injectConfig);
      when other(iProvider, Service) as type:
          routeMeta = new RouteMeta(route, element, iProvider or Service);
  
      groupMap[routeMeta.group()].add(routeMeta); // 这里每组的 routeMeta 按路径顺序存储
  }
  ```

- 第二步是根据内存中的路由信息生成路由表(根映射表和组内映射表), 并写入到类文件中, 所有类文件统一组织到一个包路径下.

  ```java
  
  // 生成根映射表类文件包括两种: ARouter$$Root$$模块名
  MethodSpec.Builder loadIntoMethodOfProviderBuilder: PUBLIC Override loadInto(Map<String, RouteMeta> providers) // 用于加载 IProvider 类型的路由信息的 loadInto 方法构造器
  MethodSpec.Builder loadIntoMethodOfRootBuilder: PUBLIC Override loadInto(Map<String, Class<? extends IRouteGroup>> routes) // 用于加载组内映射表的 loadInto 方法构造器
  
  // 分组生成组内映射表
  for (groupName, routeMetas in groupMap):
      MethodSpec.Builder loadIntoMethodOfGroupBuilder: PUBLIC Override loadInto(Map<String, RouteMeta> atlas) // 组内映射表内部用于加载路由信息的 loadInto 方法构造器
      for (routeMeta in routeMetas):
          ClassName className = ClassName.get(routeMeta.getRawType()) // 获取元素类型的类名
          
          // 原项目额外对直接实现 IProvider 接口, 还是实现 IProvider 的子接口进行了区分
          // 这里的处理方式会导致子接口的实现类只能有一个, 难以理解为什么要这么做.
          when routeMeta.getType():
              implement iProvider: 
                  loadIntoMethodOfProviderBuilder.addStatement(
                      "providers.put($S, $T.build($T." + routeMeta.getType() + ", $T.class, $S, $S, null, " + routeMeta.getPriority() + ", " + routeMeta.getExtra() + "))",
                      (routeMeta.getRawType()).toString(),
                      RouteMeta.class,
                      RouteType.class,
                      className,
                      routeMeta.getPath(),
                      routeMeta.getGroup());
              implement subInterface of iProvider:
                  loadIntoMethodOfProviderBuilder.addStatement(
                      ... // 同上
                      subInterface.toString(),
                      ... // 同上
                  );
                  // 示例: providers.put("com.alibaba.android.arouter.demo.testservice.HelloService", RouteMeta.build(RouteType.PROVIDER, HelloService.class, "/service/hello", "service", null, -1, -2147483648));
          
          // 生成支持自动注入的参数类型映射表: Map<String, TypeKind>
          Map<String, Integer> paramsType = routeMeta.getParamsType();
          String paramsTypeMapBody = ""
          for (name, type in paramsType):
              paramsTypeMapBody += "put(\"" + name + "\", " + type + "); "
              // 示例: put("name", 8); put("age", 3);
          
          loadIntoMethodOfGroupBuilder.addStatement(
              "atlas.put($S, $T.build($T." + routeMeta.getType() + ", $T.class, $S, $S, " + (StringUtils.isEmpty(paramsTypeMapBody) ? null : ("new java.util.HashMap<String, Integer>(){{" + paramsTypeMapBody + "}}")) + ", " + routeMeta.getPriority() + ", " + routeMeta.getExtra() + "))",
              routeMeta.getPath(),
              RouteMeta.class,
              RouteType.class,
              className,
              routeMeta.getPath().toLowerCase(),
              routeMeta.getGroup().toLowerCase());
          // 示例: atlas.put("/kotlin/test", RouteMeta.build(RouteType.ACTIVITY, KotlinTestActivity.class, "/kotlin/test", "kotlin", new java.util.HashMap<String, Integer>(){{put("name", 8); put("age", 3); }}, -1, -2147483648));
  
      // 生成最终的组内映射表类文件
      String groupFileName = "ARouter$$Group$$" + groupName;
      JavaFile.builder("com.alibaba.android.arouter.routes", 
          TypeSpec.classBuilder(groupFileName)
              .addSuperinterface(ClassName.get(IRouteGroup.class))
              .addModifiers(Modifier.PUBLIC)
              .addMethod(loadIntoMethodOfGroupBuilder.build())
              .build()
          )
          .build()
          .writeTo(filer);
      // 示例: 
      // package com.alibaba.android.arouter.routes;
      // public class ARouter$$Group$$kotlin implements IRouteGroup {
      //      @Overridepublic void loadInto(Map<String, RouteMeta> atlas) { ... }
      // }
  
      // 缓存根映射表信息
      rootMap.put(groupName, groupFileName);
  
  // 生成根映射表类文件
  for (groupName, groupFileName in rootMap):
      loadIntoMethodOfRootBuilder.addStatement("routes.put($S, $T.class)", entry.getKey(), ClassName.get("com.alibaba.android.arouter.routes", entry.getValue()));
  
  // Provider 的根映射表类文件
  JavaFile.builder("com.alibaba.android.arouter.routes",
      TypeSpec.classBuilder("ARouter$$Providers$$" + moduleName)
          .addSuperinterface(ClassName.get(IProviderGroup.class))
          .addModifiers(Modifier.PUBLIC)
          .addMethod(loadIntoMethodOfProviderBuilder.build())
          .build()
      )
      .build()
      .writeTo(filer);
  
  // Root 的根映射表类文件
  JavaFile.builder("com.alibaba.android.arouter.routes",
      TypeSpec.classBuilder("ARouter$$Root$$" + moduleName)
          .addSuperinterface(ClassName.get(IRouteRoot.class))
          .addModifiers(Modifier.PUBLIC)
          .addMethod(loadIntoMethodOfRootBuilder.build())
          .build()
      )
      .build()
      .writeTo(filer);
                  
  ```

##### arouter-api

ARouter 框架对外暴露的核心类, 用于提供路由表的加载和路由跳转功能. 主要包含以下几个部分(按照包含顺序):

- `ARouter` 类: 单例类, 提供对外暴露给使用者的 API 接口
    - `_ARouter` 类: 单例类, `ARouter` 类中所有接口的代理功能实现类.
        - `LogisticsCenter` 类: 路由表的中心类, 用于加载路由表, 并提供路由跳转的方法.

`ARouter` 对外主要暴露了以下几个主要功能(按照可调用顺序):

- `init` 方法: 线程安全, 初始化 ARouter 框架, 加载路由表(实际加载由 `LogisticsCenter` 执行)
    - `getInstance` 方法: 双检锁获取 ARouter 单例对象实例.
        - `build` 方法: 构造路由请求信息载体类, 用于后续的页面跳转或服务调用, 支持通过 path 和 Uri 进行构建.
            - build 过程支持首先通过注册的 `PathReplaceService` 类型服务对 `path` 或 `Uri` 进行预处理. 默认无此实现.
            - 最终返回一个 `Postcard` 对象, 其内部包含了当前路由请求的所有信息.
            - 后续可以继续通过 `Postcard` 对象进行其他路由参数的设置, 如???.
        - `navigation(service) -> T` 方法: 不需要 path, 直接通过继承自 IProvider 的接口类型获取对应的实现类.
            - 首先通过 `LogisticsCenter` 根据接口类型的名称, 通过`buildProvider` 和 `completion` 内部构造一个 `Postcard` 对象, 包含完整的路由信息.
            - 然后通过 `Postcard` 对象调用 `getProvider` 方法获取对应的实现类.
        - `navigation(context, postcard, requestCode, callback) -> Object` 方法: 通过构造的 Postcard 对象进行跳转.
            - 第一步支持使用注册的预处理服务 `PretreatmentService` 确认是否需要跳转.
            - 第二步通过 `LogisticsCenter` 的 `completion` 方法完成路由路径的加载. 这里支持加载失败时通过注册的 `DegradeService` 降级服务进行降级处理.
            - 第三步通过 `InterceptorService` 服务执行所有的拦截器, 并在拦截器执行完成后执行路由跳转.
                - `ACTIVITY` 类型的路由跳转通过 `startActivity` 方法进行跳转, 支持结果回调, 转场动画, 额外参数等.
                - `PROVIDER` 类型的路由跳转可以直接获取对应的实现类.
                - `BOARDCAST|CONTENT_PROVIDER|FRAGMENT` 类型的路由跳转直接返回实际对象, FRAGMENT会注入额外的参数.
                - `METHOD|SERVICE` 类型的路由不支持, 直接返回 null.
        - `addRouteGroup` 方法: 动态添加路由组信息, 一般用于按需加载插件时使用.
        - `inject` 方法: 通常在需要注入参数的对象中调用, 实现为当前对象自动注入参数.
            - 方法通过固定 `path` 获取 `AutowiredService` 接口的实现类.
            - 基础实现见 `AutowiredServiceImpl` 类, 此类通过利用自动生成的注入帮助类(见 `@Autowired` 注解处理过程)实现自动注入参数.
            - 注入过程是递归的, 会递归注入目的对象及其父类的可支持注入的所有属性.
            - 注入参数来自于路由 `Postcard` 对象通过 `with` 或 `withXxx` 方法设置的参数.

`LogisticsCenter` 类主要提供了以下几个功能:

- `init` 方法: 加载所有本地路由表到内存中.
    - 加载原理 1: 运行时通过 DexFile 加载 dex 文件中的所有类名, 并通过反射加载路由表.
        - 首先通过 apk 文件, 以及 Android5.0 以下 secondary-dexes 文件夹下所有的额外的 dex 文件压缩包文件去获取 dex 文件的路径.
        - 然后通过 DexFile 类加载 dex 文件, 获取 dex 文件中所有的类名, 并过滤掉不符合要求的类名, 即不包含指定包名的类名. (java最终生成类文件的类名是包名 + 代码类名)
        - 缓存所有的类名, 用于后续的路由表通过缓存加速加载.
        - 遍历所有的类名, 分种类(`IRouteRoot`, `IInterceptorGroup`, `IProviderGroup`)的通过反射构造对应类对象, 并调用其 `loadInto` 方法加载路由表到 Warehouse 的全局静态变量中(即内存中的路由表). 注意此时加载的仅是根映射表, 服务提供者, 拦截器提供者的类信息映射关系. 完整的加载会在后续的路由跳转时按需进行.
    - 加载原理 2: 编译时通过 `arouter-auto-register` 插件生成的 `loadRouterMap` 方法加载路由表.
- `buildProvider` 方法: 根据接口类型的全名或小名获取对应的实现类.
    - 首先通过接口类型的名称从内存中的路由表中获取对应的 `RouteMeta` 对象.
    - 然后通过 `RouteMeta` 对象存有的目标类类型信息构造 `Postcard` 对象.
- `completion` 方法: 通过 `Postcard` 对象完成整体路由路径上的所有信息的加载.
    - 首先通过 `Postcard` 对象获取路由路径所在组, 并通过组名加载对应的组内映射表.
    - 然后通过组内映射表获取对应的目标的 `RouteMeta` 对象, 利用其存储的路由信息和目标类类型信息继续完善 `Postcard` 对象. 注意, 这里包含 uri 中 Query 参数的解析(仅支持可注入参数)和 provider 的构建.

`Postcard` 类: 路由请求的载体类, 扩展了 `RouteMeta`, 用于进一步封装路由请求的所有信息.

- 参数 (`ARouter` 的 `build` 路由请求构造过程可选手动设置的参数):
    - `path: String`: 路由跳转路径, 一般为 `@Route` 注解中的 `path` 属性或 `Uri` 对象的 `path` 属性.
    - `group: String`: 路由路径所在组, 一般为默认组(路径第一个 `/` 后的字符串, 没有则分组为 null).
    - `uri: Uri`: 路由跳转的 Uri, 一般用于深度链接跳转内部页面, 其 `path` 属性为路由跳转路径, 其他属性待定.
    - `mBundle: Bundle`: 路由跳转时要传递给目标对象的参数, 可以通过 `with` 或 `withXxx` 方法设置参数.
    - `timeout: Long`: 路由跳转超时时间, 默认用于控制设置的拦截器执行的超时时间.
    - `greenChannel: Boolean`: 是否使用绿色通道, 用于跳过拦截器.
    - `flags: Int`: 用于控制 Activity 类型路由请求的行为标志位, 如 `FLAG_ACTIVITY_NEW_TASK` 等.
    - `enterAnim: Int | exitAnim: Int`: 用于控制 Activity 类型路由请求的进入和退出动画效果.
    - `optionsCompat: ActivityOptionsCompat`: 用于控制 Activity 类型路由请求的转场动画效果, 仅在 Android 5.0 以上有效.
    - `action: String`: 用于控制 Activity 类型路由请求的行为, 如 `Intent.ACTION_VIEW` 等.
- 参数(`ARouter` 的 `navigation` 过程自动设置的参数):
    - `type: RouteType`: 路由类型.
    - `rawType: Element`: 路由目标类原始信息
    - `destination: Class<?>`: 路由目标类具体
    - `priority: int`: 路由优先级.
    - `extra: int`: 路由附加信息.
    - `paramsType: Map<String, Integer>`: 路由注入的所有参数类型.
    - `name: String`: 路由名称.
    - `injectConfig: Map<String, Autowired>`: 路由注入的所有参数配置.
    - `provider: IProvider`: 存储 IProvider 类型的实现类, 会由 `LogisticsCenter` 自动加载.
    - `serializationService: SerializationService`: 序列化服务, 用于序列化和反序列化参数.
    - `context: Context`: 路由请求的上下文.
- `navigation(__)` 类型方法, 用于发起由 `path` 或 `Uri` 构造的路由请求, 支持返回对象实例和回调等.
    - 实际路由跳转过程主要是通过 `ARouter` 的 `navigation(context, ...)` 方法实现.

##### arouter-gradle-plugin

#### 额外补充

工作流程:

1. 编码时期, 通过 `arouter-annotation` 提供的注解来标记需要路由的页面或服务.
2. 编译时期, 通过 `arouter-compiler` 注解处理器对特定的注解来做一些逻辑处理和自动生成文件, 如 ARouter$$Root$$xxx, ARouter$$Providers$$xxx 和 ARouter$$Group$$xxx.
    - groupMap: HashMap 用来存放分组信息, key 为组名, value 为组内的所有路由信息(RouteMeta), 不可重复路径.
    - rootMap: 用来存放所有路由组信息, key 为组名, value 为每组生成的 ARouter$$Group$$xxx 类文件.
    - RouteProcessor -> process -> parseRoutes
        - 将 @Route 修饰的类信息封装进 RouteMeta 中. 再把 RouteMeta 按照组名分好组存进 groupMap 中.
        - 遍历每个组内的所有路由信息
            - 其他路由类型: 生成 ARouter$$Group$$groupName 类文件, 内部函数 `loadInto` 用来加载路由信息.
                - `atlas.put("/test/main", RouteMeta.build(RouteType.ACTIVITY, MainActivity.class, "/test/main", "test", null, -1, -2147483648));`
                - atlas<String, RouteMeta>
            - `iProvider` 路由类型: 会生成 ARouter$$Providers$$moduleName 类文件, 内部函数 `loadInto` 用来加载路由信息.
                - 直接的 `IProvider` 类型: `providers.put("com.example.MyService", RouteMeta.build(RouteType.PROVIDER, MyService.class, "/service/my", "service", null, 10, 0));`
                - `IProvider` 的子类: `providers.put("com.example.IMyProvider", RouteMeta.build(RouteType.PROVIDER, MyService.class, "/service/my", "service", null, 10, 0));`
                - providers<String, RouteMeta>
        - 遍历所有组, 生成 ARouter$$Root$$moduleName 类文件, 内部函数 `loadInto` 用来加载路由信息.
            - `routes.put("test", "ARouter$$Group$$test");`
            - routes<String, IRouteGroup>
3. 运行时初始化, 通过 `ARouter.init()` 来初始化 ARouter, 会调用 `ARouter$$Root$$xxx` 类文件中的 `loadInto` 函数来加载路由信息到内存中, 存储在 `Warehouse` 中.
   - ARouter.init() -> LogisticsCenter -> loadRouterMap -> Warehouse
       - Warehouse
           - groupsIndex<String, IRouteGroup>: 缓存所有组实例, key 为组名, value 为 IRouteGroup 实例.
           - routes<String, RouteMeta>: 缓存所有路由信息, key 为路由路径, value 为路由信息.
           - providers<Class, IProvider>: 缓存所有 IProvider 实例, key 为 IProvider 的实现类, value 为 IProvider 实例.
           - providersIndex<String, RouteMeta>: 缓存所有 IProvider 路由信息, key 为路径, value 为 RouteMeta 实例.
           - interceptors[IInterceptor]: 缓存所有拦截器实例.
           - interceptorsIndex<Integer, IInterceptor>: 缓存所有拦截器信息, key 为优先级, value 为 IInterceptor 实例.
4. 路由跳转, 通过 `ARouter.getInstance().build(path).navigation()` 来跳转到指定的页面或获取指定服务.
   - 示例 path: "/test/main"
   - ARouter.getInstance().build(path).navigation()
       - ARouter -> build(path) -> build(path, group, afterReplace) -> new Postcard(path, group, uri, bundle)
       - -> ARouter -> navigation(context, postcard, requestCode, callback) ->
       - LogisticsCenter -> completion(postcard) ->
       -

- RouteMeta 里面存放了路由信息, 包括路径、类名、类型等.
    - type: 路由类型, 分为 Activity, Fragment, Service, IProvider 等.
    - rawType: 被 @Route 注解的元素类型信息, 通常是 TypeElement 类型, 如"com.test.MainActivity".
    - destination(Class<?>): 被 @Route 注解的元素类型信息, 通常是 Class 类型, 如 MainActivity.class.
    - name: 路由的名称, 用于生成路由的注释.
    - path: 路由路径, 如 "/test/main".
    - group: 路由组名, 如 "test". 如果不设置组名, 则默认使用 path 的第一段作为组名
    - paramsType: 页面路由时, 用于注入参数的所有参数名和及其类型对应关系.
    - priority: 拦截器中的优先级, 值越小, 优先级就越高.
    - extra: 额外信息, 路由文档 RouteDoc 的标志.
    - inJectConfig: 页面路由时, 用于注入参数的所有参数名和及其配置信息的对应关系.
    - `providers.put()`;
    - `atlas.put();`

Postcard 用于存储路由信息, 参数与 RouteMeta 类似, 但是多了一些额外的参数和方法, 如 uri, bundle, provider, greenChannel 等. provider 仅在 IProvider 类型的路由中存储直接的 IProvider 实例. greenChannel 用于标记是否是绿色通道, 即不需要拦截器拦截的路由.

![alt text](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/804bb91f508e4c3baf7798ef48cfd966~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

### DRouter 解析

工作流程:

1. 编码时期
   - `@Router(scheme = "didi", host = "router", path = "/login")` 用于标记需要路由的页面或服务.
     - App 内跳转, 可以只用 path, 如 `@Router(path = "/activity/test1")`.
     - `scheme` 用于标记路由的协议, 如 "http", "https", "didi" 等.
     - `host` 用于标记路由的主机名, 如 "www.didi.com", "router" 等.
     - `path` 用于标记路由的路径, 如 "/activity/test1", "/service/test1" 等.
     - `uri` 用于标记路由的完整路径, 如 "didi://router/activity/test1", `https://www.didi.com/activity/test1` 等, 存在时会覆盖 scheme, host 和 path.
2. 编译时期, 通过 `drouter-plugin` 插件来生成路由信息, 支持增量编译和多线程编译.
    - `RouterSetting` 配置 debug(调试模式), incremental(增量编译), cache(缓存), useActivityRouterClass(使用 ActivityRouter 类), supportNoAnnotationActivity(支持无注解 Activity), pluginName(插件名称).
    - `RouterTransform` 用于通过 ASM 字节码插桩来处理编译时期的逻辑, 如解析注解, 生成路由信息, 生成 ActivityRouter 类, 生成路由表等.
        - 部分变量功能
            - `tmpDir = "intermediates/drouter"` 用于存放生成的文件, 如路由表, ActivityRouter 类等.
            - `cachePathSet` 用于存放缓存文件的路径, 用于增量编译. windows 不支持本地缓存.
            - `isWindow` 用于判断当前系统是否是 Windows 系统.
            - `invocation` 提供了所有的输入和输出信息
    !ASM 字节码处理的接口已经被弃用. 直接看最终生成的文件实例, 包括 `RouterLoader`, `InterceptorLoader`, `ServiceLoader`.

    ```java
    public class RouterLoader extends MetaLoader {
        @Override
        public void load(Map var1) {
            var1.put("@@$$/activity/dynamic", RouterMeta.build(RouterMeta.ACTIVITY).assembleRouter("", "", "/activity/dynamic", "com.didi.demo.handler.DynamicActivity", (IRouterProxy)null, (Class[])null, (String[])null, 0, 0, false));
            var1.put("@@$$/activity/remote", RouterMeta.build(RouterMeta.ACTIVITY).assembleRouter("", "", "/activity/remote", "com.didi.demo.remote.RemoteActivity", (IRouterProxy)null, (Class[])null, (String[])null, 0, 0, false));
            var1.put("@@$$/activity/result", RouterMeta.build(RouterMeta.ACTIVITY).assembleRouter("", "", "/activity/result", "com.didi.demo.activity.ActivityResultActivity", (IRouterProxy)null, (Class[])null, (String[])null, 0, 0, false));
            var1.put("@@$$/activity/router_page_single", RouterMeta.build(RouterMeta.ACTIVITY).assembleRouter("", "", "/activity/router_page_single", "com.didi.demo.fragment.RouterPageSingleActivity", (IRouterProxy)null, (Class[])null, (String[])null, 0, 0, false));
            var1.put("@@$$/activity/router_page_stack", RouterMeta.build(RouterMeta.ACTIVITY).assembleRouter("", "", "/activity/router_page_stack", "com.didi.demo.fragment.RouterPageStackActivity", (IRouterProxy)null, (Class[])null, (String[])null, 0, 0, false));
            var1.put("@@$$/activity/router_page_viewpager", RouterMeta.build(RouterMeta.ACTIVITY).assembleRouter("", "", "/activity/router_page_viewpager", "com.didi.demo.fragment.RouterPageViewPagerActivity", (IRouterProxy)null, (Class[])null, (String[])null, 0, 0, false));
            var1.put("@@$$/activity/test3", RouterMeta.build(RouterMeta.ACTIVITY).assembleRouter("", "", "/activity/test3", "com.didi.demo.activity.ActivityTest3", (IRouterProxy)null, (Class[])null, (String[])null, 0, 0, true));
            var1.put("@@$$/activity/webview", RouterMeta.build(RouterMeta.ACTIVITY).assembleRouter("", "", "/activity/webview", "com.didi.demo.web.WebActivity", (IRouterProxy)null, (Class[])null, (String[])null, 0, 0, false));
            var1.put("@@$$/fragment/second", RouterMeta.build(RouterMeta.FRAGMENT).assembleRouter("", "", "/fragment/second", FragmentSecond.class, new com_didi_demo_fragment_FragmentSecond(), (Class[])null, (String[])null, 0, 0, false));
            var1.put("@@$$/handler/test1", RouterMeta.build(RouterMeta.HANDLER).assembleRouter("", "", "/handler/test1", HandlerTest1.class, new com_didi_demo_handler_HandlerTest1(), (Class[])null, (String[])null, 0, 1, false));
            var1.put("@@$$/handler/test3", RouterMeta.build(RouterMeta.HANDLER).assembleRouter("", "", "/handler/test3", HandlerTest3.class, new com_didi_demo_handler_HandlerTest3(), (Class[])null, (String[])null, 2, 0, true));
            var1.put("@@$$/view/bottom", RouterMeta.build(RouterMeta.VIEW).assembleRouter("", "", "/view/bottom", BottomView.class, new com_didi_demo_view_BottomView(), (Class[])null, (String[])null, 0, 0, false));
            var1.put("@@$$/view/headview", RouterMeta.build(RouterMeta.VIEW).assembleRouter("", "", "/view/headview", HeadView.class, new com_didi_demo_view_HeadView(), (Class[])null, (String[])null, 0, 0, false));
            var1.put("didi@@router$$/handler/test2", RouterMeta.build(RouterMeta.HANDLER).assembleRouter("didi", "router", "/handler/test2", HandlerTest2.class, new com_didi_demo_handler_HandlerTest2(), (Class[])null, (String[])null, 0, 0, false));
            this.put("@@$$/activity/Test1_<Arg1>_<Arg2>", RouterMeta.build(RouterMeta.ACTIVITY).assembleRouter("", "", "/activity/Test1_<Arg1>_<Arg2>", "com.didi.demo.activity.ActivityTest1", (IRouterProxy)null, new Class[]{InnerInterceptor.class}, new String[]{"interceptor1", "interceptor2"}, 0, 0, false), var1);
            this.put("@@$$/fragment/first/.*", RouterMeta.build(RouterMeta.FRAGMENT).assembleRouter("", "", "/fragment/first/.*", FragmentFirst.class, new com_didi_demo_fragment_FragmentFirst(), (Class[])null, (String[])null, 0, 0, false), var1);
            this.put("@@$$/handler/.*", RouterMeta.build(RouterMeta.HANDLER).assembleRouter("", "", "/handler/.*", HandlerAll.class, new com_didi_demo_handler_HandlerAll(), (Class[])null, (String[])null, 0, 2, false), var1);
            this.put("didi@@www\\.didi\\.com$$/activity/test2", RouterMeta.build(RouterMeta.ACTIVITY).assembleRouter("didi", "www\\.didi\\.com", "/activity/test2", "com.didi.demo.activity.ActivityTest2", (IRouterProxy)null, (Class[])null, (String[])null, 0, 0, false), var1);
        }

        public RouterLoader() {
        }
    }
    ```

3. 运行时初始化, 通过 `RouterStore` 来加载路由信息到内存中.
   - `DRouter.init(application);`
   - `RouterStore.checkAndLoad("plugin_sample", false)`
   - `RouterStore` -> `checkAndLoad` -> `load`
   - `loadHostTable` 从本地直接构造生成的 RouterLoader, InterceptorLoader 和 ServiceLoader 加载路由表到内存中的 routerMetas, interceptorMetas 和 serviceMetas 中.
   - `loadPluginTable` 从插件内生成的 RouterLoader, InterceptorLoader 和 ServiceLoader 加载路由表到内存中的 routerMetas, interceptorMetas 和 serviceMetas 中. 这里只支持滴滴内部的插件, 外部插件需要自己修改.
4. 路由跳转, 通过 `DRouter` 来跳转到指定的页面或获取指定服务.
   - `DRouter.build(uri).start(context, callback);`
       - `RouterLoader.build(this, callback).start();` -> `RouterDispatcher.start(equest, routerMeta)`
           - `startActivity(request, meta, result, callback);`
           - `startFragment(request, meta, result);`
           - `startView(request, meta, result);`
           - `startHandler(request, meta, result, callback);`
   - `DRouter.build(function).getService();`
       - ServiceLoader.build(function).getService();

`RouterStore` 用于存储路由信息, 包括路由表, 拦截器表, 服务表等. 通过 `checkAndLoad` 来加载路由信息到内存中, 通过 `loadHostTable` 来加载本地生成的路由表, 通过 `loadPluginTable` 来加载插件生成的路由表.

- `routerMetas<String, Object>`: 存储路由表信息, key 为路由路径, value 为路由信息.
- `interceptorMetas<Object, RouterMeta>`: 存储拦截器表信息, key 为拦截器优先级, value 为拦截器信息.
- `serviceMetas<Class<?>, Set<RouterMeta>>`: 存储服务表信息, key 为服务类型, value 为服务信息.

`RouterMeta` 用于存储路由信息, 包括路由类型, 路由类, 路由代理, 优先级, 是否是动态路由, 协议, 主机, 路径, 是否有占位符, Activity 名称, 拦截器, 线程, 是否持有, Intent, 动态处理器, 服务别名, 特征匹配器, 动态服务, 是否是全局拦截器, 缓存等信息.

## 插件化框架

插件化框架的核心目标是在原有 app 的基础上, 实现动态加载一个或多个插件(独立 apk 或 jar 文件), 并在 app 中使用插件中的功能和资源. 独立出来的插件可以单独进行开发, 测试, 发布, 升级等流程, 从而实现一些比较重要的功能, 如模块化开发, 动态更新, 热修复, 功能扩展等功能.

因为涉及到 app 和插件之间的交互, 所以插件化框架的实现一般需要解决以下几个问题(不同的插件化框架可能会有不同的实现方式):

- 插件代码加载
- 系统组件注册
- 资源加载
- 插件和宿主, 以及插件和插件之间的通信

### RePlugin 解析

360 开源的一个 Android 插件化框架.

#### 设计理念

- 插件代码加载: 通过类加载器 `ClassLoader` 实现插件的加载和卸载.
- 系统组件注册: 通过坑位组件实现插件中的组件(如 Activity)的注册.
- 资源加载: (TODO)

#### 使用介绍

#### 源码解析

RePlugin 包含编译时和运行时两部分, 同时又区分了宿主和插件两种不同的角色. 编译时宿主会通过 `replugin-host-gradle` 插件自动生成插件化框架所需的配置文件, 插件信息, 辅助类文件等. 运行时宿主会通过 `replugin-host-lib` 模块加载插件, 并实现插件的加载, 卸载, 组件注册, 资源加载等操作.

##### 前置知识

> [!cite]
> ![[Gradle#Gradle 插件开发|Gradle 插件开发]]
> Android Binder 通信机制
> Android ClassLoader 原理
> Android 四大组件启动流程

##### replugin-host-gradle (宿主插件)

##### replugin-host-lib (宿主库)

##### replugin-plugin-gradle (插件插件)

##### replugin-plugin-lib (插件库)

### Shadow 解析

Shadow 是腾讯开源的 Android 插件化框架.

#### 框架结构及设计理念

插件代码加载:
- 使用自定义的 DexClassLoader 加载插件 APK 中的普通类. 只有在加载 Activity 容器时, 通过反射插入 DexClassLoader 到宿主的 PathClassLoader 前面, 实现 BootClassLoader <- DexClassLoader <- PathClassLoader 逻辑, 使得系统在向 PathClassLoader 查找 ContainerActivity 时能够正确找到实现.
- 插件框架的代码本身也是插件的一部分, 可以随插件一起更新, 避免了宿主代码更新困难的问题.
- 通过ClassLoader的隔离机制确保插件之间的代码不会相互干扰

系统组件注册:
- 宿主预注册壳子代理组件: 在宿主的 AndroidManifest.xml 中预先注册一系列壳子代理组件(Activity、Service等).
- 框架内部维护插件组件与宿主壳子代理组件的映射关系, 当插件想要启动组件时, Shadow 会将插件组件 Intent 转换为对应的宿主壳子代理组件 Intent, 从而实现对系统服务的调用.
- 委托机制: 使用 HostActivityDelegate 和 ShadowActivityDelegate 等委托类, 实现壳子代理组件与插件组件之间的方法调用转发.

资源加载:
- 双方案适配：根据Android系统版本采用不同的资源加载策略:
    - 在API 26及以下版本：使用 MixResources 方案, 将宿主资源和插件资源混合在一起, 先尝试从插件 Resources 获取，失败则从宿主 Resources 获取
    - 在API 27及以上版本：通过 ApplicationInfo.sharedLibraryFiles 将插件 APK 添加到 Resources 对象中. 插件和宿主之间资源互相访问还是需要接口层来实现.
- 资源ID冲突解决: 通过资源 ID 分区, 确保插件和宿主的资源ID不会冲突. 宿主使用 0x7f 分区, 插件使用0x80或更大的分区.
- WebView 资源处理: 
    - 因为 WebView 在初始化时会向系统构造的 Resources 对象注入 webview.apk, 以便 WebView 可以使用自己的资源. 但它不会向插件构造的 Resources 对象自动注入这些资源.
    - Shadow 框架会在在创建插件 Resources 时, 尝试创建 Webview 触发对应的初始化流程, 然后通过复制宿主的 sharedLibraryFiles, 将包含 webview.apk 的资源路径传递给插件 Resources.

插件和宿主，以及插件和插件之间的通信:
- 直接或接口调用: 插件可以直接使用宿主中的类和方法, 但是要求宿主将需要暴露给插件的接口打包成独立的共享库, 供插件使用.
- 广播通信: 通过 Android 的广播机制实现宿主和插件之间的通信
- ContentProvider通信: Shadow 预注册了 PluginContainerContentProvider, 用于跨进程通信.

插件管理机制(补充):
- 插件包结构约定: 
    - zip 包格式, 包含插件管理器 APK, 插件运行时环境处理插件 APK, 业务插件加载插件 APK, 业务插件 APK 和相关配置文件. 所有插件都是可更新的, 更新时只需要更新插件 zip 包. 
    - 配置文件会通过 gradle 插件自动生成, 包含当前插件包的
        - version: 插件包的版本号, 用于版本控制和更新.
        - compact_version: 插件包的兼容版本号, 用于旧 App 加载新插件包的兼容性支持.
        - UUID: 插件包的唯一标识符, 用于标识插件包的唯一性, 升级时必须更改.
        - UUID_NickName: 插件包的版本昵称, 用于辅助识别插件版本 (如"v1.0.3-beta").
        - pluginLoader: 处理业务插件加载的插件的插件信息 (包括路径和 hash), 主要负责加载插件类.
        - runtime: 处理业务插件运行时环境处理的插件的插件信息, 用于支持插件的生命周期管理等运行时操作.
        - plugins: 插件包内的所有业务插件信息的列表.
- 业务插件约定:
    - 所有业务插件在某个插件的 build.gradle 文件中声明注册, 最终经由 gradle 插件自动识别对应的插件构建任务, 将插件及其插件信息自动打包到插件包中.
    - 每个插件有固定的结构约定:
        - `businessName`: 插件所代表的业务模块名称, 通常用于业务层标识.
        - `partKey`: 插件的唯一标识符, 用于标识插件的唯一性.
        - `hostWhiteList`: 表示此插件可访问的宿主内部的包名白名单, 非白名单的包名内部的类和方法将无法被插件访问.
        - `dependsOn`: 表示插件所依赖的其他插件模块, 如业务插件通常依赖基础模块.
        - `buildTask`: 插件的构建任务名称, 编译时自动打包当前插件的 apk 包时使用. 不注入插件配置信息.
        - `apkPath`: `buildTask` 任务执行后, 插件 APK 的生成路径, 用于编译后打包插件到插件包中. 不注入插件配置信息.
        - `hash`: 插件 apk 文件的哈希值, 用于校验插件的完整性和一致性. 自动生成, 不需要手动设置.

> [!info]
> 壳子代理: 用于代替插件内真正的页面、服务、广播接收器等组件的空壳占位类. 系统启动插件的对应组件时, 先访问壳子代理组件, 然后通过 runtime 访问插件内的真正组件.


#### 使用介绍

基于 Shadow 框架的应用项目由几部分组成:

- 宿主应用(host, 唯一, 必须): 打包了通用接口, 注册了壳子代理组件, 打包插件管理器(manager)的动态升级逻辑.
- 插件管理器应用(manager, 唯一, 必须): 负责下载、安装插件, 同时带有一个动态的 View 表达 Loading 态.
- 插件加载器应用(plugin->loader, 多个, 必须): 负责加载插件, 定义插件组件和壳子代理组件的配对关系.
- 插件运行时应用(plugin->runtime, 待定, 必须): 负责插件的运行时逻辑, 定义壳子代理组件(Activity/Service/BroadcastReceiver的占位组件)的实际类.
- 插件业务应用(plugin->business_plugin, 多个, 必须): 可以安装的业务插件.

一般的项目结构

```text
├── projects
│   ├── host // 宿主
│   ├── host-lib // 宿主库
│   ├── contract // 宿主和插件之间的契约
│   ├── constant // 宿主, manager 和 loader 间共用的常量
│   ├── manager // 插件管理器
│   ├── plugin // 插件
│   │   ├── loader // 插件加载器
│   │   ├── runtime // 插件运行时
│   │   ├── business_lib // 业务依赖库, 包含完整业务代码
│   │   ├── business_app // 业务 app, 基于 business_lib, 可以直接打包和运行的业务 app
│   │   ├── business_plugin // 业务插件, 基于 business_lib, 仅包含业务代码和插件框架代码, 不能直接打包和运行的业务插件
```

##### 编译 sdk

##### 宿主(host)编写流程

1. 依赖配置

    在 build.gradle 中添加以下依赖和配置:

    ```gradle
   android {
        // 配置资源目录, 用于构建过程中把自动生成的插件管理器 APK 和插件 ZIP 包 添加到宿主 App 的 assets 资源目录
        sourceSets {
            debug {
                // Debug版本的资源目录
                assets.srcDir('build/generated/assets/sample-manager/debug/')
                assets.srcDir('build/generated/assets/plugin-zip/debug/')
            }
            release {
                // Release版本的资源目录
                assets.srcDir('build/generated/assets/sample-manager/release/')
                assets.srcDir('build/generated/assets/plugin-zip/release/')
            }
        }
   }
    dependencies {
        implementation 'com.tencent.shadow.core:common'
        implementation 'com.tencent.shadow.dynamic:dynamic-host'
    }
    ```

2. `AndroidManifest.xml` 配置

    - 自定义和注册 `PluginLoadActivityXxx`, 用于承接插件加载逻辑.
    - 自定义和注册 `PluginProcessServiceXxx` 类型的插件进程服务, 用于管理插件加载过程, 每个插件进程都需要注册一个.
    - 自定义和注册 `PluginXxxProxyActivity`, 为插件内业务 Activity 进行系统事件转发和处理, 可以有多个, 每个是不同的启动模式. 编写时注意因为没依赖 runtime 库标红没事, 宿主可以正常实现对应类加载
    - 自定义和注册 `MainProcessManagerReceiver` 接收器, 用于接收插件进程加载相关的的广播消息.
    - 注册 `PluginContainerContentProvider` 用于跨进程通信.

    ```xml
    <activity
        android:name=".PluginLoadActivityXxx"
        android:launchMode="standard"
        android:screenOrientation="portrait" />

    <service
        android:name=".PluginProcessServiceXxx"
        android:process=":plugin" />

    <activity
        android:name="com.tencent.shadow.sample.plugin.runtime.PluginXxxProxyActivity"
        android:launchMode="standard"
        android:screenOrientation="portrait"
        android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|screenLayout|fontScale|uiMode|orientation|screenSize|smallestScreenSize|layoutDirection"
        android:hardwareAccelerated="true"
        android:theme="@android:style/Theme.Translucent.NoTitleBar.Fullscreen"
        android:multiprocess="true" />

    <provider
        android:authorities="${applicationId}.contentprovider.authority.dynamic"
        android:name="com.tencent.shadow.core.runtime.container.PluginContainerContentProvider"
        android:grantUriPermissions="true"
        android:process=":plugin" />

    <receiver android:name=".plugin_view.MainProcessManagerReceiver">
        <intent-filter>
            <action android:name="sample_host.manager.startPluginService" />
        </intent-filter>
    </receiver>
    ```

3. `Application` 实现

    - 注意宿主进程和插件进程共用 `Application` 类, 即在宿主和插件的进程中都存在 `Application` 类, 因此初始化代码需要区分宿主和插件进程.
    - `onCreate`:
        - 如果是插件进程, 则恢复上次加载的插件进程的 runtime 信息, 主要是重新调整 classloader.
            - SDK: `DynamicRuntime.recoveryRuntime(this);`
        - 如果是宿主进程, 则初始化插件框架, 管理插件加载器, 以及其他 SDK 相关的初始化.
            - APP: `PluginHelper.init(this);`
            - 拷贝插件相关资源(包括插件管理器的资源包, 插件的资源包)到宿主的私有目录中.
            - 缓存资源包相关信息.
            - 初始化宿主和插件的共享资源, 如 `host-lib` 中的 `Provider` 等.
        - 提供插件管理器的唯一入口, 插件管理器包含了插件的加载和卸载逻辑, 以及插件的更新和安装逻辑.
            - APP: `Shadow.getPluginManager(apk)`
            - 自定义 `PluginManagerUpdater` 管理插件文件的更新逻辑.
            - 通过 SDK 的 `DynamicPluginManager` 自动管理插件管理器的更新, 安装和卸载.

4. 插件管理器更新器 `PluginManagerUpdater` 的自定义实现, 官方 demo 不支持更新, 直接使用的固定路径的 apk.

    ```kotlin
    class PluginManagerUpdaterImpl : PluginManagerUpdater {
        override fun wasUpdating():  Boolean {
            // 检查插件管理器是否正在更新
       }
   
        override suspend fun update(): File? {
            // 异步更新插件管理器的 apk 文件
       }
   
       override fun getLatest(): File? {
            // 获取当前缓存的最新的插件管理器的 apk 文件
        }
   
       override suspend fun isAvailable(file: File): Boolean {
             // 检查 apk 文件是否可用
       }
   }
    ```

    完整的插件管理器升级器一般需要实现以下功能:

    - 服务器端更新支持 - 从远程服务器检查和下载更新
    - 断点续传 - 网络中断后可从断点继续下载
    - 文件完整性校验 - MD5 哈希验证确保文件完整性
    - 版本管理 - 智能版本比较和管理
    - 状态持久化 - 更新状态在应用重启后保持
    - 进度回调 - 详细的更新进度和状态回调
    - 线程安全 - 并发控制确保更新过程安全
    - 错误处理 - 完善的异常处理和重试机制
    - 本地更新支持 - 从本地文件检查更新
    - 支持补丁升级 - 插件升级时可以使用补丁包进行增量更新

5. 启动插件: 基于 `PluginLoadActivityXxx` 发起加载插件的请求(Intent), 通过 Extras 传递插件相关参数.

    - `KEY_ACTIVITY_CLASSNAME`: 插件内的 Activity 类名, 必须是完整的类名, 如 `com.tencent.shadow.sample.plugin.business.MainActivity`.
    - `KEY_PLUGIN_PART_KEY`: 插件分区标识, 用于区分一个插件包内的不同插件 apk.
    - `KEY_FROM_ID`: 启动插件的目标类型 ID, 如 `FROM_ID_NOOP`, `FROM_ID_START_ACTIVITY`, `FROM_ID_CLOSE`, `FROM_ID_LOAD_VIEW_TO_HOST`
    - `KEY_EXTRAS`: 执行目标操作时需要给对应目标的额外参数, Bundle 对象, 例如打开 Activity 时需要传递的额外启动参数.

    > [!question]
    > 
    > 为什么不在这里传递 `KEY_PLUGIN_ZIP_PATH`, 而是在 `PluginLoadActivityXxx` 直接写死的插件 zip 包路径, 不推荐使用多个插件 zip 包吗?

6. 插件加载的入口 `PluginLoadActivityXxx` 实现

    - 通常含有一个用于显示插件加载 view 的容器
    - 在 `onCreate` 中获取 Intent 中的插件相关参数, 如插件 zip 包路径, Activity 类名等.
    - 通过协程或者线程执行插件加载
        - 通过 `Application` 访问唯一插件管理器
        - 基于启动 `PluginLoadActivityXxx` 时传递的 intent 以及写死的插件 zip 包路径 `KEY_PLUGIN_ZIP_PATH`, 构造插件加载参数, 并通过插件管理器执行与 `KEY_FROM_ID` 对应的操作.
            - `FROM_ID_NOOP`: 空操作
            - `FROM_ID_START_ACTIVITY`: 启动插件内部的 Activity
            - `FROM_ID_CLOSE`: 关闭插件进程
            - `FROM_ID_LOAD_VIEW_TO_HOST`: 加载插件 view 到宿主
            - 等...
    - 插件加载完成后, 触发 finish, 在 `onDestroy` 中释放当前插件管理器的资源和加载视图资源.

##### 插件管理器(manager)编写流程

在 Shadow 插件框架中, 插件管理器的实例由宿主应用的 `Application` 类提供访问入口, 具体类型为 `DynamicPluginManager`. 该对象是插件系统的核心组成部分, 负责在运行时动态加载和管理插件, 并支持插件管理器自身的热更新与替换逻辑.

首先, 其动态更新能力依赖于宿主中开发者自定义的 `PluginManagerUpdater` 实现类, 在需要时可以实现替换或升级插件管理器. 而其运行时插件加载与管理能力, 则由开发者实现的 `ManagerFactoryImpl` 和自定义的 `XxxPluginManagerThatUseDynamicLoader` 实现类来完成.

`DynamicPluginManager` 会自动通过反射加载 `ManagerFactoryImpl` 类, 并调用其 `buildManager` 方法来创建具体的插件管理器实例 `XxxPluginManagerThatUseDynamicLoader`. 

1. 依赖配置

   在 build.gradle 中添加以下依赖:

    ```gradle
    dependencies {
        implementation 'com.tencent.shadow.dynamic:dynamic-manager'
        implementation 'com.tencent.shadow.core:manager'
        implementation 'com.tencent.shadow.dynamic:dynamic-loader'
        
        compileOnly 'com.tencent.shadow.core:common'
        compileOnly 'com.tencent.shadow.dynamic:dynamic-host'
    }
    ```

2. 实现 sdk 内部所需的插件管理器工厂实现类 `ManagerFactoryImpl` 和可选的插件框架类加载白名单.

    > [!tip]
    >
    > `ManagerFactoryImpl` 的包名, 类名, 方法, 继承关系必须固定

    ```kotlin
    package com.tencent.shadow.dynamic.impl
    
    import android.content.Context
    import com.tencent.shadow.dynamic.host.ManagerFactory
    import com.tencent.shadow.dynamic.host.PluginManagerImpl
    
    class ManagerFactoryImpl : ManagerFactory {
        override fun buildManager(context: Context): PluginManagerImpl {
            return 这里填写具体的自定义实现类
        }
    }

    interface WhiteList {
        companion object {
            val sWhiteList = arrayOf(
                "com.tencent.host.shadow",
                "com.tencent.shadow.test.lib.constant"
            )
        }
    }
    ```

   - 插件管理器工厂类会在使用 SDK 的 `DynamicPluginManager` 时, 自动从配置的插件管理器 APK 文件中通过反射加载.
   - 插件框架类加载白名单会在 SDK 加载 apk 文件时自动加载和绑定到对应的插件类加载器中.

3. 自定义插件管理器实现类(一般分两部分实现(可以合并为一部分), `FastPluginManager` 只负责插件安装和加载, `XxxPluginManager` 负责根据插件管理器负责的业务行为或场景提供插件管理器所需的业务逻辑)

   插件管理器的业务行为主要由 `getName()` 方法和 `enter()` 方法控制. `getName()` 方法用于对不同插件管理器的持久化存储路径进行区分; `enter()` 方法控制当前插件管理器所支持的插件操作, 如启动插件 Activity, 关闭插件等操作.

    ```kotlin
    class XxxPluginManager(
        private val appContext: Context
    ) : FastPluginManager(appContext) {
        override fun getName(): String = "test-dynamic-manager"
    
        override fun enter(context: Context, fromId: Long, bundle: Bundle, callback: EnterCallback?) {
            when (val action = PluginAction.fromId(fromId)) {
                is PluginAction.NoOp -> {}
                is PluginAction.StartActivity -> {}
                is PluginAction.Close -> {}
            }
        }
    }
    ```
   
    启动插件 Activity 的逻辑:
    - 执行 callback 的展示加载 view 逻辑
    - 安装 `KEY_PLUGIN_ZIP_PATH` 参数指定的插件 zip 包
    - 加载 `KEY_PLUGIN_PART_KEY` 参数指定的插件
    - 手动调用插件 `Application` 的 `onCreate` 方法
    - 转换和构造能启动目标 Activity 的 Intent, 然后通过内部绑定的插件加载服务接口 `mPluginLoader` 在插件中打开目标 Activity.
    - 执行 callback 的隐藏加载 view 逻辑

    关闭插件进程的逻辑:
    - 直接调用 `close()`  方法, 触发内部 SQLite 数据库的关闭.

    安装插件的逻辑(处理插件包解析, 插件信息持久化):
    - 从 `KEY_PLUGIN_ZIP_PATH` 提供的 zip 包中解析插件配置信息, 解析通过调用 SDK 内部方法 `installPluginFromZip`
    - 将所有插件 apk 内部的 so 库文件提取到宿主管理的目录下, 或是直接注册 so 库信息到框架内部, 运行时加载. 是否提取取决于插件内 `AndroidManifest.xml` 中的 `extractNativeLibs` 属性, 提取方法直接调用 `extractSo` 即可.
    - 调用 `onInstallCompleted` 方法, 通知框架所有插件安装完成, 并将插件信息持久化存储到 SQLite 数据库中, 所有信息共同存储在 InstalledPlugin 实例中.
    - 返回已安装的插件包信息, 类型为 `InstalledPlugin`.

    加载插件的逻辑:
        - 通过 `KEY_PLUGIN_PART_KEY` 提供的插件分区标识 `partKey` 绑定此插件对应的插件进程服务类 `XxxPluginProcessService`.
        - 优先加载插件运行时环境处理的插件(runtime)和处理业务插件加载的(loader), 然后加载业务插件. 
            - 前两者加载需要通过 `PluginProcessService` 的 `loadPluginLoader` 和 `loadRuntime` 函数
            - 业务插件加载需要通过 `DynamicPluginLoader` 的 `loadPlugin` 函数.
        
   补充: 启动插件内部服务与宿主通信的方式(如在宿主中展示插件 view, 补充数据等操作):
    - 直接构造启动对应 Service 的 Intent, 然后通过内部绑定的插件加载服务接口 `mPluginLoader` 在插件中打开目标 Service.
    - 因为插件和宿主是跨进程隔离的, 因此两者之间需要交互的数据需要通过同时依赖的 host-lib 进行相关数据的静态全局管理.

##### 插件编写流程

在 Shadow 插件框架中, 插件必须包含两个特殊插件: 负责业务插件运行环境处理的插件(runtime)和负责业务插件加载的插件(loader). runtime 负责插件的运行时逻辑, 包括插件的生命周期管理, 插件组件的注册和调用等. loader 负责加载插件, 包括插件的安装, 卸载, 更新等操作.


在 Shadow 插件框架中, 插件管理器的实例由宿主应用的 `Application` 类提供访问入口, 具体类型为 `DynamicPluginManager`. 该对象是插件系统的核心组成部分, 负责在运行时动态加载和管理插件, 并支持插件管理器自身的热更新与替换逻辑.

首先, 其动态更新能力依赖于宿主中开发者自定义的 `PluginManagerUpdater` 实现类, 在需要时可以实现替换或升级插件管理器. 而其运行时插件加载与管理能力, 则由开发者实现的 `ManagerFactoryImpl` 和自定义的 `XxxPluginManagerThatUseDynamicLoader` 实现类来完成.

`DynamicPluginManager` 会自动通过反射加载 `ManagerFactoryImpl` 类, 并调用其 `buildManager` 方法来创建具体的插件管理器实例 `XxxPluginManagerThatUseDynamicLoader`.


###### 业务插件加载器(loader)编写流程

在 Shadow 插件框架中, 动态插件加载器 `DynamicPluginLoader` 是插件加载器的核心实现, 负责加载插件 APK 中的类和资源, 并提供插件组件的注册和调用功能. 插件加载器通常分为两部分实现: `XxxPluginLoader` 和 `XxxComponentManager`.

`XxxPluginLoader` 扩展自 `ShadowPluginLoader`, 只负责实际的插件加载过程，包括资源、类加载等核心功能. `XxxComponentManager` 负责管理插件中的四大组件和映射关系, 如 Activity、Service、BroadcastReceiver 和 ContentProvider.

`DynamicPluginLoader` 会自动通过反射加载 `CoreLoaderFactoryImpl` 类, 并调用其 `build` 方法来创建具体的插件加载器实例 `XxxPluginLoader`. 而 `XxxComponentManager` 则需要在 `XxxPluginLoader` 中创建和注册.

1. 依赖配置
   
    在 build.gradle 中添加以下依赖和配置:
    ```gradle
    android {
        defaultConfig {
            // loader 插件是插件框架所必需的插件, 同时也不需要构建出可独立运行 APK
            // 而宿主加载插件时要求插件的 applicationId 和宿主的 applicationId 相同, 因此这里需要设置为 applicationId
            applicationId project.HOST_APP_APPLICATION_ID
        }
    }
    dependencies {
        implementation 'com.tencent.shadow.core:loader'
        implementation 'com.tencent.shadow.dynamic:dynamic-loader'
        implementation 'com.tencent.shadow.dynamic:dynamic-loader-impl'
   
        compileOnly 'com.tencent.shadow.core:runtime'
        compileOnly 'com.tencent.shadow.core:activity-container'
        compileOnly 'com.tencent.shadow.core:common'
        compileOnly 'com.tencent.shadow.dynamic:dynamic-host'
    }
    ```

2. 实现 sdk 内部所需的核心加载器工厂实现类 `CoreLoaderFactoryImpl` 和可选的插件框架类加载白名单.
   
   > [!tip]
   >
   > `CoreLoaderFactoryImpl` 的包名, 类名, 方法, 继承关系必须固定. 框架内部会自动通过反射去创建和使用.
   
    ```kotlin
    package com.tencent.shadow.dynamic.loader.impl
    
    import android.content.Context
    import com.tencent.shadow.core.loader.ShadowPluginLoader
    
    class CoreLoaderFactoryImpl : CoreLoaderFactory {
        override fun build(hostAppContext: Context): ShadowPluginLoader {
            return 这里填写具体的自定义实现类
        }
    }

    interface WhiteList {
        companion object {
            val sWhiteList = arrayOf(
                "com.tencent.shadow.sample.host.lib",
            )
        }
    }
    ```

3. 自定义插件加载器实现类(一般分两部分实现, `XxxPluginLoader` 只负责实际的业务插件的加载过程，包括资源、类加载等核心功能, `XxxComponentManager` 负责管理插件中的四大组件和壳子容器组件的映射关系)

业务插件加载器 `XxxPluginLoader` 扩展自 `ShadowPluginLoader`, 其业务行为主要由 `getComponentManager` 和 `getDelegateProviderKey` 方法控制, 因此一般情况下只需要实现两个方法, 返回一个自定义的 `XxxComponentManager` 实例和专用与此加载器的唯一 KEY 即可. 如果需要自定义插件加载器的其他行为, 如插件加载回调, 插件加载失败处理等, 可以重写 `loadPlugin` 方法. `getDelegateProviderKey` 返回的值一定要注意与代理类, 如 `PluginDefaultProxyActivity` 等的对应关系. 不然会导致插件加载时找不到对应类.

业务插件组件管理类 `XxxComponentManager` 负责管理插件中的四大组件和宿主中注册的壳子容器组件的映射关系, 其业务行为主要由 `onBindContainerActivity` 方法 和 `onBindContainerContentProvider` 方法控制. 
- `onBindContainerActivity` 方法用于将插件中的 Activity 组件与宿主中注册的壳子容器组件进行绑定, 并返回一个 `ComponentName` 实例, 绑定关系是通过类名实现.
- `onBindContainerContentProvider` 方法用于将插件中的 ContentProvider 组件与宿主中注册的壳子容器组件进行绑定, 并返回一个 `ContainerProviderInfo` 实例.

> [!question]
> 为什么不根据插件内的 `Manifest` 文件中的 `activity` 元素的 `android:name` 属性来自动绑定组件, 而是通过类名实现?
> 为什么壳子容器组件不是自动生成, 而是手动注册?

###### 处理业务插件运行时环境的插件(runtime)编写流程

在 Shadow 插件框架中, runtime 插件是插件运行时环境处理的插件, 负责插件的运行时逻辑, 包括插件的生命周期管理, 插件组件的注册和调用等. 处理的逻辑很复杂, 但是直接编写 runtime 插件应用很简单, 只需要实现以下几个步骤:

1. 依赖配置
   
   在 build.gradle 中添加以下依赖和配置:
    ```gradle
    android {
        defaultConfig {
            // runtime 插件是插件框架所必需的插件, 同时也不需要构建出可独立运行 APK
            // 而宿主加载插件时要求插件的 applicationId 和宿主的 applicationId 相同, 因此这里需要设置为 applicationId
            applicationId project.HOST_APP_APPLICATION_ID
        }
    }
    dependencies {
        implementation 'com.tencent.shadow.core:activity-container'
    }
    ```

2. 自定义各种运行时需要在宿主中使用的壳子组件, 如 `XxxProxyActivity`. 所有壳子 `Activity` 都需要继承自 `PluginContainerActivity`. 其中可选择实现 `getDelegateProviderKey` 方法, 返回一个唯一的 KEY, 用于标识此壳子组件对应的插件加载器. 如果不实现, 则默认使用 `PluginContainerActivity` 的 KEY.

##### 业务插件编写流程

在 Shadow 插件框架中, 业务插件是指实际的业务逻辑代码, 包括独立的业务组件和相关资源. 每个业务插件可以分为两部分实现: 业务插件库和业务插件应用. 如果需要业务插件能够直接打包和运行, 可以再额外添加一个依赖业务插件库的对应业务应用或是处理业务插件应用的打包逻辑.

###### 业务插件库

业务插件库是一个 library 模块, 主要用于存放当前业务插件所需的所有业务逻辑代码, 甚至是业务插件的入口 Activity 和 Application 类.

这类库的编写没什么特殊的, 与普通的 Android library 模块编写类似.

###### 业务插件应用

业务插件应用是一个 application 模块, 主要用于打包当前业务插件所需的所有业务逻辑代码和资源, 并生成一个可安装的 APK 文件. 业务插件应用通常依赖于对应的业务插件库, 并在其基础上添加一些额外的配置和逻辑, 便于 Shadow 插件框架进行自动化处理.

> [!tip]
> 如果有多个业务插件, 某些配置只需要在一个业务插件应用中配置即可, 其他业务插件应用可以不配置, 对应的特殊配置在下面会提到.
> 如果插件依赖 AppCompatActivity 进行业务开发, 需要在插件内进行主题资源适配, 而不是宿主中
> runtime 依赖类型必须 compileOnly, 不然会导致 transform 时遇到壳子组件发生循环依赖

1. 依赖配置

   在 build.gradle 中添加以下依赖和配置:
    ```gradle
    buildscript {
        dependencies {
            classpath 'com.tencent.shadow.core:runtime' // Shadow框架的核心运行时库
            classpath 'com.tencent.shadow.core:activity-container' // Shadow框架的Activity容器
            classpath 'com.tencent.shadow.core:gradle-plugin' // Shadow框架的Gradle插件
            classpath "org.javassist:javassist:$javassist_version" // Java字节码操作库,用于代码注入
        }
    }

    apply plugin: 'com.android.application'
    apply plugin: 'com.tencent.shadow.plugin'
    
    android {
        // 默认配置
        defaultConfig {
            // 业务插件一般可能需要直接打包成 APK, 因此需要设置业务对应 applicationId
            // 但是宿主使用插件时要求插件的 applicationId 和宿主的 applicationId 相同
            // 因此需要后面的 productFlavors 配置在插件打包时覆盖此值为宿主的 applicationId
            applicationId 'com.tencent.shadow.sample.plugin.app' 
        }

        productFlavors {
            plugin {
                // 这里会自动将插件 applicationId 设置为和宿主相同
                applicationId project.SAMPLE_HOST_APP_APPLICATION_ID
            }
        }

        aaptOptions {
            // 因为前面提到过低版本 Android 系统不支持插件的资源分区, 因此插件的 Resources 需要和宿主的 Resources 合并.
            // 这里需要将插件的资源ID分区改为和宿主0x7F不同的值, 避免合并过程产生资源冲突.
            additionalParameters "--package-id", "0x7E", "--allow-reserved-package-id"
        }
    }
    
    // 依赖配置
    dependencies {
        pluginCompileOnly 'com.tencent.shadow.core:runtime'
   
        pluginCompileOnly project(":sample-host-lib") // 插件类型打包时使用 compileOnly 类型依赖, 因为这个库的实现在宿主有了, 配置插件的访问白名单即可使用
        normalImplementation project(":sample-host-lib") // 正常 apk 打包时使用 implementation 类型依赖, 是直接生成独立 apk 了, 与宿主无关
    
        implementation project(":sample-base-lib") // 这里表示插件类型打包或正常 apk 打包均使用 implementation 类型依赖
    }
    
    // Shadow 插件框架的配置, 此配置只需要在业务插件应用中配置一次即可.
    shadow {
        // 插件打包配置
        packagePlugin {
            // 加载器和运行时APK的项目路径, 用于和下面的 loaderApkConfig 和 runtimeApkConfig 配置一起实现两个插件的自动打包和加载.
            loaderApkProjectPath = 'projects/sample/source/sample-plugin/sample-loader'
            runtimeApkProjectPath = 'projects/sample/source/sample-plugin/sample-runtime'
   
            // 配置不同构建类型的插件
            pluginTypes {
                // Debug版本配置
                debug {
                    loaderApkConfig = new Tuple2('sample-loader-debug.apk', ':sample-loader:assembleDebug')
                    runtimeApkConfig = new Tuple2('sample-runtime-debug.apk', ':sample-runtime:assembleDebug')
   
                    // 业务插件因为自由度更高, 需要手动配置每个业务插件的 APK 信息.
                    pluginApks {
                        sampleApp {
                            businessName = 'sample-plugin-app'
                            partKey = 'sample-app'
                            buildTask = ':sample-app:assemblePluginDebug'
                            apkPath = 'projects/sample/source/sample-plugin/sample-app/build/outputs/apk/plugin/debug/sample-app-plugin-debug.apk'
                            hostWhiteList = ["com.tencent.shadow.sample.host.lib"]
                            dependsOn = ['sample-base'] // 运行时依赖的其他插件, 目前的笔记未涉及, 后面再介绍, 如果自己编写 demo, 这里可以暂时不用.
                        }
                    }
                }
    
                // Release版本配置(结构同Debug, 路径不同)
                ...
            }
    
            // 插件包配置
            archiveSuffix = System.getenv("PluginSuffix") ?: "" // 插件包后缀, 可以通过环境变量 PluginSuffix 来设置, 默认为空
            archivePrefix = 'plugin' // 插件包前缀, 默认为 'plugin'
            destinationDir = "${getRootProject().getBuildDir()}" // 插件包输出目录, 这里为整个项目的根 build 目录
    
            version = 4 // 插件包版本, 用于标识插件包的版本
            uuidNickName = "1.1.5" // 插件包版本的别名, 用于标识当前插件包的版本
            compactVersion = [1, 2, 3] // 当前版本插件包的兼容旧版本号 [1, 2, 3]
        }
    }
    ```

##### 打包流程

1. Shadow 的 Gradle 插件会在定义 `plugin` 配置的业务插件应用中自动生成编译所有插件 apk 并打包成 zip 包的任务. 示例位置: Android Studio -> Gradle -> :sample-app -> Tasks -> shadow -> packageAllPlugin. 执行即可.
2. 执行宿主的打包任务, 示例位置: Android Studio -> Gradle -> :sample-host -> Tasks -> build -> assembleDebug. 执行即可. 或是右上角常用的 app 构建图标也行, 选择宿主项目即可.

#### 高级用法

##### 如何适配 jdk17 和高版本 gradle

##### 如何在插件中使用宿主的资源

#### 源码解析

SDK 结构

```text
├── projects
│   ├── sdk // 框架代码
│   │   ├── coding
│   │   │   ├── aar-to-jar-plugin
│   │   │   ├── android-jar
│   │   │   ├── code-generator
│   │   │   ├── common-jar-settings
│   │   │   ├── get-android-jar
│   │   │   ├── java-build-config
│   │   ├── core
│   │   │   ├── activity-container // 插件 Activity 容器
│   │   │   ├── common // 一些公共的工具类
│   │   │   ├── gradle-plugin // gradle 插件
│   │   │   ├── load-parameters // 插件加载参数
│   │   │   ├── loader // 负责加载插件
│   │   │   ├── manager // 装载插件，管理插件
│   │   │   ├── runtime // 插件运行时需要，包括占位 Activity，占位 Provider 等等
│   │   │   ├── transform // Transform 实现，用于替换插件 Activity 父类等等
│   │   │   └── transform-kit // Transform 工具类
│   │   └── dynamic // 插件自身动态化实现，包括一些接口的抽象
│   │   │   ├── dynamic-apk
│   │   │   ├── dynamic-host
│   │   │   ├── dynamic-host-multi-loader-ext
│   │   │   ├── dynamic-loader
│   │   │   ├── dynamic-loader-impl
│   │   │   ├── dynamic-manager
│   │   │   └── dynamic-manager-multi-loader-ext
```

编译时:

宿主会通过 `core/gradle-plugin` 中 的 `ShadowPlugin` 插件自动生成插件化框架所需的配置文件, 插件信息, 辅助类文件等.

打包时:

- core.common
- dynamic.host

运行时:

manager在加载"插件"时，首先需要先加载"插件"中的runtime和loader， 再通过loader的Binder（插件应该处于独立进程中避免native库冲突）操作loader进而加载业务App。

- 宿主加载 Manager 插件
- Manager 解析插件包.


#### issues 临时笔记

##### 插件升级问题

---question & answer
最近看源码的时候突然发现好像没有这部分说明/ 代码, 那么请问你们是如何在插件已经运行过一次后 对插件进行更新的呢,更新比较关键, 先卸载再更新只是一种途径
...
我只能猜你在问什么。
插件的更新机制可以由业务在Manager中控制。更新的时机和业务是强相关的。Manager和插件进行通信，在合适的时机启动新插件就可以了。
对于插件UUID更新的情况，由于配套的Loader和Activity-Container也需要更新，则需要重起PPS。
那么最容易实现的策略可以是如果没有插件包，则等待下载，否则先启动本地已有的最新插件包，同时去下载更新的插件包。

请问，目前是需要我们自己实现从后台下载插件包的功能是么？后面官方有计划补充上这个功能么？
...
对。现在开源的代码中Manager只实现了下载好插件包之后的事情，包括安装和升级之类的本地功能。
版本检查和下载是需要业务方继承SDK的Manager然后实现的。
这部分功能我们是有计划开源的，我们肯定是希望开源出来，让大家跟我们用同一套实现，这样才有可能公共维护。
---

---question & answer
场景与需求：我们项目中有三个插件ABC，其中想单独升级插件C。
Shadow实现：在宿主host中将manage先复制到build/generated/assets/...文件夹下，将build目录下plugin-debug.zip根据packagePlugin复制到assets文件夹下，然后通过PluginHelper类从assets文件夹下复制到pluginManagerFile和pluginZipFile这两个文件中，然后后续的插件加载都是通过这两个文件糅合到宿主host中进行加载的。
问题： 目前插件中的实现，都是加载pluginZipFile这个文件加载插件的，没法做到单独升级插件C。
我不确定我目前理解的是不是对的，请大佬解惑。
...
你理解的基本没问题。manager作为shadow的插件管理逻辑，它的主要设计是服务于我们做shadow时自己的业务的需要的。作为开源项目，我们尽可能把它设计的通用可扩展了，但是对于我们自己业务用不上的逻辑没法实现那么完整。
在现有代码设计中，宿主、manager、插件，是3个不同的版本部分，可以更新其中1个的版本。对于插件这个部分来说，其中还包含loader、runtime、业务插件这些部分。这些东西是用一个UUID统一成一个版本的。在设计中，UUID相同的apk，才能协同工作。这个设计主要是因为我们需要这些UUID相同的插件经常通过类的白名单直接跨apk引用类型，所以需要简单管理它们，需要它们一同更新。
ABC三个插件，如果只需要更新C插件，那么AB也要一起更新，对于用户来说要重复下载AB插件显然是不合适的。在预想的设计中，考虑未来这个场景应该通过增量下载来优化。即manager在下载新UUID的ABC插件时，可以根据md5等文件hash复用之前旧的UUID的AB插件，达到只下载新版本的C插件和少量新配置文件的目的。所以对于loader来说，新UUID的ABC 3个插件都是新的。
启动新版本UUID的ABC 3个插件时，肯定要重启进程了。如果要保持AB插件的内存而更新插件C，还需要特别的设计。在改动不大的情况下，应该只能给C单独分配一个manager实现，让它和AB采用不同的UUID，相互通过AIDL通信。即同一个宿主接入多个不相关的Shadow实现。
...
首先感谢大佬的回复。
是不是我将插件AB使用一套manager，插件C使用另一套单独的manager进行管理，我们项目中插件ABC相互不通讯，是不是可以单独升级插件C？
...
是的。一个宿主中可以接多个Shadow的实现。最好将这些插件分开到不同进程中，避免潜在的冲突。
---

---question & answer
我这边想要做一个插件升级的功能。
我的项目中，有多个插件。固定了uuid，保持他们一致。
loader、runtime、manager这些我会预装在宿主assets中，
当宿主启动时，会将这些push到app的私有目录中。
插件工程最后打包的zip中，包含了config.json，及插件apk。
按照sample中的逻辑，当一个插件包被加载过后，不会重新加载zip。这块我修改了源码，可以自主选择是否重新加载zip包。
那么问题来了，插件的版本号控制，我能想到的是，宿主去维护一个版本号。
安装了某个插件后，记录下当前版本号，发现版本号有更新，再去重新加载新下载的zip。
请问shadow框架在此场景中，有没有记录插件版本号的字段及管理？
config.json中，有一个version字段，但该字段并没有被解析到InstalledPlugin中，而且该字段表明的意思似乎并不是插件的版本号。
我在查看源码的时候，发现UUID_NICKNAME字段有注释为插件版本号，可以依据此字段去做插件升级判断逻辑吗？
...
用UUID_NICKNAME记录你插件的自定义版本号就行了。在manager实现里用这个字段去判断是否更新插件就行。
然后core.manager对于安装的插件管理逻辑是后安装的就是新版本的插件。
每次安装的插件UUID还是要变化的。各个部分的UUID保持一致是为了标记它们是一个版本，能协同工作。
https://github.com/Tencent/Shadow/blob/master/projects/sdk/core/manager/src/main/java/com/tencent/shadow/core/manager/installplugin/PluginConfig.java
这个代码注释里有描述字段的用途。
...
我看shadow中有plugin、以及part的概念。
我是不是可以认为，如果我这边所有的插件uuid固定是一样的，那么我每一个插件都是一个part？
在shadow中，我所有的插件的集合会被认为是一个插件？
...
对。com.tencent.shadow.core.manager.installplugin.InstalledPlugin 这个类型定义了插件分成了几个Part，part也分了类型。
...
那么按照这种设计，其实我应该在每个part中去定义他的partVersion。
但是这好像又和已有的数据库设计冲突。
其实我的目的就是，每个插件可以单独升级，单独安装。
但是uuid要求每个插件的uuid都是一致的。
有什么办法能去除这种限制吗？
...
这个我前两天也回复过类似的问题：#583 (comment)
核心问题还是多个插件apk之间可能有ClassLoader parent的依赖关系。如果确实没有类型依赖，单独升级应该是不会有问题的。但是我们既然有类的跨apk依赖能力，就要有UUID这种设计帮助保护它。
我还是建议考虑从下载的层面复用之前UUID的apk，给它分配新的UUID。
...
我明白你的意思。
但是有的业务场景是插件之间完全没有关联，完全独立。
这种情况下，多个插件会被uuid限制住。
有没有什么方式可以去掉这种限制？
或者说，具体做限制的地方代码在哪处，这样我好修改为符合我这边应用场景的代码。
我没有去掉uuid的限制，但是用另一种方式做了规避。
虽然可能不符合shadow的设计理念，但符合我这边的业务场景。
在此分享一下大概思路。
在shadow的脚本中添加partVersion，用于记录每一个part的版本号信息。
在manager中判断已加载的partVersion与zip中的partVersion差异，
来决定是否重新加载zip包。


---

--- answer

---

--- question && answer
Shadow框架我已经成功集成并且调用成功，但是我搞不懂插件要如何升级？
issues中我也看了几个关于升级插件的，这边的需求没有这么复杂，只用到了一个插件，只要能做到插件升级即可
我目前知道的在App当中需要加入manage.apk 以及 plugin.zip
传统的升级思路：
下载文件并更新原有的文件即可
疑问：
我更新插件时，manage和plugin两个文件都需要重新下载升级？
我如何在主工程app当中获取plugin的版本号？用于对比本地插件是否需要升级
由于在app当中读取manage.apk路径以及名称都是是写死的，当我下载到新的manage是直接替换掉原有的manage？
还有就是是否有提供已经封装好的方法直接替换下载好的manage和plugin？
...
如果我的思路不正确，是否能帮忙调整？
manager.apk这个是不要去弄成动态的，你把它和宿主工程放在同一个项目中，当它构建出来时，你把它自动拷贝到宿主的assets目录下，然后在运行宿主时把它放到某个目录中（app或者sd卡中）。
只有插件apk的信息是动态的，这个需要动态下载，你在宿主调用时，通过bundle传动态的值。

请问下，宿主app动态下载加载manage-project和插件plugin，目前shadow支持判断是否已经下载完manage和plugin包并且判断版本号，是否有新版本需要重新下载？还是说这些判断都是需要我这边自己去写代码做判断。感谢
...
插件升级逻辑需要你自己写。对于core-manager来说，后安装的插件就是最新版本的。
可以用config.json中的UUID_NickName来标记业务版本号：
也完全重写core-manager满足自己的需要，重写manager逻辑是不会涉及loader的。


##### 插件uuid的设计问题

---question&& answer
基于现在的设计，是不是没办法动态的给插件分配进程。现在的系统好像是默认同一个Service里的所有插件uuid都是一样的。如果我有两个不同uuid的插件包，是不是没办法把他们加载到同一个Service里？
...
uuid是版本号。一组不同partkey的插件可以协同工作，就可以分配相同的uuid。插件启动在哪个进程，是由PPS和ContainerActivity决定的。这两件事不相关。manager的代码是动态的，就可以动态的决定从哪一个PPS 启动插件。
...
en, 我再说详细一点吧，我两个partkey不同，uuid也不同，然后在manager里面给他们分配同一个pps来加载。由于pps里面对之前加载pluginLoader时的uuid做了缓存，所以后面用partkey来加载插件时，第一个先加载的插件是可以的，但加载第二个插件时，由于pps里缓存了第一个插件的uuid，就直接使用第一个插件的uuid去处理了，造成第二个插件找不到。
#929，之前有人提过这个问题，当时的回复确实是同一个进程只能启动相同uuid的插件，想问下这么设计的初衷是什么？如果改成同一个进程启动不同uuid的插件有没有什么问题？
...
uuid是版本号。关于版本控制都是些通用的设计，没什么特殊的。混合加载不同版本的组件会引起什么问题可以参考一些动态库兼容性方面的资料，都是差不多的。
我们的理解可能有点偏差，应该不涉及到版本控制的问题。比如这里有两个插件，我们没办法控制他们uuid必须一样，他们有各自的版本，但理论上还是应该可以把他们分配到同一个进程。我看现在的设计里同一个进程中的插件uuid必须要统一，为什么不同的插件uuid要一致呢？
...
你没有提供具体的场景，也许你的插件非常简单，没有版本控制也能正常工作。比如一个插件是计算器，一个插件是相册，那它们就没什么关系嘛。版本不一致也不会显露出什么问题。但这种情况下你也可以把它们版本号设为相同的，也不影响什么。 你要还认为这跟版本控制没关系，就关了issue吧。这个uuid就是版本号。没啥好讨论的了。
...
你举的这个例子就可以啊，按照你的解释，计算器和相册的版本号每次都要设置一样，否则就没法在同一个进程。但实际开发中，计算器和相册的版本号不可能一直一样吧，比如计算器出问题了，我升级了一个版本，相册没动，那计算器新版本插件下发之后就不能和老版本的相册在同一进程工作了。不知道这个场景，你们怎么处理呢？
---

##### 多插件、多进程

--- question && answer
在测试官方demo时，官方提供了两个插件
想提出以下几个问题
1、不管是选择哪个插件都是加载的 sample-plugin-app 这个demo是还没完成么？
2、宿主加载两个插件，就需要有两个插件的进程，每个插件是用同一个ppscontroller ？还是一个插件一个ppsController? 我之所以问这个问题就是因为我在加载多插件时会判断ppsController是否为空，为空才会绑定另外一个进程服务，很显然按照官方demo，加载了第一个插件后ppsController是不为空的，所以对于另外的插件不会启动单独的进程。对于下图中的代码，对于多插件的情况下能否满足要求么？
3、多插件，多进程的情况下，需要让FastFastPluginManager继承自PluginManagerThatSupportMultiLoader 对么？PluginManagerThatSupportMultiLoader类中有些未实现的抽象方法需要研发人员自己实现么？比如getPluginKey() ?
...
从提交记录 a0ea9d5 上可以看出来这个app2只是为了验证multiprocess的用法。
不同插件进程里的插件是不相关的，跨进程的代码相互之间没有影响。所以我们一般不会专门研究怎么支持插件多进程，就是manifest中的process属性。因为这个没有什么技术障碍，把插件组件分配到对应插件进程的PPS就行了。
一个插件进程一个PPS。宿主在manager这边控制它就行了。fast manager只是个支持持有一个controller的启动流程演示代码。要管理多个PPS只需要持有多个控制器就好了。
要是同一个插件进程需要多种Loader版本，才需要multiloader那套实现。具体可以看提交记录，搜issue。这种场景是多个业务被迫共用一个插件进程。多个业务的shadow版本不一样。
谢谢回复！这个必须使用多个ppscontroller才行是吧，因为一个pps对应一个IBinder 对象，我看改造的话还挺麻烦的。能给具体写段代码或有多插件加载的demo 么？
经过多次、多个插件进程代码的断点调试，多插件基本功能已经实现，一些小细节还需调整。下面贴出改造后的代码，如有错误还需指正：主要改的文件是FastPluginManager文件代码：修改后的代码如下

---

