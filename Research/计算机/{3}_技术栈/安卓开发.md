---
tags:
title: 安卓开发
description: ""
author: ""
categories: ""
keywords:
  - ""
draft: true
layout: ""
date: 2024-07-31 10:44:21
lastmod: 2024-08-12 13:47:23
---

> [!todo] > [https://developer.android.com/courses/android-basics-compose/course](https://developer.android.com/courses/android-basics-compose/course) > [https://developer.android.com/courses/unit/kotlin-basics-unit-1](https://developer.android.com/courses/unit/kotlin-basics-unit-1) > [https://www.geeksforgeeks.org/kotlin-android-tutorial/](https://www.geeksforgeeks.org/kotlin-android-tutorial/) > [https://developer.android.com/courses/](https://developer.android.com/courses/)

## Android 应用程序组成

### 清单文件 `AndroidManifest.xml`

安卓操作系统与安卓应用程序之间由清单文件 `AndroidManifest.xml` 进行连接, 该清单文件位于应用程序的根目录下, 用于告知系统应用程序的基本信息, 如应用程序的名称、图标、版本号、权限以及各种组件等.

以下是一个简单的清单文件示例及其内容解析:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <!-- 应用程序信息 -->
    <application
        android:name=".MyApplication"
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.MyApplication3"
        tools:targetApi="31">

        <!-- 活动声明 -->
        <activity
            android:name=".MainActivity"
            android:launchMode="singleTop"
            android:taskAffinity=""
            android:allowTaskReparenting="true"
            android:exported="true"
            android:label="@string/title_activity_main"
            android:permission="com.example.MY_PERMISSION"
            >
        <intent-filter>
            <action android:name="android.intent.action.MAIN" />
            <category android:name="android.intent.category.LAUNCHER" />
        </intent-filter>
        </activity>

        <activity
            android:name=".SecondActivity"
            android:exported="true"
            android:label="@string/title_activity_second">
        <intent-filter>
            <action android:name="com.example.SECOND" />
            <category android:name="android.intent.category.DEFAULT" />
        </intent-filter>
        </activity>

        <!-- 服务声明 -->
        <service
            android:name=".MyService"
            android:exported="true">
            <intent-filter>
                <action android:name="com.example.MY_SERVICE" />
            </intent-filter>
        </service>

        <!-- 广播接收器声明 -->
        <receiver
            android:name=".MyReceiver"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.BOOT_COMPLETED" />
            </intent-filter>
        </receiver>

        <!-- 内容提供程序声明 -->
        <provider
            android:name=".MyProvider"
            android:authorities="com.example.myprovider"
            android:exported="true"
            android:grantUriPermissions="true">
            <grant-uri-permission android:pathPattern="/myprovider/*" />
            </provider>
    </application>

    <!-- 权限声明 -->
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission android:name="android.permission.CAMERA" />
    <uses-permission android:name="android.permission.RECORD_AUDIO" />
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />

    <!-- 使用特性 -->
    <uses-feature android:name="android.hardware.camera" />
    <uses-feature android:name="android.hardware.microphone" />
    <uses-feature android:name="android.hardware.location.gps" />

</manifest>
```

顶部声明

- `<?xml version="1.0" encoding="utf-8"?>`：声明 XML 文件的版本和编码方式.
- `<manifest>`：根元素, 包含应用的所有配置.
    - `xmlns:android="http://schemas.android.com/apk/res/android"`：定义 `android` 命名空间, 用于引用安卓系统提供的属性.
    - `xmlns:tools="http://schemas.android.com/tools"`：定义 `tools` 命名空间, 用于引用开发工具 (如 Android Studio) 提供的一些自定义属性.  

- `<application>` 元素

包含应用级别的配置信息, 定义应用的全局属性和组件.

- `android:name=".MyApplication"`: 指定应用的自定义 `Application` 类.
- `android:allowBackup="true"`: 允许用户备份和恢复应用的数据.
- `android:dataExtractionRules="@xml/data_extraction_rules"`: 指定数据提取规则, 通常用于自动备份功能.
- `android:fullBackupContent="@xml/backup_rules"`: 指定完整备份内容的规则.
- `android:icon="@mipmap/ic_launcher"`: 指向用于标识应用的图标的资源
- `android:label="@string/app_name"`: 指定应用的显示名称.
- `android:roundIcon="@mipmap/ic_launcher_round"`: 指定圆形应用图标 (通常用于圆形图标需求的设备).
- `android:supportsRtl="true"`: 指定应用是否支持从右到左 (RTL) 的布局方向.
- `android:theme="@style/Theme.MyApplication3"`: 指定应用的主题.
- `tools:targetApi="31"`: 指定目标 API 级别, 主要用于开发工具进行静态代码检查, 不影响实际运行时的行为.

**`<activity>`元素**

定义一个活动 (Activity), 是应用的一个主要组件, 代表一个用户界面.

- `android:name=".MainActivity"`: 指定活动的类名, `.MainActivity` 表示该活动在应用包名下.
- `android:launchMode="singleTop"`: 指定活动的启动模式. 这里是 `singleTop`, 表示如果活动已经在栈顶, 不会重新创建新的实例.
- `android:taskAffinity=""`: 指定活动的任务亲和性, 控制活动创建时所在的任务栈. 默认会在当前任务栈, 如果设置了亲和值, 则会寻找具有相同亲和值的任务栈, 如果没有则创建新的任务栈.
- `android:allowTaskReparenting="true"`: 指定当活动所在任务栈进入前台时, 是否可以将活动移动到其他具有相同亲和性的任务栈.
- `android:clearTaskOnLaunch="true"`: 每当用户离开该任务并再次返回时, 任务栈中的所有活动都会被清除, 仅保留根活动.
- `android:alwaysRetainTaskState="true"`: 拒绝系统在用户长时间离开任务栈时清除除了根活动之外的所有活动.
- `android:finsihOnTaskLaunch="true"`: 指定活动是否在任务启动时结束.
- `android:exported="true"`: 指定活动是否可以由应用之外的组件启动. `true` 表示可以被其他应用访问.
- `android:label="@string/title_activity_main"`: 指定活动的显示名称.
- `android:permission="com.example.MY_PERMISSION"`: 指定活动自身被调用时需要的权限.
- `<intent-filter>`: 定义了活动能够响应的意图 (Intent) , 通常用于配置应用的启动活动和处理特定的动作.

    - `<action>`: 定义意图的动作.

        - `android:name="android.intent.action.MAIN"`: 表示该活动是应用的主入口点, 会为其创建程序图标.
        - `android:name="com.example.SECOND"`: 自定义的动作名称.

    - `<category>`: 定义意图的类别.

        - `android:name="android.intent.category.LAUNCHER"`: 表示该活动会出现在应用启动器中, 作为应用的启动活动.
        - `android:name="android.intent.category.DEFAULT"`: 默认的意图类别.

**`<service>`**元素**

定义一个服务 (Service) , 是一个后台运行的组件, 用于执行长时间运行的操作.

- `android:name=".MyService"`: 指定服务的类名.
- `android:exported="true"`: 指定服务是否可以被其他应用访问.
- `<intent-filter>`: 定义了服务能够响应的意图.

    - `<action>`: 定义意图的动作.

        - `android:name="com.example.MY_SERVICE"`: 自定义的动作名称.

**`<receiver>` 元素**

定义一个广播接收器 (Broadcast Receiver) , 用于接收系统广播事件.

- `android:name=".MyReceiver"`: 指定广播接收器的类名.
- `android:exported="true"`: 指定广播接收器是否可以被其他应用访问.
- `<intent-filter>`: 定义了广播接收器能够响应的意图.

    - `<action>`: 定义意图的动作.

        - `android:name="android.intent.action.BOOT_COMPLETED"`: 表示系统启动完成后发送的广播.

**`<provider>` 元素**

定义一个内容提供程序 (Content Provider) , 用于管理应用程序的数据集.

- `android:name=".MyProvider"`: 指定内容提供程序的类名.
- `android:authorities="com.example.myprovider"`: 指定内容提供程序的权限.
- `android:exported="true"`: 指定内容提供程序是否可以被其他应用访问.
- `android:grantUriPermissions="true"`: 指定内容提供程序是否授予 URI 权限.
- `<grant-uri-permission>`: 定义了内容提供程序授予的 URI 权限.

    - `android:pathPattern="/myprovider/*"`: 匹配 URI 的路径模式.

**`<uses-permission>` 元素**

定义应用程序需要的权限.

- `android:name="android.permission.INTERNET"`: 访问互联网的权限.
- `android:name="android.permission.ACCESS_NETWORK_STATE"`: 访问网络状态的权限.
- `android:name="android.permission.CAMERA"`: 使用摄像头的权限.
- `android:name="android.permission.RECORD_AUDIO"`: 录制音频的权限.
- `android:name="android.permission.ACCESS_FINE_LOCATION"`: 访问精确位置的权限.

**`<uses-feature>` 元素**

定义应用程序需要的硬件功能.

- `android:name="android.hardware.camera"`: 摄像头硬件功能.
- `android:name="android.hardware.microphone"`: 麦克风硬件功能.
- `android:name="android.hardware.location.gps"`: GPS 定位硬件功能.

### 应用程序基础: Application

应用程序的基础是 `Application` 类, 一个单例类, 每个应用程序都有一个 `Application` 实例, 它是整个应用程序的入口点, 负责应用程序的初始化和全局状态的管理, 可以通过 `getApplication()` 方法获取.

- 在应用程序启动时初始化一些全局的资源或配置, 例如第三方库 (如分析工具、数据库库等).
- 在应用程序的生命周期中管理全局状态, 例如用户登录状态、网络连接状态等.
- 监控整个应用程序的生命周期, 处理一些全局的状态变化.

    - `onCreate()`: 应用程序创建时调用.
    - `onTerminate()`: 应用程序终止时调用.

```kotlin
class MyApplication : Application() {
    override fun onCreate() {
        super.onCreate()
        // 初始化Firebase
        FirebaseApp.initializeApp(this)
        // 初始化Crashlytics
        Fabric.with(this, Crashlytics())
        // 初始化数据库
        Realm.init(this)
        // 初始化全局数据
        someGlobalData = "This is some global data"
    }
}
```

### 应用程序四大组件: 活动、服务、广播接收器、内容提供程序

Android 应用程序由四个主要组件组成:

- 活动 (Activity): 用户与应用程序进行交互的主要入口点, 通常表示一个具有用户界面的屏幕
- 服务 (Service): 在后台执行长时间运行的操作或远程处理
- 广播接收器 (Broadcast Receiver): 在系统广播事件发生时接收系统广播
- 内容提供程序 (Content Provider): 管理应用程序的数据集

活动可以启动服务来执行后台任务; 注册广播接收器来接收系统或应用的广播以更新 UI; 使用内容提供程序来访问和管理数据; 启动其他活动, 并传递数据.

广播接收器被动接收系统或应用的广播事件, 然后可以启动服务来执行后台任务, 也可以通过内容提供程序来访问和管理数据.

服务通常是由活动或广播接收器启动, 可以通过内容提供程序来访问和管理数据.

内容提供程序为程序提供标准的数据管理接口, 包括查询、插入、更新和删除.

此外还有些附加组件:

- 片段 (Fragment): 可重用的 UI 组件
- 意图 (Intent): 用于在组件之间传递消息
- 视图 (View): 用户界面的构建块
- 布局 (Layout): 定义视图的结构和外观
- 资源 (Resource): 应用程序的非代码资源, 如图像、字符串和布局文件

#### 活动 (Activity)

每个活动都是一个类, 继承自 `Activity` 类或其子类, 用于表示 Android 应用程序用户界面的一个屏幕. Android 应用启动时, 会首先进入设置的主 `Activity` 的初始化过程. 此外, 每个应用程序可以包含多个活动, 所有活动必须在清单文件 `AndroidManifest.xml` 中进行声明, 当一个应用调用另一个应用时, 发起调用的应用可以调用另一个应用中的其他 `activity`. 例如, 浏览器应用可能会启动社交媒体应用的分享 `activity`.

每个活动都有一个生命周期, 包括以下主要状态:

- `onCreate(Bundle savedInstanceState)`: 活动创建时调用
- `onStart()`: 活动开始时调用, 初始化的资源应在 `onStop` 释放
- `onResume()`: 活动恢复时调用(可见且在前台 ) <-----|
- `onPause()`: 活动暂停时调用(可见但不在前台) ----->| 不建议释放与 ui 相关的资源和耗时操作
- `onStop()`: 活动停止时调用(不可见), 系统会自动保存组件状态, 即使活动被销毁.
- `onRestart()`: 活动重新启动时调用
- `onDestroy()`: 活动销毁时调用

辅助方法:

- `onSaveInstanceState(Bundle outState)`: 保存活动除布局或视图之外的自定义状态, 以便在活动重新创建时恢复, 缺点是只能保存少量数据, 因为要在主线程进行序列化操作.
- `onRestoreInstanceState(Bundle savedInstanceState)`: 恢复保存的状态, 与 `onSaveInstanceState` 配合使用, 一般使用 `onCreate` 方法就足够了.
- `startActivity(Intent intent, Bundle options)`: 启动另一个活动
- `startActivityForResult(Intent intent, int requestCode)`: 启动另一个活动并获取结果, 结果通过 `onActivityResult` 方法返回
- `setResult(int resultCode, Intent data)`: 当被其他活动启动时, 设置返回结果.
- `onActivityResult(int requestCode, int resultCode, Intent data)`: 当其他活动响应了 `Intent` 后, 并通过 `setResult` 设置了返回结果, 会调用此方法.

自定义默认启动活动模式

- `launchMode.standard`: 标准模式, 每次启动都会创建新的实例, 并将启动时的 `Intent` 传递给新的实例. 比如新闻应用中每次点击文章链接都会创建新的文章页面实例.
- `launchMode.singleTop`: 栈顶复用模式, 如果活动已经在栈顶, 不会重新创建新的实例, 而是调用 `onNewIntent` 方法来处理新的 `Intent`. 如果活动不在栈顶, 会创建新的实例. 比如点击消息通知栏的消息进入消息详情页面, 如果在消息通知栏消失前点击多次, 不会创建新的实例, 而是复用当前页面.
- `launchMode.singleTask`: 栈内复用模式, 如果活动已经在栈中, 会将该活动上面的所有活动出栈, 并调用 `onNewIntent` 方法来处理新的 `Intent`. 如果活动不在栈中, 会创建新的实例. 比如点击应用图标或导航栏的主页面, 我的页面等进入页面, 如果页面已经在栈中, 会将页面上面的所有活动出栈`.
- `launchMode.singleInstance`: 单实例模式, 如果没有包含此活动的任务栈, 则创建一个单独的任务栈管理此活动, 并且该活动独占任务栈, 不会与其他活动共享任务栈. 如果已经有包含此活动的任务栈, 则直接把此任务栈置于前台展示, 不会创建新的实例. 比如播放视频的全屏模式, 独立登录页面等, 会创建一个新的任务栈, 并且独占任务栈.
- `launchMode.singleInstancePerTask`: 单示例和栈内复用模式, 如果没有包含此活动的任务栈, 则创建一个单独的任务栈管理此活动, 此活动会置于栈底, 后续启动的活动也会在此任务栈中. 如果已经有包含此活动的任务栈, 则直接把此任务栈置于前台展示, 不会创建新的实例, 同时将此活动顶部的其他活动出栈.

```kotlin
class MainActivity : AppCompatActivity() {
    lateinit var textView: TextView
    var gameState: String? = null
    var currentScore = 0
    var currentLevel = 0
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        if (savedInstanceState != null) {
            with(savedInstanceState) {
                gameState = getString(GAME_STATE_KEY)
                textView.text = getString(TEXT_VIEW_KEY)
                currentScore = getInt(STATE_SCORE)
                currentLevel = getInt(STATE_LEVEL)
            }
        }
        setContentView(R.layout.activity_main)
        textView = findViewById(R.id.text_view)
    }

    override fun onStart() {
        super.onStart()
        Log.d(TAG, "onStart")
    }

    override fun onResume() {
        super.onResume()
        Log.d(TAG, "onResume")
    }

    override fun onPause() {
        super.onPause()
        Log.d(TAG, "onPause")
    }

    override fun onStop() {
        super.onStop()
        Log.d(TAG, "onStop")
    }

    override fun onSaveInstanceState(outState: Bundle?) {
        outState?.run {
            putString(GAME_STATE_KEY, gameState)
            putString(TEXT_VIEW_KEY, textView.text.toString())
            putInt(STATE_SCORE, currentScore)
            putInt(STATE_LEVEL, currentLevel)
        }
        // Call superclass to save any view hierarchy.
        super.onSaveInstanceState(outState)
    }
}
```

活动之间可以通过意图 (Intent) 进行通信, 意图可以用于启动活动、启动服务、发送广播等.

#### 服务 (Service)

服务是可以在后台执行长时间运行操作或远程处理(下载文件、播放音乐、更新数据等)的组件, 不提供用户界面, 即使应用程序处于后台或被销毁, 服务仍然可以继续运行. 每个服务都是一个类, 继承自 `Service` 类或其子类. 服务必须在清单文件 `AndroidManifest.xml` 中进行声明.

服务可以通过活动的 `startService()` 或 `bindService()` 方法启动, 通过 `stopService()` 或 `unbindService()` 方法停止. 区别在于 `startService()` 启动的服务会一直运行, 直到调用 `stopService()` 停止, 而 `bindService()` 是在其他 app 或系统组件中绑定服务, 绑定后服务会一直运行直到所有绑定的组件都解绑.

每个服务也有一个生命周期, 包括以下主要状态:

- `onStartCommand()`: 服务启动时调用
- `onCreate()`: 服务创建时调用
- `onBind()`: 服务绑定时调用
- `onUnbind()`: 服务解绑时调用
- `onRebind()`: 服务重新绑定时调用
- `onDestroy()`: 服务销毁时调用

#### 广播接收器 (Broadcast Receiver)

广播接收器是用于接收系统或应用的广播事件的组件, 当特定事件发生时, 广播接收器会接收并处理广播消息. 每个广播接收器都是一个类, 继承自 `BroadcastReceiver` 类或其子类. 广播接收器必须在清单文件 `AndroidManifest.xml` 中进行声明.

广播接收器可以通过 `registerReceiver()` 方法注册, 通过 `unregisterReceiver()` 方法注销. 也可以通过清单文件声明静态注册, 这样即使应用程序未运行, 也可以接收广播.

广播接收器可以接收系统广播事件, 常见的系统广播事件包括:

- `android.intent.action.BOOT_COMPLETED`: 系统启动完成时发送的广播
- `android.intent.action.SCREEN_ON`: 屏幕开启时发送的广播
- `android.intent.action.SCREEN_OFF`: 屏幕关闭时发送的广播
- `android.intent.action.ACTION_POWER_CONNECTED`: 充电器连接时发送的广播
- `android.intent.action.ACTION_POWER_DISCONNECTED`: 充电器断开时发送的广播
- `android.intent.action.BATTERY_LOW`: 电池电量低时发送的广播
- `android.intent.action.BATTERY_OKAY`: 电池电量恢复正常时发送的广播

广播接收器也可以通过活动的 `sendBroadcast()` 方法发送自定义的广播事件.

#### 内容提供程序 (Content Provider)

内容提供程序是用于管理应用程序的数据集的组件, 提供包括查询、插入、更新和删除等数据接口, 支持跨应用程序访问数据. 存储方式包括数据库, 文件, 网络等.

每个内容提供程序都是一个类, 继承自 `ContentProvider` 类或其子类. 内容提供程序必须在清单文件 `AndroidManifest.xml` 中进行声明.

内容提供程序可以通过查询, 插入, 更新和删除方法来操作数据. 想访问内容提供程序可以通过预定义的 URI (Uniform Resource Identifier) 来标识和访问数据集, URI 由以下部分组成:`<prefix>://<authority>/<data_type>/<id>`

`ContentProvider` 类中的方法:

- `query()`: 查询数据
- `insert()`: 插入数据
- `update()`: 更新数据
- `delete()`: 删除数据
- `getType()`: 获取数据类型
- `onCreate()`: 当提供者被启动时调用

#### 意图 (Intent)

意图是一种异步消息传递机制,

意图是用于在组件之间异步传递消息的对象, 用于在将组件绑定, 同时在组件之间传递消息, 如启动活动、启动服务、发送广播等.

- 显式意图 (Explicit Intent): 指定要启动的组件的类名, 如告诉系统在 Gmail 应用程序中启动发送电子邮件的 `Activity`. 启动时可以修改组件的启动模式.
- 隐式意图 (Implicit Intent): 指定要执行的操作, 由系统根据意图的动作和数据类型选择合适的组件, 然后系统 UI 询问用户选择哪个应用程序来处理该意图, 如在任何可以完成发送电子邮件工作的活动中启动发送电子邮件的 `Activity`.

标志:

- `FLAG_ACTIVITY_NEW_TASK`: 对应 `launchMode` 的 `singleTask`
- `FLAG_ACTIVITY_SINGLE_TOP`: 对应 `launchMode` 的 `singleTop`
- `FLAG_ACTIVITY_CLEAR_TOP`: 如果正在启动的活动已经在当前任务中运行, 那么系统将销毁其上的所有其他活动, 而不是启动该活动的新实例.
- `FLAG_ACTIVITY_CLEAR_TOP` + `FLAG_ACTIVITY_NEW_TASK`: 如果正在启动的活动已经在当前任务中运行, 那么系统将销毁其上的所有其他活动, 并将此活动置于新任务的顶部.

```xml
<uses-permission android:name="com.example.MY_PERMISSION" /> <!-- 调用其他活动需要申请对应活动定义的权限 -->

<activity android:name=".ExampleActivity">
    <intent-filter>
        <action android:name="com.example.EXAMPLE_ACTION" /> <!-- 自定义的动作名称 -->
        <category android:name="android.intent.category.DEFAULT" /> <!-- 默认的意图类别, 表示该活动可以接收启动意图 -->
        <data android:mimeType="text/plain" /> <!-- 可以发送的数据类型 -->
    </intent-filter>
</activity>
```

```kotlin
// 调用意图
val intent = Intent(this, ExampleActivity::class.java)
intent.action = "com.example.EXAMPLE_ACTION"
intent.type = "text/plain"
intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
startActivity(intent)
```

## 项目架构

### 架构原则

原则:

- 组件分离

    - 单一职责
    - 高内聚低耦合

        - 不要将 `ViewModel` 传入 `RecyclerView` 等视图的适配器(Adapter), 而是通过适配器或视图状态的 Callback 接口实现 ViewModel 的访问.

- 通过数据模型驱动界面

    - 尽量持久化存储

- 单一数据源

    - 分配单一的数据持有者
    - 只有持有者可以修改或转变数据, 修改尽量通过提供接口来实现

### 架构结构

UI Layer(界面层, 唯一职责是使用和显示界面状态)

- 界面(UI): 唯一职责是使用 `View` 或 `Jetpack Compose` 等构建视图元素来使用和显示界面状态.

    - 界面会向状态容器发送用户事件通知, 状态容器会处理事件对应的逻辑并更新界面状态.
    - 界面通过使用适当的生命周期感知型协程构建器从状态容器收集最新的界面状态(View: `repeatOnLifecycle`, Compose: `collectAsStateWithLifecycle`). (循环往复)
    - 如果界面不可见或未处于活动状态, 除非明确要求, 否则状态生成和收集的过程可以暂停, 防止消耗任何资源. (生命周期感知型协程构建器会自动控制)
    - 不要替换 activity 或 fragment 的生命周期方法, 可以改为使用 `LifecycleObserver` 监听生命周期事件. 或是通过 `repeatOnLifecycle` 来监听生命周期状态事件(`CREATED`、`DESTROYED`、`INITIALIZED`、`RESUMED`、`STARTED`).

- 界面状态(UI State): 由状态容器提供, 向界面提供数据(`_UiState`, 类似于 `Model`, 尽可能是不可变的.).

    - 一般包含要显示的数据, 控制是否要展示的状态, 控制是否要跳转的状态, 界面的回调函数, 界面的补充信息(突然要弹窗展示的信息)
    - 只有数据源或数据所有者才应负责更新他们公开的数据

- 状态容器(State holder): 负责存储和提供界面状态, 并且包含执行相应任务所必需的处理逻辑.

    - 状态容器分两种, 一种由普通的类实现(界面逻辑状态容器), 绑定到界面的生命周期, 存储不需要长期保留的界面状态和界面逻辑. 一个种由 `ViewModel` 实现(业务逻辑状态容器), 用于处理业务逻辑, 将数据从数据层或网域层转换为屏幕界面状态, 通过数据流向界面提供数据, 通过回调函数向界面提供事件处理逻辑.
    - `ViewModel` 不要放入容器视图的适配器中, 会增加耦合, 可以通过采用回调的方式(界面状态中放回调或适配器定义回调参数)进行.
    - 在 `ViewModel` 中应该立即处理事件, 并通过事件的处理结果引发状态更新, 而不能将来自 `ViewModel` 的事件发送到界面.
    - `ViewModel` 不要存储对任何与生命周期相关的类型的引用, 如 `Activity`, `Fragment`, `Context` 或 `Resources` 作为依赖项传递. 因为 `ViewModel` 生命周期长, 持有的引用在设备状态更改导致被销毁重建时, 旧实例无法被垃圾回收.
    - `ViewModel` 通过数据流(`StateFlow`, `LiveData`)向界面提供界面状态数据, 通过回调函数向界面提供事件处理逻辑.
    - `ViewModel` 通过内置的协程作用域 `viewModelScope` 来执行异步任务(`suspend` 函数), 如从数据源获取数据以及更新界面状态数据.
    - `ViewModel` 应该在屏幕级别的组件中使用, 如 `activity`, `fragment` 等屏幕级别的组件. 对于嵌套的 `fragment`, 如果与父级共享一个 `ViewModel`, 可以通过 `ViewModelProvider` 来获取父级 `fragment` 的 `ViewModel`.

- 界面事件(Event): 由界面发送给状态容器的事件, 用于触发状态容器中的逻辑处理.

    - 包括用户交互、本地资源状态改变、外部资源状态改变产生的事件等.
    - 如果事件需要执行界面逻辑 (与修改界面元素的状态相关, 如可展开项的状态) , 界面便可以直接处理这些事件.
    - 如果事件需要执行业务逻辑 (如刷新屏幕上的数据, 更新数据库数据) , 则应用由 `ViewModel` 处理此事件.

Domain Layer(网域层, 负责封装复杂的业务逻辑, 或者由多个 `ViewModel` 重复使用的简单业务逻辑)

- 合并数据层的多个存储库数据
- 存储可重复使用的简单业务逻辑, 相比于存放在 `Utils` 类中, 使得业务逻辑更加清晰, 便于维护.

Data Layer(数据层, 负责处理数据的获取和存储)

- 由多个存储库(`Repositories`)组成, 其中每个存储库都可以包含零到多个数据源(`Data Sources`).
- 存储库负责处理数据变化, 解决不同数据源冲突, 对数据源抽象化处理, 编码业务逻辑, 提供公开数据访问的函数接口.
- 每个数据源类仅负责处理一个数据源, 数据源可以是文件、网络来源或本地数据库(数据库、`DataStore`、`SharedPreferences`、Firebase API、GPS 位置信息提供程序、蓝牙数据提供程序、网络连接状态提供程序), 且只能由存储库访问.
- 多个存储库可以组合成一个 Manager 存储库, 以便在一个存储库中处理多个数据源.
- 数据源尽可能包含本地数据源和远程数据源, 以便在没有网络连接时使用本地数据源.
- 调用数据源或存储库时, 推荐通过协程(或多线程)来异步获取数据以及与保持数据在不同层之间的流动, 以避免阻塞主线程. 耗时长的操作可以通过 `WorkManager` 来执行. 比如在程序启动时在后台逐一初始化数据源, 以避免启动时的卡顿.
- 从网络数据源读取数据时, 可以通过指数退避算法需要处理网络连接失败、超时等异常情况.

#### 生命周期感知型组件

`Activity` 或 `Fragment` 通常会在其生命周期中执行一些操作, 如初始化数据、加载数据、释放资源等. 普通的生命周期方法在编写时会导致代码冗长, 比如初始化和释放资源的代码分散在了多个生命周期方法中, 使代码难以维护. 不同声明周期方法是异步执行的, 因为执行时间不同, 有时候可能会导致不同的生命周期方法之间的数据不一致.

生命周期感知型组件用于解决这些问题, 通过 `Lifecycle`(`LifecycleRegistry` 是其具体实现的类) 和 `LifecycleObserver`(`DefaultLifecycleObserver` 和 `LifecycleEventObserver` 是其具体实现的类) 来观察和响应具有生命周期变化的组件(如 `Activity` 或 `Fragment`等实现了 `LifecycleOwner` 接口的组件)的生命周期事件, 从而在生命周期状态发生变化时执行相应的操作.

- `Lifecycle`(`LifecycleRegistry`) 存储了具有生命周期变化的组件的生命周期状态, 并且可以在生命周期状态发生变化时通知所有注册的 `LifecycleObserver` 对象. 通过 `addObserver()` 方法来添加 `LifecycleObserver` 对象, 通过 `removeObserver()` 方法来移除 `LifecycleObserver` 对象.
- `DefaultLifecycleObserver` 是一个接口, 用于观察具有生命周期变化的组件的生命周期事件, 从而在生命周期状态发生变化时执行相应的操作. 通过实现 `LifecycleObserver` 接口并重写 `onCreate()`, `onStart()`, `onResume()`, `onPause()`, `onStop()`, `onDestroy()` 等方法来执行相应的操作.
- `LifecycleEventObserver` 是一个接口, 用于观察具有生命周期变化的组件的生命周期事件, 从而在生命周期状态发生变化时执行相应的操作. 通过实现 `LifecycleEventObserver` 接口并重写 `onStateChanged()` 方法来执行相应的操作. 如果同时实现了 `DefaultLifecycleObserver` 接口, 则 `DefaultLifecycleObserver` 的方法会优先执行.

注意事项:

- 当 `onSaveInstanceState()` 被调用时, Android 认为当前的 UI 状态应该被保存, 因此不建议在这之后再更改 UI. 然而, `onStop()` 通常在 `onSaveInstanceState()` 之后调用, 此时 `Lifecycle` 会从 `RESUMED` 变为 `CREATED`, 分发 `ON_STOP` 事件. 如果在 `onSaveInstanceState()` 和 `onStop()` 之间对 UI 进行更改, 可能导致应用导航状态不一致. [这是个问题](https://developer.android.com/topic/libraries/architecture/lifecycle?hl=zh-cn#onStop-and-savedState)!

```kotlin
class MyObserver : DefaultLifecycleObserver {
    override fun onCreate(owner: LifecycleOwner) {
        // 在 onCreate() 方法中执行初始化操作
    }

    override fun onDestroy(owner: LifecycleOwner) {
        // 在 onDestroy() 方法中执行释放资源操作
    }
}

class MyActivity : AppCompatActivity() {
    private val myObserver = MyObserver()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        lifecycle.addObserver(myObserver) // getLifecycle()
    }

    override fun onDestroy() {
        super.onDestroy()
        lifecycle.removeObserver(myObserver)
    }
}
```

每个 `LifecycleOwner` 对象都有一个协程作用域, 可以通过 `lifecycleScope` 属性来获取; 每一个 `ViewModel` 对象都有一个协程作用域, 可以通过 `viewModelScope` 属性来获取.  
生命周期感知型组件的协程作用域用于在生命周期范围内启动协程, 以便在生命周期状态发生变化时取消协程.

如果需要在 `LifecycleOwner` 对象只要进入到指定的生命周期状态就执行某个操作, 可以使用 `repeatOnLifecycle()` 函数, 该函数会在 `LifecycleOwner` 对象进入到指定的生命周期状态时执行指定的操作, 并且会在 `LifecycleOwner` 对象退出指定的生命周期状态时取消操作.

```kotlin
class MyActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        lifecycleScope.launch {

            // 随状态变化而反复执行
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                // 在 STARTED 状态下执行操作
            }

            // 单次长时间操作, 随状态变化可恢复运行直到运行完成
            whenStarted {
                // 在第一次 STARTED 状态下执行操作
            }

            whenResumed {
                // 在第一次 RESUMED 状态下执行操作
            }

            whenCreated {
                // 在第一次 CREATED 状态下执行操作
            }
        }
    }
}

class MyFragment : Fragment() {
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        viewLifecycleOwner.lifecycleScope.launch {
            viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {
                // 在 STARTED 状态下执行操作
            }
        }
    }
}

class MyViewModel : ViewModel() {
    init {
        viewModelScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                // 在 STARTED 状态下执行操作
            }
        }
    }
}
```

#### ViewModel(未完成)

`ViewModel` 是一个用于持久存储界面相关状态数据, 处理界面业务逻辑的类. 防止因为 `activity` 或 `fragment` 的重建而导致数据丢失. 同时, `ViewModel` 的作用域被限定为 `ViewModelStoreOwner` 的生命周期范围内, 通常是 `activity` 或 `fragment` 的生命周期范围内. 只有在 `activity` 或 `fragment` 在非配置更改的情况下被销毁时, `ViewModel` 才会被销毁, 比如调用 `finish()` 方法.

```kotlin
class MyViewModel : ViewModel() {
    private val _data = MutableStateFlow<String>()
    val data: StateFlow<String> = _data.asStateFlow()

    fun updateData(newData: String) {
        _data.value = newData
    }
}

class MyActivity : AppCompatActivity() {
    private val viewModel: MyViewModel by viewModels() // 使用 by viewModels() 代理属性来获取 ViewModel 实例, 这通常在 onCreate() 之前

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        viewModel = ViewModelProvider(this).get(SimpleViewModel::class.java) // 使用 ViewModelProvider 手动创建 ViewModel 实例


        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.data.collect { data ->
                    // 更新界面数据
                }
            }
        }
    }
}
```

因为 `ViewModelProvider` 只能通过默认的无参构造函数来创建 `ViewModel` 实例. 当 `ViewModel` 需要依赖外部组件时, 可以通过构造函数注入或 Hilt 库进行依赖注入, 并只能通过 `ViewModelProvider.Factory` 来创建 `ViewModel` 实例.

```kotlin
class MyViewModel @ViewModelInject constructor(
    private val repository: MyRepository
) : ViewModel() {
    private val _data = MutableStateFlow<String>()
    val data: StateFlow<String> = _data.asStateFlow()

    fun updateData(newData: String) {
        _data.value = newData
    }
}

class MyViewModelFactory @Inject constructor(
    private val repository: MyRepository
) : ViewModelProvider.Factory {
    override fun <T : ViewModel?> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(MyViewModel::class.java)) {
            return MyViewModel(repository) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}

class MyActivity : AppCompatActivity() {
    private val viewModel: MyViewModel by viewModels { MyViewModelFactory(repository) } // 使用 by viewModels() 代理属性来获取 ViewModel 实例, 这通常在 onCreate() 之前

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        var factory = MyViewModelFactory(repository)
        viewModel = ViewModelProvider(this, factory).get(SimpleViewModel::class.java) // 使用 ViewModelProvider 手动创建 ViewModel 实例

        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.data.collect { data ->
                    // 更新界面数据
                }
            }
        }
    }
}

```

可以通过 `SavedStateHandle` 在 `ViewModel` 中保存和恢复与界面状态相关的数据, 避免因为系统因内存不足等原因终止应用程序时导致的数据丢失, 从而在重启应用程序时恢复数据.

#### LiveData(未完成)

`LiveData` 是一种可观察的数据存储器类, 可以感知 `LifecycleOwner` 的生命周期状态, 并且只在 `LifecycleOwner` 处于活动状态时通知观察者.  
`MutableLiveData` 是 `LiveData` 的子类, 用于存储可变数据, 并且可以通过 `setValue()` 或 `postValue()` 方法来更新数据.

```kotlin
class MyViewModel : ViewModel() {
    private val _data = MutableLiveData<String>()
    val data: LiveData<String> = _data

    fun updateData(newData: String) {
        _data.value = newData
    }
}

class MyActivity : AppCompatActivity() {
    private val viewModel: MyViewModel by viewModels()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        val observer = Observer<String> { data ->
            // 更新界面数据

        }
        viewModel.data.observe(this, observer)
    }
}
```

[将协程与 LiveData 一起使用](<https://developer.android.com/topic/libraries/architecture/coroutines?hl=zh-cn#livedata:~:text=项> 浪费资源。-,将协程与 LiveData 一起使用,-使用 LiveData 时)

#### StateFlow

`StateFlow` 是一种可观察的数据存储器类, 可以感知 `LifecycleOwner` 的生命周期状态, 并且只在 `LifecycleOwner` 处于活动状态时通知观察者.  
`MutableStateFlow` 是 `StateFlow` 的子类, 用于存储可变数据, 并且可以通过 `value` 属性来更新数据.

```kotlin
class MyViewModel : ViewModel() {
    private val _data = MutableStateFlow<String>("")
    val data: StateFlow<String> = _data.asStateFlow()

    fun updateData(newData: String) {
        _data.value = newData
    }
}

class MyActivity : AppCompatActivity() {
    private val viewModel: MyViewModel by viewModels()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.data.collect { data ->
                    // 更新界面数据
                }
            }
        }
    }
}
```

#### DataStore

#### Room

#### WorkManager

### 依赖管理

- 通过构造函数注入或 Hilt 库进行依赖注入
- 依赖注入使类能够定义其依赖项而不构造它们. 在运行时, 另一个类负责提供这些依赖项.
- 服务定位器: 服务定位器模式提供了一个注册表, 类可以从中获取其依赖项而不构造它们.

Dagger&Hilt 中常见的注解及其功能的详细介绍:

- `@HiltAndroidApp`: 用于标记应用程序的 `Application` 类以在应用程序启动时触发 `Hilt` 的代码生成, 基于 Dagger 生成和管理依赖注入的必要组件.
- `@AndroidEntryPoint`: 用于标记 `Activity`, `Fragment`, `View`, `Service`, `BroadcastReceiver` 等 Android 组件, 使其成为的依赖注入的入口点, 表示他们需要被注入依赖项.
- `@HiltViewModel`: 用于标记 `ViewModel` 类, 以告知依赖注入框架为 `ViewModel` 类提供依赖注入.
- `@Inject`: 用于标记构造函数, 字段, 方法或属性, 表示它们是依赖注入的目标, 从而自动为这些目标注入所需的依赖项. (除了默认的一些依赖, 其他依赖项都需要通过 `@Module` 来告知如何提供)
- `@Module`: 标记一个 `object` 类为依赖注入模块, 模块中的方法可以通过 `@Provides` 注解告知依赖注入框架如何提供依赖项.
- `@InstallIn`: 用于标记 `@Module` 类, 以指定该模块的生命周期和作用域. 如 `ApplicationComponent`, `ActivityComponent`, `FragmentComponent`, `ServiceComponent`, `BroadcastReceiverComponent` 等.
- `@Provides`: 用于标记 `@Module` 类中的方法, 以告知依赖注入框架如何提供依赖项.
- `@Singleton`: 用于标记依赖项的作用域, 表示该依赖项在所在的依赖注入模块的整个生命周期中只会被创建一次.
- `@Binds`: 标记一个 `abstract` 抽象类为依赖注入模块, 模块中的抽象方法可以通过 `@Binds` 注解告知依赖注入框架如何将抽象接口方法的依赖项与具体实现绑定.
- `@Qualifier`: 标记一个 `annotation` 注解类来自定义依赖项类型注解, 以通过注解的形式告知依赖注入框架何区分相同类型的不同依赖项实现.
- `@Named`: 内置的用于标记依赖项的类型注解, 以通过注解的形式告知依赖注入框架何区分相同类型的不同依赖项实现.
- `@ViewModelInject`: 内置的用于标记 `ViewModel` 类的构造函数, 以告知依赖注入框架为 `ViewModel` 类提供依赖注入.
- `@EntryPoint`: 定义 Hilt 组件外部的依赖项的入口点. 可以让非 Hilt 管理的类也能获取依赖项.
- `@ApplicationContext`: 内置的用于标记 `Context` 类型的依赖项, 以告知依赖注入框架注入的是应用程序的 `Context` 对象.
- `@ActivityRetainedScoped`: 内置的用于定义依赖项的生命周期与 `Activity` 保持一致.

```kotlin
@HiltAndroidApp
class MyApplication : Application()

@Qualifier
@Retention(AnnotationRetention.BINARY)
annotation class MyQualifier

@Module
@InstallIn(SingletonComponent::class)
object MyModule {
    @Provides
    @Singleton
    fun provideMyDependency(): MyDependency {
        return MyDependency()
    }

    @Provides
    @Named("MyDependency")
    fun provideNamedDependency(): MyDependency {
        return MyDependency()
    }

    @Provides
    @MyQualifier
    fun provideQualifiedDependency(): MyDependency {
        return MyDependency()
    }
}

@Module
@InstallIn(ApplicationComponent::class)
abstract class MyAbstractModule {
    @Binds
    abstract fun bindMyDependency(impl: MyDependencyImpl): MyDependency
}

@AndroidEntryPoint
class MyActivity : AppCompatActivity() {
    @Inject
    @Named("MyDependency")
    lateinit var myDependency: MyDependency
}

@HiltViewModel
class MyViewModel @Inject constructor(
    @MyQualifier private val myDependency: MyDependency
) : ViewModel()

@EntryPoint
@InstallIn(ApplicationComponent::class)
interface MyEntryPoint {
    fun myDependency(): MyDependency
}

class MyService : Service() {
    private val myDependency: MyDependency by lazy {
        EntryPointAccessors.fromApplication(this, MyEntryPoint::class.java).myDependency()
    }
}
```

### 项目测试

> [!cite] > [Android 测试模块](https://developer.android.com/topic/modularization/patterns#test-modules) > [Android 测试](https://developer.android.com/training/testing?hl=zh-cn)

- 测试内容

    - 对 ViewModel (包括 Flow) 进行单元测试
    - 对数据层实体进行单元测试. 即对代码库和数据源进行单元测试
    - 进行界面导航测试 (可在持续集成环境中用作回归测试)
    - 测试 StateFlow 和 LiveData 的行为

        - 尽可能对 value 属性进行断言
        - 如果使用 WhileSubscribed, 您应该创建一个 collectJob

### 模块组织

- 项目模块化: 将应用程序拆分为多个模块, 以便更容易管理和维护, 以下是从高到低的模块组织结构:

    - 应用模块(app): 包含界面入口点, 依赖于功能模块, 支持产品变种(`productFlavors`), 编译为不同的二进制文件, 如不同设备或不同版本的 APK 文件, 以及不同的构建类型(`buildTypes`), 如调试和发布版本.
    - 功能模块(feature): 包含一系列相关的屏幕. 对于导航栏, 每个功能可能对应一个目的地. 依赖于数据模块和通用模块.
    - 通用模块(core): 包含应用程序中多个模块之间共享的代码, 如工具类、扩展函数、自定义视图等.
    - 数据模块(data): 包含存储库(`Repository`)、数据源(`DataSource`)和模型类(`Model`), 用于封装特定领域的所有数据和业务逻辑, 将存储库公开为外部 API.
    - 测试模块(test): 包含单元测试和 UI 测试, 用于测试应用程序的各个部分.

- 注意事项:

    - 模块间需要相互依赖并通信时, 可以通过将相关逻辑放在另一个中介模块中进行解耦, 以避免直接依赖. 同时此中介模块可以被其他任何需要此逻辑的模块复用.
    - 高级模块(业务逻辑)不应该直接依赖于低级模块的具体实现, 而是应该依赖于其抽象接口. 这样可以方便低级模块的替换, 扩展和测试. 具体项目中可以同时创建一个 `api` 模块和一个 `impl` 模块, `api` 模块定义接口, `impl` 模块实现接口.

()[![https://developer.android.com/static/topic/libraries/architecture/images/mad-arch-ui-udf-in-action.png?hl=zh-cn](https://developer.android.com/static/topic/libraries/architecture/images/mad-arch-ui-udf-in-action.png?hl=zh-cn)]

### 架构代码样例

```kotlin

data class Author(
    val id: String,
    val name: String,
)

data class LoginUiState(
    val isLoading: Boolean = false,
    val errorMessage: String? = null,
    val isUserLoggedIn: Boolean = false
)

class LoginViewModel : ViewModel() {
    private val _uiState = MutableStateFlow(LoginUiState())
    val uiState: StateFlow<LoginUiState> = _uiState.asStateFlow()
    /* ... */
}

class LoginActivity : AppCompatActivity() {
    private val viewModel: LoginViewModel by viewModels()

    override fun onCreate(savedInstanceState: Bundle?) {
        /* ... */

        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.uiState.collect { uiState ->
                    if (uiState.isUserLoggedIn) {
                        // Navigate to the Home screen.
                    }
                    ...
                }
            }
        }
    }
}

private const val DOB_VALIDATION_KEY = "dobValidationKey"

class DobValidationFragment : Fragment() {

    private var validationInProgress: Boolean = false
    private val viewModel: DobValidationViewModel by viewModels()

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        val binding = // ...
        validationInProgress = savedInstanceState?.getBoolean(DOB_VALIDATION_KEY) ?: false

        binding.continueButton.setOnClickListener {
            viewModel.validateDob()
            validationInProgress = true
        }

        viewLifecycleOwner.lifecycleScope.launch {
            viewModel.uiState
                .flowWithLifecycle(viewLifecycleOwner.lifecycle)
                .collect { uiState ->
                    // Update other parts of the UI ...

                    // If the input is valid and the user wants
                    // to navigate, navigate to the next screen
                    // and reset `validationInProgress` flag
                    if (uiState.isDobValid && validationInProgress) {
                        validationInProgress = false
                        navController.navigate(...) // Navigate to next screen
                    }
                }
        }

        return binding
    }

    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)
        outState.putBoolean(DOB_VALIDATION_KEY, validationInProgress)
    }
}



data class NewsItem(
    val title: String,
    val body: String,
    val bookmarked: Boolean = false,
    val publicationDate: String,
    val onBookmark: () -> Unit
)

data class Message(val id: Long, val message: String)
data class NewsUiState(
    val isSignedIn: Boolean = false, // 状态属性
    val isPremium: Boolean = false,
    val isFetchingArticles: Boolean = false, // 加载状态
    val newsItems: List<NewsItem> = listOf(), // 数据
    val userMessages: List<Message> = listOf() // 反馈信息
)
val NewsUiState.canBookmarkNews: Boolean get() = isSignedIn && isPremium // 其他属性的派生属性
interface NewsRepository{}

class NewsViewModel : ViewModel() {
    private val repository: NewsRepository
    private val formatDateUseCase: FormatDateUseCase,
    private val _uiState = MutableStateFlow(NewsUiState())
    val uiState: StateFlow<NewsUiState> = _uiState.asStateFlow()
    val newsListUiItems = repository.latestNews.map { news ->
        NewsItemUiState(
            title = news.title,
            body = news.body,
            bookmarked = news.bookmarked,
            publicationDate = formatDateUseCase(news.publicationDate),
            // Business logic is passed as a lambda function that the
            // UI calls on click events.
            onBookmark = {
                repository.addBookmark(news.id)
            }
        )
    }

    private var fetchJob: Job? = null

    fun fetchArticles(category: String) {
        fetchJob?.cancel()
        fetchJob = viewModelScope.launch {
            try {
                val newsItems = repository.newsItemsForCategory(category)
                _uiState.update {
                    it.copy(newsItems = newsItems)
                }
            } catch (ioe: IOException) {
                // Handle the error and notify the UI when appropriate.
                _uiState.update {
                    val messages = getMessagesFromThrowable(ioe)
                    it.copy(userMessages = messages)
                 }
            }
        }
    }

    fun refreshNews() {
        viewModelScope.launch {
            // If there isn't internet connection, show a new message on the screen.
            if (!internetConnection()) {
                _uiState.update { currentUiState ->
                    currentUiState.copy(userMessages = arrayOf(["No Internet connection"]))
                }
                return@launch
            }

            // Do something else.
        }
    }

    fun userMessageShown() {
        _uiState.update { currentUiState ->
            currentUiState.copy(userMessage = null)
        }
    }

}

class NewsActivity : AppCompatActivity() {
    private lateinit var binding2: ActivityLoginBinding
    private lateinit var binding: ActivityLatestNewsBinding
    private val viewModel: NewsViewModel by viewModels()

    override fun onCreate(savedInstanceState: Bundle?) {
        ...

        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                // 界面根据新数据, 更新要显示的数据
                viewModel.uiState
                    .map { it.isFetchingArticles }
                    .distinctUntilChanged()
                    .collect { progressBar.isVisible = it }
                // 根据状态的更改, 界面进行响应
                viewModel.uiState.collect { uiState ->
                    // 根据一些信息的更改, 界面进行一些通知
                    uiState.userMessage?.let {
                        // TODO: Show Snackbar with userMessage.

                        // Once the message is displayed and
                        // dismissed, notify the ViewModel.
                        viewModel.userMessageShown()
                    }
                }
            }
        }

        binding.expandButton.setOnClickListener {
            binding.expandedSection.visibility = View.VISIBLE
        }

        binding.refreshButton.setOnClickListener {
            viewModel.refreshNews()
        }

        binding2.helpButton.setOnClickListener {
            navController.navigate(...) // Open help screen
        }
    }
}

data class ArticleApiModel(
    val id: Long,
    val title: String,
    val content: String,
    val publicationDate: Date,
    val modifications: Array<ArticleApiModel>,
    val comments: Array<CommentApiModel>,
    val lastModificationDate: Date,
    val authorId: Long,
    val authorName: String,
    val authorDateOfBirth: Date,
    val readTimeMin: Int
)

data class Article(
    val id: Long,
    val title: String,
    val content: String,
    val publicationDate: Date,
    val authorName: String,
    val readTimeMin: Int
)

class NewsRemoteDataSource(
  private val newsApi: NewsApi,
  private val ioDispatcher: CoroutineDispatcher
) {
    /**
     * Fetches the latest news from the network and returns the result.
     * This executes on an IO-optimized thread pool, the function is main-safe.
     */
    suspend fun fetchLatestNews(): List<ArticleHeadline> =
        // Move the execution to an IO-optimized thread since the ApiService
        // doesn't support coroutines and makes synchronous requests.
        withContext(ioDispatcher) {
            newsApi.fetchLatestNews()
        }
    }

// Makes news-related network synchronous requests.
interface NewsApi {
    fun fetchLatestNews(): List<ArticleHeadline>
}

// NewsRepository is consumed from other layers of the hierarchy.
class NewsRepository(
    private val newsRemoteDataSource: NewsRemoteDataSource,
        // This could be CoroutineScope(SupervisorJob() + Dispatchers.Default).
    private val externalScope: CoroutineScope
) {
    suspend fun fetchLatestNews(): List<ArticleHeadline> =
        newsRemoteDataSource.fetchLatestNews()
    // Mutex to make writes to cached values thread-safe.
    private val latestNewsMutex = Mutex()

    // Cache of the latest news got from the network.
    private var latestNews: List<ArticleHeadline> = emptyList()

    suspend fun getLatestNews(refresh: Boolean = false): List<ArticleHeadline> {
        return if (refresh) {
            externalScope.async {
                newsRemoteDataSource.fetchLatestNews().also { networkResult ->
                    // Thread-safe write to latestNews.
                    latestNewsMutex.withLock {
                        latestNews = networkResult
                    }
                }
            }.await()
        } else {
            return latestNewsMutex.withLock { this.latestNews }
        }
    }
}

class RefreshLatestNewsWorker(
    private val newsRepository: NewsRepository,
    context: Context,
    params: WorkerParameters
) : CoroutineWorker(context, params) {

    override suspend fun doWork(): Result = try {
        newsRepository.refreshLatestNews()
        Result.success()
    } catch (error: Throwable) {
        Result.failure()
    }
}

private const val REFRESH_RATE_HOURS = 4L
private const val FETCH_LATEST_NEWS_TASK = "FetchLatestNewsTask"
private const val TAG_FETCH_LATEST_NEWS = "FetchLatestNewsTaskTag"

class NewsTasksDataSource(
    private val workManager: WorkManager
) {
    fun fetchNewsPeriodically() {
        val fetchNewsRequest = PeriodicWorkRequestBuilder<RefreshLatestNewsWorker>(
            REFRESH_RATE_HOURS, TimeUnit.HOURS
        ).setConstraints(
            Constraints.Builder()
                .setRequiredNetworkType(NetworkType.TEMPORARILY_UNMETERED)
                .setRequiresCharging(true)
                .build()
        )
            .addTag(TAG_FETCH_LATEST_NEWS)

        workManager.enqueueUniquePeriodicWork(
            FETCH_LATEST_NEWS_TASK,
            ExistingPeriodicWorkPolicy.KEEP,
            fetchNewsRequest.build()
        )
    }

    fun cancelFetchingNewsPeriodically() {
        workManager.cancelAllWorkByTag(TAG_FETCH_LATEST_NEWS)
    }
}

```

## UI

应用的界面 (UI) 就是您在屏幕上所看到的内容 (文本、图片、按钮和许多其他类型的元素) 及其在屏幕上的布局方式.

### 界面状态保存

### 临时存放

Jetpack Compose 可以使用在项目的  Android 自动生成的 `R`  类中通过资源 ID 访问 Android 项目中定义的资源.

- `painterResource()`  函数会加载可绘制图片资源, 并将资源 ID (在本例中为  `R.drawable.androidparty` ) 作为实参.
- `stringResource()`

`onCreate()`  函数中的  [setContent()](https://developer.android.com/reference/kotlin/androidx/compose/ui/platform/ComposeView?hl=zh-cn#setContent(kotlin.Function0))[setContent()](https://developer.android.com/reference/kotlin/androidx/compose/ui/platform/ComposeView?hl=zh-cn#setContent(kotlin.Function0))  函数用于通过可组合函数定义布局.

可组合函数 Jetpack Compose 是用于构建 Android 界面的新款工具包. 任何标有  `@Composable`  注解的函数都可通过  `setContent()`  函数或其他可组合函数进行调用. 该注解可告知 Kotlin 编译器 Jetpack Compose 使用的这个函数会生成 UI.

注解

```kotlin
@Composable
@Preview
```

修饰符 [Modifier](https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier?hl=zh-cn)[Modifier](https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier?hl=zh-cn)  用于扩充或修饰可组合项, 如修饰组件的布局.

- 内边距修饰符 (`Modifier.padding`) 在  `Text`  可组合项的周围添加空间.

```kotlin
Modifier.padding(
    start = 16.dp,
    top = 16.dp,
    end = 16.dp,
    bottom = 16.dp
)

Modifier
    .padding(16.dp)
    .align(alignment = Alignment.End)
```

- 背景颜色修饰符 `Modifier.background`

![_](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-add-images/img/df69881d07b064d0.gif?hl=zh-cn)

基本标准布局元素是  `Column`、`Row,`  和  `Box`.

- [Box](https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/package-summary?hl=zh-cn#Box(androidx.compose.ui.Modifier,androidx.compose.ui.Alignment,kotlin.Boolean,kotlin.Function1))[Box](https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/package-summary?hl=zh-cn#Box(androidx.compose.ui.Modifier,androidx.compose.ui.Alignment,kotlin.Boolean,kotlin.Function1))  布局是 Compose 中的标准布局元素之一. 使用  `Box`  布局可将元素堆叠在一起. `Box`  布局还可用于配置它所包含的元素的特定对齐方式.

应用在某些情况下可能会被翻译成其他语言, 一些固定的 `String`  数据类型可以提取到资源文件中进行管理, 避免硬编码导致无法进行翻译.

@JvmOverloads constructor 用于自动在 java 中生成各种重载的构造函数

[ConstraintLayout 之 ConstraintSet - enzo 的博客](https://enzowyf.github.io/constraintset.html)

// 设置控件尺寸  
// constrainWidth/constrainHeight  
// constrainDefaultWidth/constrainDefaultHeight  
// constrainMaxWidth/constrainMaxHeight  
// constrainMinWidth/constrainMinHeight

// 设置控件间直接约束关系

// 控件 start 的某边与 end 的某边对齐, margin 用于设置边与边中间间距  
// connect(int startID, int startSide, int endID, int endSide, int margin)  
// connect(int startID, int startSide, int endID, int endSide)

// 控件 center 置于另两个控件 first 和 second 之间, bias(0~1) 用于设置位置偏移比例  
// center(int centerID, int firstID, int firstSide, int firstMargin, int secondID, int secondSide, int secondMargin, float bias)  
// 控件 center 水平居中于另一个控件 centerID, leftId/rightId 用于设置左右边界控件  
// centerHorizontally(int centerID, int leftId, int leftSide, int leftMargin, int rightId, int rightSide, int rightMargin, float bias)

// 方向: ConstraintSet.TOP/BOTTOM/START/END/LEFT/RIGHT/BASELINE(TextView)

// 控件 viewId 与 toView 水平居中  
// centerHorizontally(int viewId, int toView)  
// 控件 viewId 与 toView 垂直居中  
// centerVertically(int viewId, int toView)

// 修改控件属性  
// setVisibility/setAlpha/setRotation  
// setRotationX/setRotationY  
// setScaleX/setScaleY/setTransformPivot/setTransformPivotX/setTransformPivotY  
// setTranslation/setTranslationX/setTranslationY/setTranslationZ  
// setElevation

RecyclerView ( `RecyclerView` 和 `RecyclerView.LayoutManager` )

- 数据驱动：需要一个数据源来提供要显示的数据, 见 `RecyclerView.Adapter` 和 `RecyclerView.ViewHolder`
- 可重用性：支持视图的重用机制, 通过重用池来减少内存开销, 见 `onCreateViewHolder` 和 `onBindViewHolder`
- 布局管理：支持多种布局, 通过不同的布局管理器来控制视图的显示方式 (如网格、列表等) , 见 `LinearLayoutManager` 、 `GridLayoutManager` 、 `StaggeredGridLayoutManager`
- 自定义单元格：允许自定义单元格, 以便显示复杂的内容. 创建自定义的 `ViewHolder` 子类, 然后在 `Adapter` 中使用这个 `ViewHolder`, 在 `onCreateViewHolder` 和 `onBindViewHolder` 方法中绑定 `ViewHolder`.

### 基础组件

`AbsListView` 是一个抽象类, 不能用作应用程序布局中的 `View` 元素, 尽管您可以将其用作 `Base Class` 来实现您自己的 `View`. 在  
`AbsoluteLayout` 要被弃用了. 允许您指定其子级的确切位置 (x/y 坐标) 的布局. 与没有绝对定位的其他类型的布局相比, 绝对布局不太灵活且更难以维护.  
`AbsSeekBar` 和 `AbsSpinner` 全是抽象类.  
`ActionMenuView`, 操作菜单视图, 支持接收菜单项单击事件的接口(看到有人当做底部菜单栏使用的).  
`Adapter` 适配器就像数据源和用户界面之间的桥梁. 它从各种数据源读取数据, 将其转换为 `View` 对象, 并将其提供给链接的 `Adapter` 视图以创建 UI 组件.  
`AdapterView` 适配器视图可用于以列表或网格等形式有效地显示由适配器提供的大量数据. `Adapter` 获取数据并根据该数据创建一个 `View , 然后将该`View `提供给`AdapterView `. 然后`AdapterView `以想要的方式显示数据.`AlphabetIndexer `实现`SectionIndexer `接口的适配器的辅助类. 如果适配器中的项目通过简单的基于字母的排序进行排序, 则此类提供了一种使用二分搜索对大型列表进行快速索引的方法. 在`ListView `或`RecyclerView `中, 可以使用`AlphabetIndexer `来为列表提供分节导航.`AnalogClock `被弃用了`BaseAdapter`

- `ArrayAdapter` 通过此类可以从数组获取 `AdapterView`,
- `CursorAdapter`
- `SimpleAdapter`
- `ResourceCursorAdapter`
- `SimpleCursorAdapter`

`AutoCompleteTextView` 可编辑的文本视图, 在用户键入时自动显示完成建议. 建议列表显示在下拉菜单中, 用户可以从中选择一个项目来替换编辑框的内容. 建议列表是从数据适配器获取的  
`CalendarView` 用于显示和选择日期的日历小部件.  
`CheckBox`, 创建一个复选框选项, 每个复选框都是单独管理的, 必须为每个复选框注册点击监听器.  
`CheckedTextView`, 扩展 `TextView` 支持 `Checkable` 界面和显示. 也就是说文本支持选中后复选支持.  
`Chronometer` 基于 `TextView` 实现的计时器. 控制和展示计时时间.  
`CompoundButton` 复合按钮, 抽象类, 具有两种状态的按钮, 选中和未选中(开和关). 当按下或单击按钮时, 状态会自动更改. 主要派生出了 `CheckBox`, `RadioButton`, `Switch`, `ToggleButton`  
`DialerFilter` 被弃用  
`DigitalClock` 被弃用  
`EdgeEffect` 用于在可滑动控件边缘提供视觉反馈, 例如 `ScrollView` 在滑动到边界时显示的弧形颜色效果.  
`EditText` 用于输入和修改文本的用户界面元素, 支持输入类型选择, 文本类型, 密码类型等.  
`ExpandableListView` 可扩展列表视图, 显示垂直滚动的两级列表中的项目的视图, 与 `ListView` 的不同之处在于允许两个级别：可以单独展开以显示其子级的组.  
`Filter` 过滤器使用过滤模式来异步约束数据, 细节待定.  
`FrameLayout` 框架布局, 可以添加多个子视图进行叠放, 新添加的视图, 会覆盖在旧视图上面.  
`Gallery` 被弃用了. 可以参考新的 `HorizontalScrollView` 和 `ViewPager`  
`GridLayout` 矩形网格布局, 可以指定网格的列数和行数. `GridLayout` 基本上将其子级放置在矩形网格中. 该网格有一组许多细线, 将视图区域分隔成单元格, N 列的网格, 那么我们将有 N+1 个从 0 开始的网格索引. 子项占据一个或多个连续的单元格, 由其 `rowSpec` 和 `columnSpec` 布局参数定义, 占据相同单元格的子项, 可能会产生重叠.  
`GridView` 网格视图, 将多个子项显示在支持滚动的二维网格的视图. 数据通过 Adapter 适配器与 GridView 连接, 并将每条数据插入到将在 GridView 中显示的适当项目中.  
`HeaderViewListAdapter`, 一个基类, 目前不需要学习.  
`HorizontalScrollView` 水平滚动视图, 也只支持水平滚动, 需要在其中放置一个包含要滚动的全部内容的子项, 在水平方向上, 呈现用户可以滚动浏览的顶级项目的水平数组.  
`ImageButton` 图像按钮, 显示一个带有图像 (而不是文本) 的按钮, 用户可以按下或单击该按钮.  
`ImageSwitcher` 图像切换器, 当在两个 `ImageView` 上设置新图像时, `ViewSwitcher` 在两个 `ImageView` 之间切换. 添加到 `ImageSwitcher` 的视图必须都是 `ImageView`.  
`ImageView` 图像视图, 显示图片资源, 例如 `Bitmap` 或者 `Drawable` 资源. I  
`LinearLayout` 线性布局, 将其他视图水平排列在单列中或垂直排列在单行中的布局.  
`ListPopupWindow` 列表弹出窗口, `ListPopupWindow` 将自身锚定到主视图并显示一个选项列表, 能够显示 `ListAdapter` 中的项目. , 进行包括定位、滚动父项以适应下拉菜单、与 IME (如果存在) 进行合理交互等.  
`ListView` 显示可垂直滚动的视图集合, 其中每个视图都位于列表中前一个视图的正下方.  
`Magnifier` 放大镜, `Android` 放大镜小部件. 可由附加到窗口的任何视图使用.  
`MediaController` 媒体控制器. 如果拥有 “android.permission.MEDIA_CONTENT_CONTROL” 权限或者是启用的通知侦听器, 或者直接从会话所有者获取 `MediaSession.Token`, 则可以通过 `MediaSessionManager` 创建 `MediaController`. 允许应用程序与正在进行的媒体会话交互. 媒体按钮和其他命令可以发送到会话. 可以注册回调以接收来自会话的更新, 例如元数据和播放状态变化.  
`MultiAutoCompleteTextView`,可编辑的文本视图, 扩展 `AutoCompleteTextView`, 可以显示用户正在键入的文本子字符串的补全建议, 而不只是整个内容. `AutoCompleteTextView` 仅提供有关整个文本的建议. 但是 `MultiAutoCompleteTextView` 为文本的子字符串提供了多种建议.  
`NumberPicker` 数字选择器, 一个小部件, 使用户能够从预定义范围中选择一个数字, 支持显示为可编辑输入字段, 上面有一个递增按钮, 下面有一个递减按钮. 也支持将当前值显示为可编辑输入字段, 上面的值较小, 下面的值较大. 点击较小或较大的值可以通过向上或向下动画数轴来选择该值, 以使所选值成为当前值. 向上或向下滑动允许当前值多次递增或递减. 长按较小和较大值还可以快速更改当前值. 点击当前值可以输入所需的值. 还支持将当前值显示为滚动垂直选择器, 所选值位于中心, 上方和下方是前一个和后一个数字, 并由分隔线分隔. 通过垂直滑动来更改该值.  
`OverScroller` 过滚, 封装了滚动能力, 同时支持超出滚动操作范围的能力.  
`PopupMenu` 弹出菜单, `PopupMenu` 在锚定到视图的模式弹出窗口中显示菜单. 如果有空间, 弹出窗口将出现在锚视图下方；如果没有空间, 则弹出窗口将出现在锚视图上方. 如果 `IME` 可见, 则弹出窗口不会与其重叠, 直到触摸它为止. 触摸弹出窗口外部会将其关闭.  
`PopupWindow` 弹出窗口. 此类表示可用于显示任意视图的弹出窗口. 弹出窗口是一个浮动容器, 出现在当前活动的顶部.  
`ProgressBar` 进度条. 指示操作进度的用户界面元素. 进度条支持两种表示进度的模式：确定和不确定. 不确定模式是进度条的默认模式, 显示循环动画, 但不指示具体的进度量. 当想要显示已发生特定数量的进度时, 请对进度栏使用确定模式. 例如, 正在检索的文件的剩余百分比、写入数据库的批次中的记录数量或正在播放的音频文件的剩余百分比.  
`QuickContactBadge`, 显示为一个小徽章, 用户单击该徽章即可快速创建联系人, 例如将电话号码或电子邮件添加到联系人列表.

- AbsListView
- AbsListView.LayoutParams
- AbsoluteLayout
- AbsoluteLayout.LayoutParams
- AbsSeekBar
- AbsSpinner
- ActionMenuView

    - ActionMenuView.LayoutParams

- AdapterView
- AdapterView.AdapterContextMenuInfo
- AdapterViewAnimator
- AdapterViewFlipper
- AlphabetIndexer
- AnalogClock
- ArrayAdapter
- AutoCompleteTextView
- BaseAdapter
- BaseExpandableListAdapter
- Button
- CalendarView
- CheckBox
- CheckedTextView
- Chronometer
- CompoundButton
- CursorAdapter
- CursorTreeAdapter
- DatePicker
- DialerFilter
- DigitalClock
- EdgeEffect
- EditText
- ExpandableListView

    - ExpandableListView.ExpandableListContextMenuInfo

- Filter

    - Filter.FilterResults

- FrameLayout

    - FrameLayout.LayoutParams

- Gallery

    - Gallery.LayoutParams

- GridLayout

    - GridLayout.Alignment
    - GridLayout.LayoutParams
    - GridLayout.Spec

- GridView
- HeaderViewListAdapter
- HorizontalScrollView
- ImageButton
- ImageSwitcher
- ImageView
- LinearLayout

    - LinearLayout.LayoutParams

- ListPopupWindow
- ListView

    - ListView.FixedViewInfo

- Magnifier

    - Magnifier.Builder

- MediaController
- MultiAutoCompleteTextView

    - MultiAutoCompleteTextView.CommaTokenizer

- NumberPicker
- OverScroller
- PopupMenu
- PopupWindow
- ProgressBar
- QuickContactBadge
- RadioButton
- RadioGroup

    - RadioGroup.LayoutParams

- RatingBar
- RelativeLayout

    - RelativeLayout.LayoutParams

- RemoteViews

    - RemoteViews.DrawInstructions
    - RemoteViews.DrawInstructions.Builder
    - RemoteViews.RemoteCollectionItems
    - RemoteViews.RemoteCollectionItems.Builder
    - RemoteViews.RemoteResponse
    - RemoteViews.RemoteViewOutlineProvider

- RemoteViewsService
- ResourceCursorAdapter
- ResourceCursorTreeAdapter
- Scroller
- ScrollView
- SearchView
- SeekBar
- ShareActionProvider
- SimpleAdapter
- SimpleCursorAdapter
- SimpleCursorTreeAdapter
- SimpleExpandableListAdapter
- SlidingDrawer
- Space
- Spinner
- StackView
- Switch
- TabHost

    - TabHost.TabSpec

- TableLayout

    - TableLayout.LayoutParams

- TableRow

    - TableRow.LayoutParams

- TabWidget
- TextClock
- TextSwitcher
- TextView

    - TextView.SavedState

- TimePicker
- Toast

    - Toast.Callback

- ToggleButton
- Toolbar

    - Toolbar.LayoutParams

- TwoLineListItem
- VideoView
- ViewAnimator
- ViewFlipper
- ViewSwitcher
- ZoomButton
- ZoomButtonsController
- ZoomControls
- InlineContentView
- InlinePresentationSpec

    - InlinePresentationSpec.Builder

### androidx 扩展组件

- ActionBar

    - ActionBar.LayoutParams
    - ActionBar.Tab

- ActionBarDrawerToggle
- AlertDialog

    - AlertDialog.Builder

- AppCompatActivity
- AppCompatDelegate
- AppCompatDialog
- AppCompatDialogFragment
- AppCompatViewInflater
- AppLocalesMetadataHolderService
- ActionMenuView

    - ActionMenuView.LayoutParams

- AppCompatAutoCompleteTextView
- AppCompatButton
- AppCompatCheckBox
- AppCompatCheckedTextView
- AppCompatEditText
- AppCompatImageButton
- AppCompatImageView
- AppCompatMultiAutoCompleteTextView
- AppCompatRadioButton
- AppCompatRatingBar
- AppCompatSeekBar
- AppCompatSpinner
- AppCompatTextView
- AppCompatToggleButton
- LinearLayoutCompat

    - LinearLayoutCompat.LayoutParams

- ListPopupWindow
- PopupMenu
- SearchView
- ShareActionProvider
- SwitchCompat
- ThemedSpinnerAdapter.Helper
- Toolbar

    - Toolbar.LayoutParams
    - Toolbar.SavedState

- TooltipCompat

### androidx 碎片组件(Fragment)

`Fragment`是 `Activity` 中使用的一种可重用 UI 组件, 可以在 `Activity` 中被添加、替换、移除, 也可以在 `Fragment` 中嵌套其他 `Fragment`, 有自己的生命周期, 可以与 `Activity` 共享生命周期.

- `Fragment` 生命周期回调方法: `onCreate()` , `onCreateView()` , `onViewCreated()` , `onViewStateRestored()` , `onStart()` , `onResume()` , `onPause()` , `onStop()` , `onSaveInstanceState()` , `onDestroyView()` , `onDestroy()`
- `Fragment` 生命周期状态: `CREATED`, `STARTED`, `RESUMED`, `DESTROYED`. 可以由 `getLifecycle().getCurrentState()` 获取当前状态
- `Fragment` 视图状态: `INITIALIZED` , `CREATED` , `STARTED` , `RESUMED` , `DESTROYED`. 可以由 `getViewLifecycleOwner().getLifecycle().getCurrentState()` 获取当前状态

实际开发中, `Fragment` 需要一个托管它的视图容器, 通常是一个 `FrameLayout` 等布局容器. 新的 API 提供了 `FragmentContainerView` 来代替 `FrameLayout`, 支持更好的视觉效果设置, 和额外的编辑器功能.

可以根据不同的场景获取不同的 `FragmentManager` 管理实例, 来管理场景内 `Fragment` 的添加、替换、移除等操作. `FragmentManager` 通过事务(`FragmentTransaction`) 和回退栈(`BackStack`) 来管理 `Fragment` 的状态和生命周期.

回退栈是一个后进先出的栈, 用于存储 `Fragment` 的状. 在应用的任意时刻, 只能有一个 `FragmentManager` 可以控制 `Fragment` 的回退栈, 所以在多 `Fragment` 的情况下, 需要使用 `setPrimaryNavigationFragment()` 方法在不同的导航片段之间切换主要导航控制权, 以便正确管理回退栈. 吃外如果需要支持多个回退栈, 可以使用 `saveBackStack()` 和 `restoreBackStack()` 方法来保存和恢复回退栈, 比如在导航栏切换时.

事务是一组针对 `Fragment`的操作集合, 通过 `beginTransaction()` 或 kotlin 扩展方法 `commit` 来创建和提交事务, 可以包括任意数量的操作. 事务执行时可以通过 `addToBackStack()` 方法在回退栈中保存事务, 这样可以通过 `popBackStack()` 方法来回退到上一个状态. 没添加到回退栈的事务会被立即执行, 但不会保存状态, 比如删除任务会立即删除和销毁, 无法回撤.

如果设备发生了配置变化 (如屏幕旋转) , Activity 及其所有 Fragment 都会被销毁并重新创建, 此时需要注意 `Fragment` 的实例初始化问题.

- Fragment

    - DialogFragment
    - PreferenceFragmentCompat
    - ListFragment

```kotlin
class MyFragment : Fragment() {
    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        return inflater.inflate(R.layout.fragment_my, container, false)
    }
}

class MyActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        if (savedInstanceState == null) {
            supportFragmentManager.beginTransaction()
                .add(R.id.fragment_container, MyFragment())
                .commit()
            // 或者
            supportFragmentManager.commit {
                add<MyFragment>(R.id.fragment_container)
            }
        }
    }
}
```

- FragmentContainer: 一个抽象类, 用于管理 Fragment 的容器, 通常是一个 ViewGroup
- FragmentContainerView: 一个 ViewGroup, 用于管理 Fragment 的容器
- FragmentManager:

    - 在 Activity 中通过 `getSupportFragmentManager()` 获取管理实例
    - 在 Fragment 中通过 `getChildFragmentManager()` 获取管理实例
    - 在 Child Fragment 中通过 `getParentFragmentManager()` 获取管理实例
    - 通过 `beginTransaction()` 创建事务, 类型为 `FragmentTransaction`
    - 通过 `commit()` 提交事务
    - 通过 `popBackStack()` 弹出回退栈
    - 通过 `addToBackStack()` 添加到回退栈
    - 通过 `add`, `replace`, `remove`, `hide`, `show` 等方法操作 Fragment
    - 通过 `findFragmentById()` 和 `findFragmentByTag()` 查找 Fragment
    - 通过 `getFragments()` 获取当前所有 Fragment
    - 通过 `setReorderingAllowed()` 设置是否允许事务操作的重新排序
    - 通过 `setCustomAnimations` 设置自定义动画, 应用于调用位置后续的所有 `Fragment` 操作

        - `setCustomAnimations(enter: Int, exit: Int, popEnter: Int, popExit: Int)`

- Fragment.SavedState
- FragmentActivity
- FragmentController
- FragmentFactory: 用于创建 Fragment 实例的工厂, 可以通过自定义工厂来控制 Fragment 的实例创建过程. 默认情况下, Fragment 会通过反射机制创建实例, 通过 `FragmentFactory` 可以自定义创建逻辑.
- FragmentHostCallback
- FragmentKt
- FragmentManager.FragmentLifecycleCallbacks
- FragmentManagerKt
- FragmentManagerNonConfig
- FragmentPagerAdapter
- FragmentStatePagerAdapter
- FragmentTabHost
- FragmentTransaction
- FragmentTransactionKt
- FragmentViewModelLazyKt
- ViewKt

```kotlin
class MainActivity : AppCompatActivity() {
    // 创建 Fragment 实例
    val fragment = MyFragment()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        if (savedInstanceState == null) {

            supportFragmentManager.commit {
                setReorderingAllowed(true)
                add<MyFragment>(R.id.fragment_container_view)
            }
        }
    }
}
```

### androidx 导航组件(Navigation)

特点:

- 固定起始目的地
- 通过堆栈管理目的地
- 向上和后退按钮功能一致
- 深度链接支持(深度链接时, 现有返回堆栈都将被删除, 基于导航图重建新的返回堆栈)

组成:

- Host: `NavHostFragment` 和 `NavHost`, 用来存储和展示所有导航目的地对象的 `Fragment` 容器组件, 使用时需要手动指定导航图

    - `navGraph` 属性绑定导航图
    - `defaultNavHost` 属性设置为 true, 以便使得此导航组件首先处理系统返回键事件.

- Graph: `NavGraph`, 定义导航目的地连接关系的数据结构, 构成一个导航图

    - 目的地类型: `fragment`, `activity`, `dialog`.

        - `fragment`, 目的对象充满整个 Host 区域
        - `activity`, 退出导航图所在的 `Activity`, 启动一个新的 `Activity`
        - `dialog`, 展示在之前的内容上方

- Controller: `NavController`, 管理目的地之间导航, 处理深层链接, 处理返回堆栈等的协调员

    - 保存导航图并公开允许您的应用程序在图中的目的地之间移动的方法
    - 使用导航组件时，您可以使用 NavController 类创建导航控制器。 NavController 是中央导航 API。它跟踪用户访问过的目的地，并允许用户在目的地之间移动。

- Destination: `NavDestination`, 导航图中的节点, 通常在构建导航图时创建
- Route: 任何可序列化的数据类型, 通过 Route 进行导航到达目的地

目的地类型有三种: `Hosted` , `Dialog` , `Activity`

- `Hosted` 会使得目的内容占满整个导航内容区域
- `Dialog` 会使得目的内容展示在之前的内容上方
- `Activity` 会退出导航图所在的 Activity, 启动一个与导航组件分开管理的新 Android 活动

### androidx 分页组件(paging)

### 自定义视图

> [!cite]
>
> [Android 事件分发机制完全解析](https://blog.csdn.net/guolin_blog/article/details/9097463)

通常的自定义 View 流程:

- 继承自 `View` 或者 `ViewGroup` 类

```kotlin
/**
 * 自定义 View
 * params context 应用上下文
 * params attrs 属性集合, 用于在 xml 中使用自定义组件时, 为组件传递自定义属性(不使用时, 可以传递 null)
 * params defStyleAttr 默认样式, 用于在 xml 中使用自定义组件时, 为组件传递默认样式. 可以通过在 xml 中设置 style 属性来覆盖默认样式.
 */
class MyView(context: Context, attrs: AttributeSet, defStyleAttr: Int) : View(context, attrs, defStyleAttr) {
    // 1. 定义属性
    private var mText: String = ""

    // 2. 初始化属性
    init {
        val typedArray = context.obtainStyledAttributes(attrs, R.styleable.MyView, defStyleAttr, 0)
        mText = typedArray.getString(R.styleable.MyView_text) ?: ""
        typedArray.recycle()
    }
}

// 使用
<com.example.MyView
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    app:text="Hello World!" />

val myView = MyView(context).apply {
    text = "Hello World!"
    layoutParams = ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT)
}
```

- 重写 `override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int)` 方法, 在其中测量自定义 View 的大小
- 重写 `override fun onDraw(canvas: Canvas?)` 方法, 在其中绘制自定义 View 的内容
- 重写 `override fun onLayout(changed: Boolean, left: Int, top: Int, right: Int, bottom: Int)` 方法, 在其中布局自定义 View 的子 View
- 重写 `override fun onTouchEvent(event: MotionEvent?): Boolean` 方法, 在其中处理自定义 View 的触摸事件

#### `onMeasure` 方法

> [!cite]
>
> [onMeasure 详解](https://blog.csdn.net/dmk877/article/details/49558367)

每个视图都有一个 `onMeasure` 方法, 用于测量视图的大小, 并通过 `setMeasuredDimension(width, height)` 方法设置视图的最终大小. 视图的大小由两部分组成: 宽度和高度, 其最终大小会受到父视图的测量要求 `MeasureSpec`(大小和模式), 视图自身的 `LayoutParams` 以及视图内容等因素的影响.

- `MeasureSpec.EXACTLY` 精确模式, 视图大小是确定的, 由 `MeasureSpec.getSize()` 获取. 对应布局属性 `match_parent` 或者 `具体数值dp`
- `MeasureSpec.AT_MOST` 最大模式, 视图大小不能超过 `MeasureSpec.getSize()`, 通常是父视图的大小. 对应布局属性 `wrap_content`.
- `MeasureSpec.UNSPECIFIED` 未指定模式, 视图大小不受限制, 可以任意大小. 通常用于 `ScrollView` 中的子视图.

```java
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),
            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));
}

private void setMeasuredDimension(int measuredWidth, int measuredHeight) {
    mMeasuredWidth = measuredWidth;
    mMeasuredHeight = measuredHeight;
}
```

最根源的父视图是 `Activity` 绑定的 `Window` 视窗内的 `DecorView`. `Window` 视窗用于包含和管理应用的窗口内容有关的所有视图; `DecorView` 是一个继承自 `FrameLayout` 类型的根布局, 它的大小一般是手机屏幕的大小.

```java
public class Activity ... { ...
    mWindow = new PhoneWindow(this, window, activityConfigCallback);
    public void setContentView(@LayoutRes int layoutResID) {
        mWindow.setContentView(layoutResID);
        initWindowDecorActionBar();
    }
}

public class PhoneWindow ... { ...
    public void setContentView(int layoutResID) {
        installDecor();
    }

    private void installDecor() {
        if (mDecor == null) {
            mDecor = new DecorView(context, -1, this, getAttributes());;
        }
        if (mContentParent == null) {
            ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);
            mContentParent = generateLayout(mDecor);
        }
    }
}
```

此外 `PhoneWindow` 又有一个 `mContentParent: FrameLayout` 容器, 用于存放实际的应用内容区域的视图, 大小通常是 `DecorView` 的大小减去状态栏和导航栏的高度.

`DecorView extends FrameLayout -> ViewGroup -> View` 也是个视图, 同时它也就有自己的 `onMeasure` 方法来测量自己的大小. 但是 `DecorView` 并没有父视图, 那么它的大小是怎么确定的呢?

首先每一个 `View` 都会通过 `measure(widthMeasureSpec, heightMeasureSpec)` 方法来测量自己的大小, 因此只需要搞清楚这里的 `widthMeasureSpec` 和 `heightMeasureSpec` 的来源即可. 这里需要去追溯到 `ViewRootImpl`.

在 `PhoneWindow` 创建的同时, 会创建一个 `ViewRootImpl` 对象自动与 `DecorView` 绑定, 用于管理当前窗口内部视图树内所有视图的绘制和事件分发. 而 `DecorView` 就可以通过 `getViewRootImpl()` 通过得到的 `ViewRootImpl` 对象来触发 `ViewRootImpl` 的 `performTraversals()` 方法来重新测量自己的大小.

```java
public class PhoneWindow ... { ...
    private void openPanel(final PanelFeatureState st, KeyEvent event) {
        ...
        final WindowManager wm = getWindowManager();
        wm.addView(st.decorView, lp);
        ...
    }
}

// WindowManagerImpl
public final class WindowManagerGlobal { ...
    public void addView(View view, ViewGroup.LayoutParams params, ...) {
        ViewRootImpl root;
        root = new ViewRootImpl(view.getContext(), display);
        mViews.add(view);
        mRoots.add(root);
        ...
    }
}
```

`ViewRootImpl` 会在自己的 `performTraversals()` 方法中计算 `DecorView` 需要的根测量规格 `childWidthMeasureSpec` 或 `childHeightMeasureSpec`.

简单来说这两个测量规格的计算取决于窗口的类型, 如果是特殊窗口类型, 直接使用设备的宽高, 如果是 `WRAP_CONTENT` 类型, 则扣除系统栏的高度后, 当前窗口在屏幕上显示的实际矩形区域, 其他情况直接使用 `WindowManager` 获取的屏幕尺寸. 具体的计算还有更多细节.

然后 `ViewRootImpl` 会利用计算好的根测量规格调用 `performMeasure()` 方法来执行 `DecorView` 的 `measure(...)` 方法, 从而使得 `DecorView` 根据根测量规格来测量自己的大小.

```java
public final class ViewRootImpl ... {
    private void performTraversals() {
        ...
        int desiredWindowWidth;
        int desiredWindowHeight;
        Rect frame = mWinFrame;
        if (mFirst) {
            final Configuration config = mContext.getResources().getConfiguration();
            if (shouldUseDisplaySize(lp)) {
                Point size = new Point();
                mDisplay.getRealSize(size);
                desiredWindowWidth = size.x;
                desiredWindowHeight = size.y;
            } else if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT
                    || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
                desiredWindowWidth = dipToPx(config.screenWidthDp);
                desiredWindowHeight = dipToPx(config.screenHeightDp);
            } else {
                desiredWindowWidth = frame.width();
                desiredWindowHeight = frame.height();
            }
        } else {
            desiredWindowWidth = frame.width();
            desiredWindowHeight = frame.height();
        }

        // Ask host how big it wants to be
        windowSizeMayChange |= measureHierarchy(mView, layoutParams, contextResources,
                desiredWindowWidth, desiredWindowHeight);
    }

    private boolean measureHierarchy(host, lp, res, desiredWindowWidth, desiredWindowHeight) {
        ...
        final DisplayMetrics packageMetrics = res.getDisplayMetrics();
            childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);
            childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);
            performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);
        ...
    }

    private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) {
        mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);
    }
}
```

其中 `measure(...)` 方法中有一个默认的根据测量规格计算大小的实现, 即 `onMeasure()` 方法, 它会直接使用所提供的测量规格提供的大小. (因为一般传入的模式不会是 `MeasureSpec.UNSPECIFIED`)

#### `onLayout` 方法

每个视图都有一个 `onLayout` 方法, 用于布局当前视图相对于父视图的位置, 并通过 `setFrame(left, top, right, bottom)` 方法设置视图的最终位置. 视图的位置由四个坐标值组成: 左上角的 x 坐标和 y 坐标, 右下角的 x 坐标和 y 坐标, 其最终位置取决于设置的坐标, 分别对应以下四个属性:

- `mLeft——View.getLeft()`: 当前视图的左边界到父视图的左边界的距离
- `mTop——View.getTop()`: 当前视图的顶部到父视图顶部的距离
- `mRight——View.getRight()`: 当前视图的右边界到父视图的左边界的距离
- ``mBottom——View.getBottom(): 当前视图的底部到父视图的顶部的距离

```java
public void layout(int l, int t, int r, int b) {
    ...
    int oldL = mLeft;
    int oldT = mTop;
    int oldB = mBottom;
    int oldR = mRight;
    boolean changed = setFrame(l, t, r, b);
    if (changed) {
        onLayout(changed, l, t, r, b);
    }
}

protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
}

protected boolean setFrame(int left, int top, int right, int bottom) {
    boolean changed = false;

    if (mLeft != left || mRight != right || mTop != top || mBottom != bottom) {
        changed = true;

        int oldWidth = mRight - mLeft;
        int oldHeight = mBottom - mTop;
        int newWidth = right - left;
        int newHeight = bottom - top;
        boolean sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight);

        invalidate(sizeChanged);

        mLeft = left;
        mTop = top;
        mRight = right;
        mBottom = bottom;
        mRenderNode.setLeftTopRightBottom(mLeft, mTop, mRight, mBottom);
    }
    return changed;
}


```

最根源的父视图是 `Activity` 绑定的 `Window` 视窗内的 `DecorView`. 与 `onMeasure` 方法的介绍类似, `DecorView` 可以通过触发绑定的 `ViewRootImpl` 对象的 `performTraversals()` 方法来重新布局自己的子视图. 默认的根布局区域就是 `onMeasure` 方法中确定的测量大小所占区域.

```java
public final class ViewRootImpl ... {
    private void performTraversals() {
        windowSizeMayChange |= measureHierarchy(mView, layoutParams, contextResources,
                desiredWindowWidth, desiredWindowHeight);

        if (mWidth != frame.width() || mHeight != frame.height()) {
            mWidth = frame.width();
            mHeight = frame.height();
        }
        performLayout(lp, mWidth, mHeight);
    }

    private void performLayoutWindowManager.LayoutParams lp, int desiredWindowWidth,
            int desiredWindowHeight {
        mView.layout(0, 0, mView.getMeasuredWidth(), mView.getMeasuredHeight());

        // 这里如果布局失败, 会尝试使用 desiredWindowWidth 和 desiredWindowHeight 参数重新计算视图大小, 并重新布局
    }
}
```

#### `onDraw` 方法

#### `invalidate` 方法

#### `dispatchTouchEvent` 方法

![_](https://img2018.cnblogs.com/blog/653161/201903/653161-20190321113420853-1974821013.png)

> [!cite]
> [Android 事件分发机制解析](https://juejin.cn/post/7102248400019521544")

每当用户触摸屏幕时, 系统会首先将触摸事件封装成 `MotionEvent` 对象, 并通过当前 `Activity` 将事件传递给 `DecorView` 中的根视图 `ViewGroup` 对象, 由根视图对象将此事件传递给其子视图, 一直到最终的目标视图.

包括 `Activity`, `Window`, `ViewGroup`, `View` 在内的所有类型对象都有一个 `dispatchTouchEvent` 方法, 用于分发触摸事件. 以下介绍每种对象的 `dispatchTouchEvent` 方法的实现逻辑:

- `Activity.dispatchTouchEvent`

    - 会首先在 `ACTION_DOWN` 事件到来时, 调用 `onUserInteraction` 方法, 默认为空实现, 可以重写此方法来记录用户交互事件
    - 然后将事件传递给绑定的 `Window` 对象处理, 如果事件被消费, 则返回 true, 否则继续去调用 `Activity.onTouchEvent` 方法.

- `Window.dispatchTouchEvent`

    - 一般会将事件直接传递给绑定的 `DecorView: ViewGroup` 对象处理.

- `ViewGroup.dispatchTouchEvent`

    - 进行设置输入一致性验证, 辅助功能标志, 安全性检查等. (不重要)
    - 清除所有之前的触摸目标, 并调用重置触摸状态, 防止之前的触摸事件影响当前事件.
    - 首先进行事件拦截的判断和处理. 事件拦截, 会导致事件不再向子视图传递.

        - 拦截条件 1: 1. 是 `ACTION_DOWN` 事件, 或者已有子视图在处理触摸事件; 2. `FLAG_DISALLOW_INTERCEPT` 标志未被设置为 true; 拦截成功后会调用 `onInterceptTouchEvent` 方法. 后续不会再进行向子视图的触摸事件分发.
        - 拦截条件 2: 不是 `ACTION_DOWN` 事件, 且没有任何子视图在处理当前触摸事件. 也视为拦截成功. 后续不会再进行向子视图的触摸事件分发.

    - 然后判断事件是否被取消, 通过 `FLAG_CANCEL_FORCED` 标志或事件类型是否是 `ACTION_CANCEL` 来判断. 事件被取消会导致事件不再向子视图传递.
    - 判断是否需要进行多点触控事件的处理, 通过 `FLAG_SPLIT_MOTION_EVENTS` 标志和是否不是鼠标事件来判断.
    - 进行事件分发判断和处理

        - 当事件是 `ACTION_DOWN`(初始按下) 或 `ACTION_POINTER_DOWN`(多点触控新增的手指按下) 或 `ACTION_HOVER_MOVE`(按下后移动) 时

            - 先逆序查找所有可以接收事件的子视图 (确认视图能否接收事件) 并调用子视图的 `dispatchTouchEvent` 方法传递事件, 直到有子视图消费事件或者事件被取消. 如果事件被消费了, 将可接收子视图保存在链表结构头部, 为多点触控事件做准备.
            - 如果没有子视图消费事件, 但是事件是多点触控和触摸后移动事件, 则尝试将要处理的事件分发给第一次按下时保存的所有可以处理事件的子视图链表中的尾部视图.

        - 如果是其他事件, 则直接从头到尾遍历所有可以接收事件的子视图, 并调用子视图的 `dispatchTouchEvent` 方法传递事件, 直到有子视图消费事件或者事件被取消.

- `View.dispatchTouchEvent`

    - 进行设置输入一致性验证, 辅助功能标志, 安全性检查等. (不重要)
    - 如果视图启用了滚动条并且事件是相关的滚动操作, 会先尝试处理滚动条拖拽事件 `handleScrollBarDragging` 方法, 消费后继续向下.
    - 如果设置了触摸事件监听器, 会先调用监听器的 `onTouch` 方法处理事件, 消费后直接返回.
    - 调用视图自身的 `onTouchEvent` 方法处理事件, 消费后直接返回.
    - 未消费事件, 返回 false.

##### `onTouchEvent` 方法

##### `onInterceptTouchEvent` 方法

##### `handleScrollBarDragging` 方法

##### `requestDisallowInterceptTouchEvent` 方法

通过设置 `FLAG_DISALLOW_INTERCEPT` 标志来控制父视图是否拦截触摸事件.

##### `setMotionEventSplittingEnabled` 方法

通过设置 `FLAG_SPLIT_MOTION_EVENTS` 标志来控制是否分割多点触控事件.

#### `getMeasuredWidth` 和 `getWidth` 方法的区别

- `getMeasureWidth()` 方法在 `measure()` 过程结束后就可以获得到它的值.
- `getWidth()` 方法要在 `layout()`过程结束后才能获取到.

自定义控件的时候在 `onLayout` 方法中一般采用 `getMeasuredWidth` 来获得控件的宽度.  
在除了 `onLayout` 之外的方法中采用 `getWidth` 方法来获取控件的宽度.

```java
public class View ... {
    public final int getMeasuredWidth() {
        return mMeasuredWidth & MEASURED_SIZE_MASK;
    }

    public final int getWidth() {
        return mRight - mLeft;
    }
}
```

#### TextPaint

`TextPaint` 是 `Paint` 的子类, 用于绘制文本的画笔. `TextPaint` 除了继承了 `Paint` 的所有属性和方法外, 还有一些专门用于绘制文本的属性和方法.

- `TextPaint.setTextSize(float textSize)`: 设置文本大小
- `TextPaint.setTypeface(Typeface typeface)`: 设置字体样式
- `TextPaint.setUnderlineText(boolean underlineText)`: 设置是否显示下划线
- `TextPaint.setStrikeThruText(boolean strikeThruText)`: 设置是否显示删除线

文本的基本信息 `Paint.FontMetrics`:

- `baseline`: 基线, 文本绘制的基准线, 用于绘制文本的起始位置
- `ascent`: 文本中字符的最高点到基线的距离
- `descent`: 文本中字符的最低点到基线的距离
- `top`: 文本中字符可以达到的最高点到基线的距离
- `leading`:

文本居中的计算方法: `int baseline = viewHeight / 2 + (fontMetrics.descent - fontMetrics.ascent) / 2 - fontMetrics.descent;`

### 动画和过渡

> [!cite]
>
> [https://developer.android.com/guide/fragments/animate](https://developer.android.com/guide/fragments/animate) > [Frame Animation（逐帧动画）](https://developer.aliyun.com/article/567019)

#### Frame 动画(帧动画)

帧动画: 通过一系列的图片帧来实现动画效果, 适用于帧数较少的动画效果

- 动画文件定义位置: `res/drawable/`
- 动画定义类型: `AnimationDrawable`
- 在 `Activity` 的 `onCreate()` 方法期间无法调用 `AnimationDrawable` 上调用的 `start()` 方法. 可以从 `Activity` 中的 `onStart()` 方法或者 `onWindowFocusChanged()` 方法中调用 `start()` 方法, 以避免动画启动时界面未绘制完成的问题.
- 使用时以 `ImageView` 为载体, 通过 `ImageView.setBackgroundResource()` 方法设置动画资源, 并通过将背景转换为 `AnimationDrawable` 对象来启动动画

```kotlin
// rocket_thrust_anim.xml
<?xml version="1.0" encoding="utf-8"?>
<animation-list
    xmlns:android="http://schemas.android.com/apk/res/android"
    <-- 动画是否只播放一次 --/>
    android:oneshot="false"
    >
    <item android:drawable="@drawable/rocket_thrust1" android:duration="200" />
    <item android:drawable="@drawable/rocket_thrust2" android:duration="200" />
    <item android:drawable="@drawable/rocket_thrust3" android:duration="200" />
</animation-list>

<ImageView
    android:id="@+id/rocket_image"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:background="@drawable/rocket_thrust_anim" />

// 使用
val rocketImage = findViewById<ImageView>(R.id.rocket_image).apply {
    setBackgroundResource(R.drawable.rocket_thrust)
    rocketAnimation = background as AnimationDrawable
}

rocketImage.setOnClickListener({ rocketAnimation.start() })
```

#### 插值器和求值器

每一个动画都有一个插值器和一个求值器, 插值器控制动画的进度, 求值器控制动画的属性值.

插值器（Interpolator）决定了动画的进度如何随时间变化. 时间是线性的, 但是动画的进度不一定是线性的, 插值器就是用来控制动画进度的, 在固定的时间内, 可以让它先快后慢, 先慢后快 或者提前到达终点进行回弹等.

默认可用的插值器:

- `@android:anim/linear_interpolator` | `LinearInterpolator`: 线性匀速
- `@android:anim/decelerate_interpolator` | `DecelerateInterpolator`: 减速
- `@android:anim/accelerate_interpolator` | `AccelerateInterpolator`: 加速
- `@android:anim/overshoot_interpolator` | `OvershootInterpolator`: 快速超出终点一小步后回弹到终点
- `@android:anim/anticipate_interpolator` | `AnticipateInterpolator`: 先回退一小步再加速
- `@android:anim/accelerate_decelerate_interpolator` | `AccelerateDecelerateInterpolator`: 先加速后减速
- `@android:anim/anticipate_overshoot_interpolator` | `AnticipateOvershootInterpolator`: 先回退一小步再加速, 最后超出重点一小步后回弹到终点
- `@android:anim/bounce_interpolator` | `BounceInterpolator`: 加速到终点后持续弹跳直至停止
- `@android:anim/cycle_interpolator` | `CycleInterpolator`: 周期运动
- `pathInterpolator` | `PathInterpolator`: 自定义路径插值器, 支持为二次贝塞尔曲线和三次贝塞尔曲线创建插值器

```xml
// 默认插值器的参数设置
<linearInterpolator xmlns:android="http://schemas.android.com/apk/res/android" /> // 无法自定义参数
<decelerate_interpolator xmlns:android="http://schemas.android.com/apk/res/android" android:factor="2" /> // 可设置减速因子
<accelerate_interpolator xmlns:android="http://schemas.android.com/apk/res/android" android:factor="2" /> // 可设置加速因子
<overshootInterpolator xmlns:android="http://schemas.android.com/apk/res/android" android:tension="2" /> // 可设置超出终点后的张力(回拉力)
<anticipate_interpolator xmlns:android="http://schemas.android.com/apk/res/android" android:tension="2" /> // 可设置回退一小步的张力
<accelerateDecelerateInterpolator xmlns:android="http://schemas.android.com/apk/res/android" /> // 无法自定义参数
<anticipateOvershootInterpolator xmlns:android="http://schemas.android.com/apk/res/android" android:tension="2" android:extraTension="2" /> // 可设置回退一小步的张力和超出终点后的张力
<bounceInterpolator xmlns:android="http://schemas.android.com/apk/res/android" /> // 无法自定义参数
<cycleInterpolator xmlns:android="http://schemas.android.com/apk/res/android" android:cycles="2" /> // 可设置周期数
<pathInterpolator xmlns:android="http://schemas.android.com/apk/res/android"
    android:controlX1="0.1" android:controlY1="0.2" android:controlX2="0.3" android:controlY2="0.4"
/> // 可设置路径插值器的控制点坐标
```

```kotlin
// 自定义插值器
class MyInterpolator : Interpolator {
    override fun getInterpolation(input: Float): Float {
        return input * input
    }
}

// 使用自定义插值器
val objectAnimator = ObjectAnimator.ofFloat(view, "translationX", 0f, 100f).apply {
    duration = 1000
    interpolator = MyInterpolator()
}
objectAnimator.start()

// 使用路径插值器
val path = Path().apply {
    moveTo(0f, 0f) // moveTo() 方法用于将画笔移动到指定位置
    lineTo(100f, 100f) // lineTo() 方法用于从当前位置画一条直线到指定位置
    cubicTo(100f, 0f, 200f, 200f, 300f, 100f) // cubicTo() 方法用于绘制三次贝塞尔曲线
    arcTo(0f, 0f, 100f, 100f, 0f, 270f, true) // arcTo() 方法用于绘制弧形
}
val pathInterpolator = PathInterpolator(path)
```

求值器（TypeEvaluator）决定了动画属性值在起始值和结束值之间随进度 (fraction) 而如何变化. 动画期间, 求值器会根据当前时间对应的动画进度来计算出当前属性值, 并将其传递给动画监听器, 从而实现动画效果.

默认可用的求值器:

- `IntEvaluator`: 用于整型属性值的求值
- `FloatEvaluator`: 用于浮点型属性值的求值
- `ArgbEvaluator`: 用于颜色属性值的求值
- `RectEvaluator`: 用于矩形属性值的求值
- `PointEvaluator`: 用于点属性值的求值
- `IntArrayEvaluator`: 用于整型数组属性值的求值
- `FloatArrayEvaluator`: 用于浮点型数组属性值的求值

```kotlin
// 自定义求值器
class PointFEvaluator : TypeEvaluator<PointF> {
    override fun evaluate(fraction: Float, startValue: PointF, endValue: PointF): PointF {
        val x = startValue.x + (endValue.x - startValue.x) * fraction
        val y = startValue.y + (endValue.y - startValue.y) * fraction
        return PointF(x, y)
    }
}

// 使用自定义求值器
val startPoint = PointF(0f, 0f)
val endPoint = PointF(500f, 500f)

val animator = ValueAnimator.ofObject(PointFEvaluator(), startPoint, endPoint)
animator.duration = 1000
animator.addUpdateListener { animation ->
    val point = animation.animatedValue as PointF
    view.translationX = point.x
    view.translationY = point.y
}
animator.start()
```

#### android.view.animation（视图动画, 补间动画, 平移, 缩放, 旋转, 透明度）

> [!cite]
>
> [Tween(补间动画)完全解析](https://blog.csdn.net/dmk877/article/details/51912104)

视图动画: 通过对视图的属性进行动画操作, 适用于简单的动画效果

- 动画文件定义位置: `res/anim/`
- 动画定义方式

  ```xml
  <translate xmlns:android="http://schemas.android.com/apk/res/android"
      // 平移动画
      android:fromXDelta="0" // 起始位置 x 坐标 (px值, 百分比值, 百分比 p 值)
      android:toXDelta="100" // 结束位置 x 坐标
      android:fromYDelta="0" // 起始位置 y 坐标
      android:toYDelta="100" // 结束位置 y 坐标
  
  // 百分比 p 值表示相对于父容器宽或高的百分比值, 0% 表示起始位置, 100% 表示结束位置
  />
  
  <scale xmlns:android="http://schemas.android.com/apk/res/android"
      // 缩放动画
      android:fromXScale="1.0" // 起始 x 缩放比例, 0-1 缩小, 1-∞ 放大
      android:toXScale="0.5" // 结束 x 缩放比例
      android:fromYScale="1.0" // 起始 y 缩放比例
      android:toYScale="0.5" // 结束 y 缩放比例
  
      android:pivotX="50%" // 视图缩放的中心 x 坐标 (px 值, 百分比值, 百分比 p 值)
      android:pivotY="50%" // 视图缩放的中心 y 坐标
  />
  
  <rotate xmlns:android="http://schemas.android.com/apk/res/android"
      // 旋转动画
      android:fromDegrees="0" // 起始角度
      android:toDegrees="360" // 结束角度
      android:pivotX="50%" // 旋转中心 x 坐标 (px 值, 百分比值, 百分比 p 值)
      android:pivotY="50%" // 旋转中心 y 坐标
  />
  
  <alpha xmlns:android="http://schemas.android.com/apk/res/android"
      // 透明度动画
      android:fromAlpha="1.0" // 起始透明度
      android:toAlpha="0.0" // 结束透明度
  />
  
  <set xmlns:android="http://schemas.android.com/apk/res/android"
      // 组合动画
      android:shareInterpolator="true" // 是否共享插值器, false 时需要为每个子动画设置插值器
      // 可以通过 startOffset 属性自定义每个动画开始前的延迟时间, 默认一起开始
  >
  
      <alpha
          ...
      />
  
      <scale
          ...
      />
  
      ...
  
  </set>
  
  <any
      // 通用属性
      android:duration="1000" // 动画持续时间
      android:startOffset="1000" // 动画开始前的延迟时间
      android:fillBefore="true" // 动画结束后是否回到初始状态, 默认为 true
      android:fillEnabled="true" // 是否启用 fillBefore, 默认为 true
      android:fillAfter="true" // 动画结束后是否保持结束状态, 默认为 false, 优先于 fillBefore
      android:repeatCount="infinite" // 动画重复次数, 默认为 0, 0 为不重复, -1 为无限重复
      android:repeatMode="reverse" // 动画重复模式, 默认为 restart, reverse 为反向重复
      android:interpolator="@android:anim/accelerate_decelerate_interpolator" // 动画插值器
  />
  ```

- 动画启动方式 (xml)

  ```kotlin
  
  // View
  val imageView = findViewById<ImageView>(R.id.image)
  val animation = AnimationUtils.loadAnimation(this, R.anim.bounce_animation)
  imageView.startAnimation(animation)
  
  // Fragment
  val fragmentManager = supportFragmentManager(Activity 情况下) | getParentFragmentManager()(Fragment 情况下)
  FragmentTransaction transaction = fragmentManager.beginTransaction();
  transaction.setCustomAnimations(R.anim.enter_animation, R.anim.exit_animation);
  transaction.replace(R.id.fragment_container, new MyFragment());
  transaction.addToBackStack(null)
  transaction.commit();
  
  // Activity
  val intent = Intent(context, TargetActivity::class.java)
  val options = ActivityOptions.makeCustomAnimation(context, R.anim.enter_anim, R.anim.exit_anim)
  startActivity(intent, options.toBundle())
  ```

- 动画启动方式(代码) 暂无

#### android.animation (属性动画)

属性动画: 通过对视图的属性进行动画操作, 适用于复杂的动画效果.

- 针对属性值进行动画操作, 因此适用于任何对象的任何属性, 而不仅限于平移, 缩放, 旋转, 透明度等.
- 动画操作可以针对于对象本身, 而不是如补间动画那样只是改变了视图对象的显示效果.
- 属性动画支持所有的通用属性, 如动画持续时间, 动画插值器等.
- 动画文件定义位置: `res/animator/`
- 使用时需要每个动画都需要绑定目标对象的属性名称, 并通过 `setTarget()` 方法绑定目标对象, 然后再通过 `start()` 方法启动动画.
- 23 之后的安卓版本可以使用 `PropertyValuesHolder` 和 `Keyframe` 来进阶定义动画效果, 比如为动画添加关键帧, 设置关键帧的插值器, 为 `objectAnimator` 添加多个属性值等.
- 对于修改后不自动触发 `invalidate()` 方法的属性, 需要手动调用 `invalidate()` 方法来刷新视图.
- 具有与视图动画几乎相同的通用属性, 如 `duration`, `startOffset`, `fillBefore`, `fillEnabled`, `fillAfter`, `repeatCount`, `repeatMode`, `interpolator` 等.

  ```xml
  <any
      // 通用属性
      android:duration="1000" // 动画持续时间
      android:startOffset="1000" // 动画开始前的延迟时间
      android:fillBefore="true" // 动画结束后是否回到初始状态, 默认为 true
      android:fillEnabled="true" // 是否启用 fillBefore, 默认为 true
      android:fillAfter="true" // 动画结束后是否保持结束状态, 默认为 false, 优先于 fillBefore
      android:repeatCount="infinite" // 动画重复次数, 默认为 0, 0 为不重复, -1 为无限重复
      android:repeatMode="reverse" // 动画重复模式, 默认为 restart, reverse 为反向重复
      android:interpolator="@android:anim/accelerate_decelerate_interpolator" // 动画插值器
  />
  ```

##### `ValueAnimator` 定义

构造时直接传入起始值, 中间值(可选, 可多个), 结束值. 使用时需要通过动画监听器来监听动画过程中属性值的变化, 并在监听器中根据当前属性值来更新目标对象的属性值(如视图的位置), 从而实现动画效果.

- 可以通过不同的工厂方法创建不同类型的 `ValueAnimator` 对象, 如 `ofInt()`, `ofFloat()`, `ofObject()`.

```kotlin
// 创建 ValueAnimator 对象
val valueAnimator = ValueAnimator.ofInt(0, 100)
val valueAnimator = ValueAnimator.ofFloat(0f, 100f)
val valueAnimator = ValueAnimator.ofObject(PointFEvaluator(), startPoint, endPoint)
```

```xml
<animator xmlns:android="http://schemas.android.com/apk/res/android"
    android:valueFrom="1"
    android:valueTo="0"
    android:valueType="floatType" | "intType" | "objectType"
/>
```

##### `ObjectAnimator` 定义

`ObjectAnimator` 是 `ValueAnimator` 的子类, 用于对对象的属性进行动画操作. 构造时需要传入目标对象, 属性名称, 起始值, 中间值(可选, 可多个), 结束值. 使用时直接调用 `start()` 方法启动动画.

- 对象属性必须可以 `get` 和 `set`. 例如, 如果属性名称是 `foo`, 则需要有一个 `getFoo()` 方法和一个 `setFoo()` 方法.

```kotlin
// 创建 ObjectAnimator 对象
val objectAnimator = ObjectAnimator.ofInt(view, "translationX", 0, 100)
val objectAnimator = ObjectAnimator.ofFloat(view, "translationX", 0f, 100f)
val objectAnimator = ObjectAnimator.ofObject(view, "point", PointFEvaluator(), startPoint, endPoint)
val path = Path().apply {
    arcTo(0f, 0f, 100f, 100f, 0f, 359f, true) // 一个圆形路径
}
val objectAnimator = ObjectAnimator.ofFloat(view, View.X, View.Y, path)
```

```xml
<objectAnimator xmlns:android="http://schemas.android.com/apk/res/android"
    android:propertyName="translationX" // 动画属性名称
    android:valueFrom="0" // 起始值
    android:valueTo="100" // 结束值
    android:valueType="floatType" | "intType" | "objectType"
/>
```

##### `TimeAnimator` 定义

`TimeAnimator` 是 `ValueAnimator` 的子类, 用于监听动画过程中的时间变化. 使用时需要通过动画监听器来监听动画过程中时间的变化, 并在监听器中根据当前时间来更新目标对象的属性值, 从而实现动画效果. 注意动画监听器有两种, 一种是专属 `TimeAnimator`的 `TimeListener` 用于监听动画过程中时间的变化, 另一种是 `AnimatorListener` 用于监听动画的开始, 结束, 取消, 重复等事件.

```kotlin
// 创建 TimeAnimator 对象
val animator = TimeAnimator().apply {
    // 添加动画监听器
    setTimeListener { animation, totalTime, deltaTime ->
        view.layout(deltaTime.toInt(), deltaTime.toInt(), deltaTime.toInt() + view.width, deltaTime.toInt() + view.height)
    }
}
```

##### `AnimatorSet` 定义

借助 `AnimatorSet` 可以将多个动画组合在一起, 并设置它们的执行顺序, 重复次数, 重复模式等. 使用时需要通过 `play()` 方法将多个动画添加到 `AnimatorSet` 中, 然后通过 `start()` 方法启动动画.

```kotlin
// 创建 ObjectAnimator 对象
val objectAnimator1 = ...
val objectAnimator2 = ...
val objectAnimator3 = ...
val objectAnimator4 = ...
val objectAnimator5 = ...

// 创建 AnimatorSet 对象
val animator = AnimatorSet().apply {
    // 手动设置动画执行顺序
    play(objectAnimator1).before(objectAnimator2)
    play(objectAnimator3).with(objectAnimator2)
    play(objectAnimator4).with(objectAnimator2)
    play(objectAnimator5).after(objectAnimator4)
    // 设置动画重复次数
    repeatCount = ValueAnimator.INFINITE
    // 设置动画重复模式
    repeatMode = ValueAnimator.REVERSE
}

// 嵌套和统一设置方法
val animatorSet1 = AnimatorSet().apply {
    playTogether(objectAnimator2, objectAnimator3, objectAnimator4)
}
val animator = AnimatorSet().apply {
    playSequentially(objectAnimator1, animatorSet1, objectAnimator5)
}
```

```xml
<set xmlns:android="http://schemas.android.com/apk/res/android"
    // 组合动画
    android:shareInterpolator="true" // 是否共享插值器, false 时需要为每个子动画设置插值器
    android:ordering="together" // 动画执行顺序, together 为同时执行, sequential 为顺序执行. 也可以通过 startOffset 属性自定义每个动画开始前的延迟时间
>

    <animate ... />
    <objectAnimator ... />
    <set ... />

</set>
```

##### 关键帧 (Keyframe)

关键帧: 用于为属性动画添加关键帧, 设置关键帧的插值器, 为 `objectAnimator` 添加多个属性值等.

- 关键帧使用方式 (xml)

  ```xml
  <animator xmlns:android="http://schemas.android.com/apk/res/android">
      <propertyValuesHolder>
          <keyframe android:fraction="0" android:value="1"/>
          <keyframe android:fraction=".2" android:value=".4"/>
          <keyframe android:fraction="1" android:value="0"/>
      </propertyValuesHolder>
  </animator>
  
  <objectAnimator xmlns:android="http://schemas.android.com/apk/res/android">
      <propertyValuesHolder android:propertyName="x" >
          <keyframe android:fraction="0" android:value="800" />
          <keyframe android:fraction=".2"
                  android:interpolator="@android:anim/accelerate_interpolator"
                  android:value="1000" />
          <keyframe android:fraction="1"
                  android:interpolator="@android:anim/accelerate_interpolator"
                  android:value="400" />
      </propertyValuesHolder>
      <propertyValuesHolder android:propertyName="y" >
          <keyframe/>
          <keyframe android:fraction=".2"
                  android:interpolator="@android:anim/accelerate_interpolator"
                  android:value="300"/>
          <keyframe android:interpolator="@android:anim/accelerate_interpolator"
                  android:value="1000" />
      </propertyValuesHolder>
  </objectAnimator>
  ```

- 关键帧使用方式 (代码)

  ```kotlin
  val keyframe1 = Keyframe.ofFloat(0f, 1f)
  val keyframe2 = Keyframe.ofFloat(0.2f, 0.4f)
  val keyframe3 = Keyframe.ofFloat(1f, 0f)
  
  val propertyValuesHolder = PropertyValuesHolder.ofKeyframe("scaleX", keyframe1, keyframe2, keyframe3)
  val animator = ValueAnimator.ofPropertyValuesHolder(propertyValuesHolder)
  
  val keyframe1 = Keyframe.ofFloat(0f, 800f)
  val keyframe2 = Keyframe.ofFloat(0.2f, 1000f)
  val keyframe3 = Keyframe.ofFloat(1f, 400f)
  val propertyValuesHolderX = PropertyValuesHolder.ofKeyframe("x", keyframe1, keyframe2, keyframe3)
  val keyframe1 = Keyframe.ofFloat(0f, 0f)
  val keyframe2 = Keyframe.ofFloat(0.2f, 300f)
  val keyframe3 = Keyframe.ofFloat(1f, 1000f)
  val propertyValuesHolderY = PropertyValuesHolder.ofKeyframe("y", keyframe1, keyframe2, keyframe3)
  val animator = ObjectAnimator.ofPropertyValuesHolder(tagetView, propertyValuesHolderX, propertyValuesHolderY)
  ```

##### 属性动画启动

- 动画监听器有两种, 一种是专属 `ValueAnimator`的 `AnimatorUpdateListener` 用于监听动画过程中属性值的变化, 另一种是 `AnimatorListener` 用于监听动画的开始, 结束, 取消, 重复等事件.

```kotlin

// 代码动画启动
val animator = ...
animator.start()

// xml 动画定义需要加载和启动
val animator = AnimatorInflater.loadAnimator(context, R.animator.animator_file) as ValueAnimator | ObjectAnimator | AnimatorSet
animator.setTarget(view)

animator.apply {
    // 设置动画持续时间
    duration = 1000
    // 设置动画插值器
    interpolator = AccelerateDecelerateInterpolator()
    // 添加动画监听器
    addUpdateListener {
        val value = it.animatedValue as Int | Float | PointF
        // 修改目标对象的属性值
    }

    addListener(object : AnimatorListener {
        // 重载方法
    })
}

animator.start()

// 布局动画启动

viewGroup = <LinearLayout android:animateLayoutChanges="true" > </LinearLayout> // xml
viewGroup = code && viewGroup.layoutTransition.enableTransitionType(LayoutTransition.CHANGING) // 代码

val layoutTransition = LayoutTransition()
layoutTransition.setAnimator(LayoutTransition.APPEARING, animator)
layoutTransition.setAnimator(LayoutTransition.DISAPPEARING, animator)
layoutTransition.setAnimator(LayoutTransition.CHANGE_APPEARING, animator)
layoutTransition.setAnimator(LayoutTransition.CHANGE_DISAPPEARING, animator)
layoutTransition.setAnimator(LayoutTransition.CHANGING, animator)
viewGroup.layoutTransition = layoutTransition

```

##### 针对视图的更简易的属性动画启动方式

```kotlin
// 代码动画启动
view.animate().translationX(100f).translationY(100f).rotation(360f).alpha(0.5f).setDuration(1000).start()
```

#### 矢量图动画

矢量图动画: 通过对矢量图的属性进行动画操作, 例如旋转它或更改路径数据以将其变形为不同的图像.

- 动画文件定义位置: `res/drawable/` & `res/animator/`
- 动画定义方式 (xml)

  ```xml
  <!-- res/drawable/vectordrawable.xml  定义矢量图 -->
  <vector xmlns:android="http://schemas.android.com/apk/res/android"
      android:height="64dp"
      android:width="64dp"
      android:viewportHeight="600"
      android:viewportWidth="600">
      <group
          android:name="rotationGroup"
          android:pivotX="300.0"
          android:pivotY="300.0"
          android:rotation="45.0" >
          <path
              android:name="v"
              android:fillColor="#000000"
              android:pathData="M300,70 l 0,-70 70,70 0,0 -70,70z" />
      </group>
  </vector>
  
  <!-- res/animator/animatorvectordrawable.xml  定义矢量图动画 -->
  <animated-vector xmlns:android="http://schemas.android.com/apk/res/android"
  android:drawable="@drawable/vectordrawable" >
      <target
          android:name="rotationGroup"
          android:animation="@animator/rotation" />
      <target
          android:name="v"
          android:animation="@animator/path_morph" />
  </animated-vector>
  
  <!-- res/animator/rotation.xml  定义旋转动画 -->
  <objectAnimator
      android:duration="6000"
      android:propertyName="rotation"
      android:valueFrom="0"
      android:valueTo="360" />
  
  <!-- res/animator/path_morph.xml  定义路径变形动画 -->
  <set xmlns:android="http://schemas.android.com/apk/res/android">
      <objectAnimator
          android:duration="3000"
          android:propertyName="pathData"
          android:valueFrom="M300,70 l 0,-70 70,70 0,0   -70,70z"
          android:valueTo="M300,70 l 0,-70 70,0  0,140 -70,0 z"
          android:valueType="pathType" />
  </set>
  ```

#### Transition (过渡动画)

过渡动画: 用于在两个视图之间进行动画切换, 适用于视图之间的切换效果.

#### 状态列表动画

状态列表动画: 用于在视图的不同状态之间进行动画切换, 适用于视图的状态切换效果.

- 动画文件定义位置: `res/xml/`
- 动画定义方式 (xml)

  ```xml
  <?xml version="1.0" encoding="utf-8"?>
  <selector xmlns:android="http://schemas.android.com/apk/res/android">
      <!-- the pressed state; increase x and y size to 150% -->
      <item android:state_pressed="true">
          <set>
              <objectAnimator android:propertyName="scaleX"
                  android:duration="@android:integer/config_shortAnimTime"
                  android:valueTo="1.5"
                  android:valueType="floatType"/>
              <objectAnimator android:propertyName="scaleY"
                  android:duration="@android:integer/config_shortAnimTime"
                  android:valueTo="1.5"
                  android:valueType="floatType"/>
          </set>
      </item>
      <!-- the default, non-pressed state; set x and y size to 100% -->
      <item android:state_pressed="false">
          <set>
              <objectAnimator android:propertyName="scaleX"
                  android:duration="@android:integer/config_shortAnimTime"
                  android:valueTo="1"
                  android:valueType="floatType"/>
              <objectAnimator android:propertyName="scaleY"
                  android:duration="@android:integer/config_shortAnimTime"
                  android:valueTo="1"
                  android:valueType="floatType"/>
          </set>
      </item>
  </selector>
  ```

- 动画定义方式 (代码)

  ```kotlin
  
  ```

- 动画启动方式 (xml)

  ```xml
  <Button android:stateListAnimator="@xml/animate_scale"
      ... />
  ```

- 动画启动方式 (代码)

  ```kotlin
  val button = findViewById<Button>(R.id.button)
  val stateListAnimator = AnimatorInflater.loadStateListAnimator(this, R.xml.animate_scale)
  button.stateListAnimator = stateListAnimator
  ```

#### 动画实用工具类(圆形揭示动画)

`ViewAnimationUtils` 提供了一些实用的方法来创建和操作动画.

- `createCircularReveal()`: 创建一个圆形揭示动画, 从一个视图的中心开始揭示到视图的边缘.

  ```kotlin
  val view = findViewById<View>(R.id.view)
  // 获取视图的中心坐标
  val cx = view.width / 2
  val cy = view.height / 2
  // 计算揭示动画的半径
  val initialRadius = Math.hypot(cx.toDouble(), cy.toDouble()).toFloat()
  val anim = ViewAnimationUtils.createCircularReveal(view, cx, cy, initialRadius, 0f)
  anim.addListener(object : AnimatorListenerAdapter() {
      override fun onAnimationStart(animation: Animator) {
          view.visibility = View.INVISIBLE
      }
  })
  anim.start()
  ```

#### 动态动画 (dynamicanimation)

`DynamicAnimation` 是一个用于创建动态动画的类, 用于模拟物理运动, 例如弹簧, 摩擦力等. `DynamicAnimation` 有两个子类, 分别是 `SpringAnimation` 和 `FlingAnimation`. `SpringAnimation` 用于模拟弹簧运动, `FlingAnimation` 用于模拟惯性运动.

- 需要引入额外的依赖库

  ```gradle
  dependencies {
      implementation 'androidx.dynamicanimation:dynamicanimation:1.0.0'
  }
  ```

- `ViewProperty` 用于指定需要进行动画操作的属性, 如 `TRANSLATION_X`, `TRANSLATION_Y`, `TRANSLATION_Z`, `ROTATION`, `ROTATION_X`, `ROTATION_Y`, `SCALE_X`, `SCALE_Y`, `X`, `Y`, `Z`, `ALPHA`.
- `FlingAnimation` 用于模拟惯性运动, 例如滑动效果.

  ```kotlin
  val view = findViewById<View>(R.id.view)
  // 计算触摸速度
  val velocityX = 1000f
  val maxScroll = 1000f
  val flingAnimation = FlingAnimation(view, DynamicAnimation.TRANSLATION_X)
  flingAnimation.setStartVelocity(velocityX) // 以每秒像素为单位的速度
  flingAnimation.setMinValue(0f)
  flingAnimation.setMaxValue(maxScroll)
  flingAnimation.setFriction(1.1f) // 摩擦力, 定义了动画中速度降低的速度
  flingAnimation.start()
  ```

- `SpringAnimation` 用于模拟弹簧运动, 例如弹簧的拉伸和压缩效果.

  ```kotlin
  val view = findViewById<View>(R.id.view)
  val springAnimation = SpringAnimation(view, DynamicAnimation.TRANSLATION_Y, 0f)
  springAnimation.spring.stiffness = SpringForce.STIFFNESS_LOW
  springAnimation.spring.dampingRatio = SpringForce.DAMPING_RATIO_HIGH_BOUNCY
  springAnimation.addUpdateListener { animation, value, velocity ->
      // 更新视图的属性值
  }
  springAnimation.addEndListener { animation, canceled, value, velocity ->
      // 动画结束时的回调
      flingAnimation.start()
  }
  springAnimation.start()
  ```

## 网络库(HttpURLConnection, OkHttp, Retrofit, 内部库)

网络请求库 = 网络请求 + 数据解析 + 线程切换(异步) + 异常处理

### HttpURLConnection

> [!TODO]

### OkHttp

> [!cite] > [【OkHttp】OkHttp Get 和 Post 请求 ( 同步 Get 请求 | 异步 Get 请求 | 同步 Post 请求 | 异步 Post 请求 )-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/2249988) > [网络请求框架 OkHttp3 全解系列 (一) ：OkHttp 的基本使用-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/1667338) > [由浅入深, 聊聊 OkHttp 的那些事(易懂, 不繁琐) - 掘金](https://juejin.cn/post/7199431845367922745?searchId=20240806152219108948FAF7C05048547D) > [Android 主流网络请求框架 OkHttp 全方位详析 - 掘金](https://juejin.cn/post/7345756317557817354?searchId=20240806152219108948FAF7C05048547D) > [从 OKHttp 框架看代码设计](https://juejin.cn/post/6844903449469943821?searchId=2024080615223180876F5097A608E5EACE) > [HTTP 客户端连接, 选择 HttpClient 还是 OkHttp？](https://juejin.cn/post/6844904040644476941?searchId=2024080615223180876F5097A608E5EACE) > [OkHttp 的完整指南](https://juejin.cn/post/7068162792154464264?searchId=2024080615223180876F5097A608E5EACE) > [雨露均沾的 OkHttp—WebSocket 长连接 (使用篇) - 掘金](https://juejin.cn/post/6847009772198166536?searchId=2024080615223180876F5097A608E5EACE) > [官方推荐使用的 OkHttp4 网络请求库全面解析！](https://juejin.cn/post/7212536164057776184?searchId=2024080615223180876F5097A608E5EACE) > [OkHttp 拦截器的一些骚操作 - 掘金](https://juejin.cn/post/6844903606718562317?searchId=2024080615223180876F5097A608E5EACE) > [一篇文章带你走通 OkHttp+Retrofit+Rxjava - 掘金](https://juejin.cn/post/6844903464082866190?searchId=2024080615223180876F5097A608E5EACE) > [使用 Retrofit 2.0 + OkHttp 3.0 实现缓存处理 - 掘金](https://juejin.cn/post/6844903444285751309?searchId=2024080615223180876F5097A608E5EACE) > [OKHttp 源码解析(一)--初阶-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/1199021)

- 简洁易用的 API：通过构建 Request 对象和使用 Call 对象来发起同步或异步的网络请求.
- 支持现代的 HTTP 协议, 包括 HTTP/2 和 SPDY
- 连接池和缓存：OkHttp 内置了连接池和响应缓存, 可以有效地管理和复用网络连接, 并提供可配置的缓存机制, 减少重复的网络请求.
- 自动重试 ：在请求失败时自动重试请求, 从而提高请求可靠性.
- 拦截器：提供拦截器机制, 允许在发送请求和接收响应的过程中进行自定义处理, 例如添加公共参数、日志记录等.
- 支持 gzip 压缩 ：支持接受和解压 GZIP 压缩的响应数据, 减小网络传输的数据量, 提升网络性能.

#### 使用

![_](%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91.assets/file-20240806154800379.png)

```kotlin
val client = OkHttpClient.Builder() // 1. 创建 OkHttpClient 实例
    .connectTimeout(5000L, java.util.concurrent.TimeUnit.MILLISECONDS)
    .readTimeout(5000L, java.util.concurrent.TimeUnit.MILLISECONDS)
    .writeTimeout(5000L, java.util.concurrent.TimeUnit.MILLISECONDS)
    .retryOnConnectionFailure(true)
    .followRedirects(true)
    .followSslRedirects(true)
    .cache(null) // 设置缓存
    .authenticator(null) // 设置身份验证器
    .certificatePinner(null) // 设置证书锁定器
    .connectionPool(null) // 设置连接池
    .connectionSpecs(listOf()) // 设置连接规范
    .cookieJar(null) // 设置 Cookie 管理器
    .dispatcher(null) // 设置分发器
    .dns(null) // 设置 DNS 解析器
    .eventListenerFactory(null) // 设置事件监听器工厂
    .proxy(null) // 设置代理
    .protocols(listOf()) // 设置支持的协议
    .proxyAuthenticator(null) // 设置代理身份验证器
    .proxySelector(null) // 设置代理选择器
    .socketFactory(null) // 设置 Socket 工厂
    .hostnameVerifier(null) // 设置主机名验证器
    .build()

val getRequest = Request.Builder() // 2. 创建 Request 对象
    .url("https://reqres.in/api/users?page=2")
    .header("name", "value")
    .addHeader("name", "value")
    .cacheControl(null) // 设置缓存控制
    .build()

// 3. 同步请求
val response1 = client.newCall(getRequest).execute().use { response ->
    response.body?.string() ?: ""
}

// 3. 异步请求, 如果当前 request 已执行, 抛出错误
val response2 = client.newCall(get).enqueue(object : Callback {
    override fun onFailure(call: Call?, e: IOException) {
        //
    }

    override fun onResponse(call: Call?, response: Response) {
        val content = response.body?.string() ?: ""
    }
})
```

#### 原理

> [!cite] > [由浅入深, 聊聊 OkHttp 的那些事(易懂, 不繁琐) - 掘金](https://juejin.cn/post/7199431845367922745?searchId=20240806152219108948FAF7C05048547D) > [面试官：听说你熟悉 OkHttp 原理？ - 掘金](https://juejin.cn/post/6844904087788453896?searchId=20240806152219108948FAF7C05048547D)

![_](%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91.assets/file-20240806152547281.png)

> [!TODO]

### Retrofit

> [!TODO]

### 内部库

## 临时

### Git – 断点续传 git 大项目

假设要从 GitHub 拉取 OpenCV：[https://github.com/opencv/opencv 进行编译](https://github.com/opencv/opencv进行编译), 可以按照以下的方法.

1. 首先新建一个项目文件夹, 初始化空白 git 仓库

   ```bash
   mkdir opencv
   cd opencv
   git init
   ```

2. 添加远程仓库

   ```bash
   git remote add origin https://github.com/opencv/opencv
   ```

3. 拉取所有分支、标签和完整历史记录

   ```bash
   git fetch origin --prune --tags +refs/heads/*:refs/remotes/origin/*
   
   origin：指定远程仓库名.
   --prune：删除本地没有的远程分支.
   --tags：获取所有标签.
   +refs/heads/*:refs/remotes/origin/*：获取远程仓库的所有分支, 并将其映射到本地的 refs/remotes/origin/ 下, 一般可以不加此选项
   ```

4. 如果第 3 步中断或者失败, 则重复执行第 3 步, 直到完成下载
5. 下载完成之后, 检出需要的分支或标签, 如 master

   ```bash
   git branch -r
   git tag
   git checkout master
   ```

6. 更新所有本地分支和远程分支的映射关系

   ```bash
   git pull origin --all
   ```

7. 再执行 `git checkout master` 命令

在 Linux 系统下, 可以写一个 shell 脚本, 自动循环进行 `git fetch`.

### 为什么减少依赖很重要？

这段内容强调了在开发 Android 应用时, 应该尽量减少对 Android 框架类 (如 Context、Toast 等) 的直接依赖, 将这些依赖隔离在少数核心组件中. 这样做的主要目的是提高代码的可测试性和模块化, 降低耦合度.

1. 提高可测试性：当类依赖于 Android 框架时 (例如需要一个 Context 实例) , 在编写单元测试时, 必须模拟这些依赖对象, 这可能会增加复杂性. 如果业务逻辑不依赖于 Android 框架类, 那么编写单元测试就变得更加容易, 因为你只需要测试纯粹的业务逻辑, 而不必处理 Android 特有的依赖.
2. 降低耦合度：如果类依赖于 Android 框架, 它们就只能在 Android 环境中运行 (例如设备或模拟器). 通过减少这种依赖性, 代码可以更独立、更灵活, 可以在不同的环境中复用, 且不容易受到 Android 特定 API 的限制.  
   举例说明  
   不良的依赖设计  
   考虑以下示例, 一个 UserManager 类直接依赖于 Context 来获取资源或展示 Toast：

```kotlin
class UserManager(private val context: Context) {

    fun showWelcomeMessage() {
        // 使用 Context 来显示 Toast 消息
        Toast.makeText(context, "Welcome!", Toast.LENGTH_SHORT).show()
    }
}
```

在这个设计中, UserManager 类直接依赖于 Context, 这会带来以下问题：

- 难以测试：在测试时, 你需要提供一个 Context 实例, 这可能会使测试更加复杂和笨重.
- 耦合性高：UserManager 只能在 Android 环境中使用, 因为它需要一个 Context 实例.  
  改进后的设计  
  现在我们将 UserManager 中与 Android 相关的操作抽离到一个单独的接口中, 这样就可以减少对 Android 类的直接依赖：

```kotlin
interface MessageDisplayer {
    fun showMessage(message: String)
}

class ToastMessageDisplayer(private val context: Context) : MessageDisplayer {
    override fun showMessage(message: String) {
        Toast.makeText(context, message, Toast.LENGTH_SHORT).show()
    }
}

class UserManager(private val messageDisplayer: MessageDisplayer) {

    fun showWelcomeMessage() {
        // 使用抽象接口来显示消息
        messageDisplayer.showMessage("Welcome!")
    }
}
```

在这个改进的设计中：

- MessageDisplayer：定义了一个抽象接口, 它不依赖于 Android 框架. 这个接口可以有不同的实现, 比如 ToastMessageDisplayer 用于 Android 环境.
- ToastMessageDisplayer：是 MessageDisplayer 的具体实现, 负责实际显示 Toast 消息. 它依赖 Context, 但这种依赖被隔离在了这个具体的类中.
- UserManager：现在只依赖于 MessageDisplayer 接口, 而不是直接依赖 Context. 这使得 UserManager 可以轻松地进行单元测试, 因为你可以传递一个简单的 MessageDisplayer mock 对象.  
  在测试中的优势  
  在测试 UserManager 时, 你不再需要依赖 Context 或 Android 特有的类：

```kotlin
class FakeMessageDisplayer : MessageDisplayer {
    var message: String? = null

    override fun showMessage(message: String) {
        this.message = message
    }
}

fun testShowWelcomeMessage() {
    val fakeMessageDisplayer = FakeMessageDisplayer()
    val userManager = UserManager(fakeMessageDisplayer)

    userManager.showWelcomeMessage()

    assert(fakeMessageDisplayer.message == "Welcome!")
}
```

在这个测试中, FakeMessageDisplayer 是 MessageDisplayer 的一个简单实现, 允许你检查 UserManager 的行为而不需要 Context.  
总结  
减少对 Android 类的直接依赖, 通过使用接口或抽象类来隔离 Android 相关操作, 可以让你的应用更加模块化和可测试. 你可以将业务逻辑与 Android 特有的实现细节分开, 使代码更灵活、更容易测试, 也更符合 SOLID 原则中的单一职责和依赖倒置原则.

### 文件读写和权限说明

> [!todo] > [记一个 Android 14 适配引发的 Android 存储权限问题](https://www.cnblogs.com/joy99/p/17809113.html) > [Android 文件读写最全解析](https://www.cnblogs.com/joy99/p/17809113.html) > [Android 数据存储五种方式使用与总结.md](<https://github.com/helen-x/AndroidInterview/blob/master/android/Android> 数据存储五种方式使用与总结.md)

sharedPreferences: 基于 XML 文件存储的键值对数据, 根据第一个参数 name 获得相应的 SharedPreferences 对象

- MODE_PRIVATE: 只能被本应用程序读、写
- MODE_WORLD_READABLE: 其他应用程序可以读, 但不能写
- MODE_WORLD_WRITEABLE: 其他应用程序可以读, 写
- MODE_MULTI_PROCESS: 当多个进程同时读写同一个 SharedPreferences 时, 会检查文件是否修改

## Android 多线程

任务执行和管理: `Thread` | `Runnable` | `Executors` | `WorkManager` (`AsyncTask` 弃用了) | `ThreadPoolExecutor`  
任务反馈及交互: `Callable` | `Future` | `FutureTask` | `Handler` | `HandlerThread` |

### 直接创建和管理线程及其任务

子类化 `Thread`. 通过复写 `run` 方法自定义线程任务, 同时可以通过创建的线程对象管理线程, 如 运行、睡眠、挂起、停止.

```kotlin
class MyThread(name: String) : Thread(name) {
    private var ticket = 100
    override fun run() {
        while (ticket > 0) {
            ticket--
            Thread.sleep(1000)
        }
    }
}

// 创建线程对象并启动
val mt = MyThread("线程名称")
mt.start()

// 使用匿名类创建和启动线程
Thread("线程名称") {
    var ticket = 100
    while (ticket > 0) {
        ticket--
        println("线程名称: 卖掉了1张票, 剩余票数为: $ticket")
        Thread.sleep(1000) // 卖票速度是1秒一张
    }
}.start()
```

### 任务与线程分离, 实现线程复用和资源共享

通过实现 `Runnable` 任务接口, 只需要定义一个 `run` 方法来自定义线程任务(即只关注于任务). 通过创建 `Runnable` 任务对象, 并将 `Runnable` 对象传递给一个或多个线程对象, 使得线程对象可以执行 `Runnable` 对象定义的线程任务, 同时共享此 `Runnable` 对象中的资源. 线程的管理仍是通过线程对象自身进行, 但是无需子类化 `Thread`.

```kotlin
class MyRunnable : Runnable {
    private var ticket = 100
    override fun run() {
        while (ticket > 0) {
            ticket--
            Thread.sleep(1000)
        }
    }
}

// 创建线程对象并启动任务
val myRunnable = MyRunnable()
val thread1 = Thread(myRunnable)
val thread2 = Thread(myRunnable)
thread1.start()
thread2.start()

// 使用匿名 Runnable 创建和启动线程
val runnable = Runnable {
    var ticket = 100
    while (ticket > 0) {
        ticket--
        Thread.sleep(1000)
    }
}

Thread(runnable, "线程名称1").start()
Thread(runnable, "线程名称2").start()

// 使用 lambda 表达式创建和启动线程, lambda 表达式会被自动转换成 Runnable.
Thread {
    var ticket = 100
    while (ticket > 0) {
        ticket--
        Thread.sleep(1000)
    }
}.start()
```

### 使用线程池简化线程创建和生命周期管理

将任务提交给线程池, 根据需要分配线程来执行任务.

`Executor` 是一个接口, 只限制了实现任务提交到线程池和任务执行的功能.  
`ExecutorService` 是在 `Executor` 的基础上进一步定义的接口, 提供了控制任务执行和更高级的任务提交功能.

- `shutdown()` 方法停止提交任务, 并允许先前提交的任务继续执行, 直到执行完成.
- `shutdownNow()` 方法停止提交任务, 并阻止等待先前提交的任务, 尝试停止当前正在执行的任务.
- `submit(...)` 方法提交任务, 并返回一个可用于取消任务执行和存放任务结果的 `Future` 对象.
- `invokeAny` 和 `invokeAll` 执行一组任务, 然后等到至少一个或全部任务完成.  
  `ScheduledExecutorService` 是在 `ExecutorService` 基础上进一步定义的接口, 提供了延迟和周期性执行任务的功能.
- `schedule(...)` 方法, 用于延迟执行任务.
- `scheduleAtFixedRate(...)` 方法, 用于周期性执行任务.
- `scheduleWithFixedDelay(...)` 方法, 用于周期性执行任务, 但是在任务完成后的固定延迟后再次执行.

完整的实现了 `ExecutorService` 或 `ScheduledExecutorService` 的线程池服务类型有:

- `ForkJoinPool`
- `ScheduledExecutorService`
- `ThreadPoolExecutor`

    - `ScheduledThreadPoolExecutor`

`Executors` 是一个工具类, 提供了方便的工厂方法来创建以上列举的不同类型的线程池服务对象.

```kotlin
// 固定大小的线程池, 适用于需要限制线程数量, 且需要复用线程执行大量短期任务的场景
val executor = Executors.newFixedThreadPool(3) // ExecutorService
// 可缓存的线程池, 优先复用已有线程, 不足时根据需要创建新线程, 适用于执行大量生存期很短的异步任务
val executor = Executors.newCachedThreadPool()
// 只有一个线程, 所有任务按照提交顺序执行
val executor = Executors.newSingleThreadExecutor()
executor.execute { Thread.sleep(1000) } // 模拟任务执行时间
executor.shutdown()

// 定时任务线程池, 适用于需要延迟执行或周期性执行任务的场景
val scheduler = Executors.newScheduledThreadPool(2)
scheduler.schedule({ Thread.sleep(1000) }, 2, TimeUnit.SECONDS) // 延迟2秒后执行
scheduler.scheduleAtFixedRate({ Thread.sleep(1000) }, 1, 3, TimeUnit.SECONDS) // 延迟1秒后, 每3秒执行一次
scheduler.shutdown()

// 自定义线程池
val threadPool = ThreadPoolExecutor(
    2, // 核心线程数
    4, // 最大线程数
    60, // 空闲线程存活时间
    TimeUnit.SECONDS, // 时间单位
    LinkedBlockingQueue<Runnable>(2) // 任务队列
)
threadPool.execute { Thread.sleep(1000) } // 模拟任务执行时间
threadPool.shutdown()
```

### 异步获取任务结果

`ExecutorService` 和 `ScheduledExecutorService` 两种任务执行器类型的 `submit` 或 `schedule` 等方法均可以通过传递一个 `Callable` 任务对象来返回一个表示异步计算结果的 `Future` 或 `ScheduledFuture` 对象. 通过 `Future` 对象可以取消其所绑定的任务, 获取任务执行状态, 以及获取任务执行结果.

```kotlin
val executor = Executors.newSingleThreadExecutor()
val callableTask = Callable {
    Thread.sleep(1000)
    "Callable 任务执行结果"
}
val future: Future<String> = executor.submit(callableTask)
println("任务执行结果: ${future.get()}")
executor.shutdown()

Thread 可以通过 FutureTask 将任务进行封装, 其可以同时作为 Runnable 任务对象和 Future 对象作为任务载体, 同时获取和控制线程状态.
val futureTask = FutureTask<String> {
    "Hello"
}
Thread(futureTask).start()
val result = futureTask.get()
```

### 不同任务线程间进行消息传递

在线程中通过 `Handler`、`MessageQueue` 和 `Looper` 实现在不同线程间传递消息和执行任务.

- `MessageQueue` 用于在线程内部存储待处理的消息 `Message` 和任务 `Runnable`. 一种基于单链表的数据结构实现的消息队列, 支持对内部 `Message` 的插入 `enqueueMessage`、取出 `next`、移除 `removeMessages` 等操作. 此外, `MessageQueue` 与 `Looper` 绑定, 当创建 `Looper` 时, 会自动创建一个 `MessageQueue` 对象, 并将其绑定到当前线程, 不需要手动创建.
- `Looper` 负责循环处理消息队列中的消息. 每个线程可以通过内部调用 `Looper.prepare()` 创建一个 `Looper` 对象, 并通过 `Looper.loop()` 方法启动消息处理循环, 注意只能创建一个 `Looper` 对象, 主线程默认已经创建了一个 `Looper` 对象. 启动消息处理循环后, `Looper` 会不断从消息队列中取出消息, 并将其分发给目标 `Handler` 处理, 直到消息队列为空. 未处理完成或手动退出消息处理循环前, 线程会一直处于阻塞状态.
- `Handler` 用于发送和处理消息 `Message` 和任务 `Runnable`. 每个线程可以有多个 `Handler` 对象, 但是每个 `Handler` 对象只能绑定到一个指定的 `Looper` 对象(默认为当前线程的 `Looper`). 通过 `Handler` 的 `sendMessage` 方法向绑定的 `Looper` 的消息队列中发送消息, 通过 `Handler` 的 `post` 方法向消息队列中发送任务. 支持消息的延迟发送.
- `Message` 用于封装消息内容, 包括 `arg1` 和 `arg2` 两个存储整数的参数、`obj` 存储接收者对象的引用、`what` 存储消息类型或用户定义的消息代码、`target` 存储消息接收者的 `Handler` 对象、`callback` 存储消息处理回调函数等.

```kotlin
import android.os.Handler
import android.os.Looper
import android.os.Message

fun main() {
    // 主线程的 Handler, 用于发送消息到后台线程
    val mainHandler = Handler(Looper.getMainLooper())

    val backgroundThread = BackgroundThread()
    backgroundThread.start()

    mainHandler.post {
        println("主线程发送消息到后台线程")
        val message = Message.obtain()
        message.what = 1
        message.obj = "Hello from the Main Thread!"
        backgroundThread.getHandler()?.sendMessage(message)
    }
}

class BackgroundThread : Thread() {
    private var backgroundHandler: Handler? = null

    override fun run() {
        Looper.prepare()
        backgroundHandler = MyHandler(Looper.myLooper()!!)
        Looper.loop()
    }

    fun getHandler(): Handler? {
        return backgroundHandler
    }
}

// 自定义后台线程的消息处理逻辑
class MyHandler(looper: Looper) : Handler(looper) {
    override fun handleMessage(msg: Message) {
        when (msg.what) {
            1 -> {
                println("后台线程处理消息: ${msg.obj}")
                val mainHandler = Handler(Looper.getMainLooper())
                mainHandler.post {
                    println("主线程收到消息: ${msg.obj}")
                }
            }
        }
    }
}


```

在线程中通过 `HandlerThread` 和 `Handler` 实现在不同线程间传递消息和执行任务.

- `HandlerThread` 是一个带有 `Looper` 的线程类, 用于在后台线程中执行任务和处理消息. `HandlerThread` 继承自 `Thread` 类, 通过 `Looper` 实现了消息循环处理机制, 可以通过 `getLooper()` 方法获取 `Looper` 对象, 通过 `quit()` 方法退出消息循环.
- `HandlerThread` 与 `Handler` 结合使用, 可以实现在后台线程中执行任务和处理消息, 通过 `HandlerThread` 的 `getLooper()` 方法获取 `Looper` 对象, 并通过 `Handler` 的构造方法传入 `Looper` 对象, 从而实现消息的发送和处理.

```kotlin
import android.os.Handler
import android.os.HandlerThread
import android.os.Looper
import android.os.Message

fun main() {
    // 主线程的 Handler, 用于发送消息到后台线程
    val mainHandler = Handler(Looper.getMainLooper())

    // 创建并启动 HandlerThread
    val backgroundThread = HandlerThread("BackgroundThread")
    backgroundThread.start()
    val backgroundHandler = Handler(backgroundThread.getLooper())

    //
    mainHandler.post {
        println("主线程发送消息到后台线程")
        val message = Message.obtain()
        message.what = 1
        message.obj = "Hello from the Main Thread!"
        backgroundHandler.sendMessage(message)
    }
}

class MyHandler(looper: Looper) : Handler(looper) {
    override fun handleMessage(msg: Message) {
        when (msg.what) {
            1 -> {
                println("后台线程处理消息: ${msg.obj}")
                // 处理完任务后, 将结果发送回主线程
                val mainHandler = Handler(Looper.getMainLooper())
                mainHandler.post {
                    println("主线程收到消息: ${msg.obj}")
                }
            }
        }
    }
}
```

## 路由框架

> [!Cite] > [ARouter](https://github.com/alibaba/ARouter) > [ActivityRouter](https://github.com/mzule/ActivityRouter) > [WMRouter](https://github.com/meituan/WMRouter) > [TheRouter](https://github.com/HuolalaTech/hll-wp-therouter-android) > [DRouter](https://github.com/didi/DRouter) > [BRouter](https://github.com/bilibili/BRouter) > [Custom Router](https://github.com/gdutxiaoxu/Router) > [Custom Router](https://github.com/waws80/Router) > [Custom Router](https://github.com/chenenyu/Router) > [Android 路由框架用法大全](https://juejin.cn/post/6984993972804550692) > [Android 组件化 —— 路由设计最佳实践](https://cloud.tencent.com/developer/article/1356515) > [Android 客户端路由框架的整理和思考](https://www.jianshu.com/p/15d8cc6cf19b) > [GRouter](https://github.com/taoweiji/grouter-android/)

| 功能模块             | ARouter 功能                                                   | 说明                                                             |
| -------------------- | -------------------------------------------------------------- | ---------------------------------------------------------------- |
| **页面跳转**         | 支持直接通过路径跳转到目标页面                                 | 通过 `@Route` 标注路径，简化跳转逻辑                             |
| **参数传递**         | 支持多种参数类型，包括基本数据类型、自定义对象等               | 参数通过 `@Autowired` 自动注入，简化开发                         |
| **转场动画**         | 支持跳转时自定义转场动画                                       | 可通过常规方式或 `ActivityOptionsCompat` 自定义动画              |
| **跳转拦截器**       | 可定义多个拦截器，按优先级执行                                 | 常用于登录检查、埋点等逻辑，简化重复代码                         |
| **全局降级策略**     | 自定义降级处理逻辑，支持页面未找到等情况                       | 降级策略提升用户体验，特别是路径失效或目标不存在时               |
| **服务注册与发现**   | 支持跨模块服务发现和依赖注入，模块间解耦                       | 通过 `@Route` 注解和 `IProvider` 接口实现服务发现                |
| **参数序列化**       | 支持自定义对象序列化，通过实现 `SerializationService` 接口实现 | 支持复杂数据结构和自定义对象的传递                               |
| **动态注册**         | 支持动态注册路由信息，适用于插件化架构                         | 通过 `addRouteGroup` 方法动态添加路由信息                        |
| **路径重写**         | 支持路径或 URL 的动态重写                                      | 通过实现 `PathReplaceService` 接口，对路径重写或重定向           |
| **自动生成文档**     | 支持自动生成路由文档                                           | 可生成 JSON 格式文档，用于团队协作                               |
| **多模块支持**       | 支持多模块工程，分组按需初始化                                 | 各模块的路由按组分类加载，节约资源                               |
| **Debug 与日志控制** | 支持调试模式和日志开关，便于开发调试                           | 可通过 `ARouter.openLog()` 和 `ARouter.openDebug()` 控制日志输出 |
| **增量编译**         | 支持增量编译，提高编译速度                                     | 可开启增量编译，但开启文档生成后会关闭增量编译                   |
| **IDE 插件支持**     | 提供 Android Studio 插件，便于路径跳转                         | 可通过 ARouter Helper 插件快速跳转到目标类，提高开发效率         |

### ARouter 解析

#### 设计理念

帮助 Android App 进行组件化改造, 支持模块间的路由、通信、解耦.

- 编译时基于注解处理器(apt)来生成路由表. 在每个组件的 build.gradle 文件中, 配置注解处理器的依赖和配置信息即可在编译时自动扫描组件内所有使用了预设注解(如 `@Route`)的类, 属性, 或方法, 然后根据注解中的信息生成一个路由表, 包含路径到目标类的映射关系和参数信息.
- 运行时基于反射机制创建目标类实例. 在运行时, 通过路由表中的路径信息获取到目标类的类名, 然后通过反射机制创建目标类的实例, 并将参数注入到目标类中, 最后调用目标类的方法.
- 支持 Activity, Fragment, Service, Provider, CONTENT_PROVIDER, BOARDCAST, METHOD 等多种路由类型.
- 支持直接解析标准 URL 进行跳转. 实现跨端统一跳转协议, 通过 URL 跳转到指定页面.
- 支持跳转时自定义转场动画. 实现多种场景下的转场动画.
- 支持定义多个拦截器, 按优先级顺序执行. 实现通过路径跳转到目标页面前的拦截处理, 常用于登录检查、埋点等逻辑, 简化重复代码.
- 支持自定义全局与局部降级处理逻辑. 实现当路径失效或目标不存在时的降级处理, 提升用户体验.
- 支持通过预设注解自动注入多种参数类型, 包括基本数据类型、自定义对象等. 实现通过路径跳转到目标页面, 无需手动解析传递的参数, 简化开发.
- 支持生成路由文档. 实现自动生成 JSON 格式文档, 用于团队协作.
- 支持增量编译(开启文档生成后无法增量编译).
- 提供 IDE 插件支持. 实现通过 ARouter Helper 插件快速跳转到目标类, 提高开发效率.
- 支持多模块工程. 实现路由按模块进行分组加载, 节约资源.

#### 使用介绍

- 添加依赖和配置

  ```gradle
  android {
      defaultConfig {
          ...
          javaCompileOptions {
              annotationProcessorOptions {
                  arguments = [AROUTER_MODULE_NAME: project.getName()]
              }
          }
      }
  }
  dependencies {
      implementation 'com.alibaba:arouter-api:1.5.1'
      kapt 'com.alibaba:arouter-compiler:1.2.2'
  }
  ```

- 在需要跳转的 Activity 上添加注解

  ```kotlin
  @Route(path = "/test/activity")
  class TestActivity : AppCompatActivity() {
      ...
  }
  ```

- 添加可传递参数

  ```kotlin
  @Route(path = "/test/activity")
  class TestActivity : AppCompatActivity() {
      @Autowired
      var name: String? = null
  
      // 自定义映射关系
      @Autowired(name = "girl")
      var boy: String? = null
  
      // json 与 object 映射(需要对象实现 Parcelable 接口)
      @Autowired
      var obj: TestObj? = null
      var map: Map<String, String>? = null
      var list: List<TestObj>? = null
  
      override fun onCreate(savedInstanceState: Bundle?) {
          super.onCreate(savedInstanceState)
          ARouter.getInstance().inject(this) // 自动注入参数
      }
  }
  ```

- 使用拦截器

  ```kotlin
  @Interceptor(priority = 1, name = "TestInterceptor")
  class TestInterceptor : IInterceptor {
      override fun process(postcard: Postcard, callback: InterceptorCallback) {
          // 拦截器处理逻辑
          callback.onContinue(postcard)
      }
  
      override fun init(context: Context) {
          // 拦截器的初始化，会在sdk初始化的时候调用该方法，仅会调用一次
      }
  }
  ```

- 自定义全局降级策略

  ```kotlin
  @Route(path = "/service/degrade")
  public class DegradeServiceImpl implements DegradeService {
  
      @Override
      public void onLost(Context context, Postcard postcard) {
          // 当找不到页面时执行的操作，例如跳转到一个错误页面或提示
      }
  
      @Override
      public void init(Context context) {
          // 初始化代码，可以为空
      }
  }
  ```

- 在 Application 中初始化 ARouter

  ```kotlin
  class App : Application() {
      override fun onCreate() {
          super.onCreate()
          ARouter.init(this)
      }
  }
  ```

- 跳转到指定 Activity

  ```kotlin
  // 简单跳转
  ARouter.getInstance().build("/test/activity").navigation()
  // 携带参数跳转
  ARouter.getInstance().build("/test/activity")
      .withString("key", "value")
      .navigation()
  // 通过类型跳转
  ARouter.getInstance().navigation(TestActivity::class.java)
  ```

#### 源码解析

##### 前置知识

- `编译期元数据` 是指在编译时生成的元数据, 用于描述源代码的结构和信息, 通常用于代码生成、代码检查、代码优化等场景.

    - `SourceVersion` 枚举表示 Java 语言的版本, 通常用于判断当前编译环境支持的 `Java` 版本。
    - `Elements` 是 Java 编译器提供的是一个工具接口, 提供了一系列用于获取和操作源代码元素信息的便捷方法, 包括类、方法、字段、注解等.

        - `TypeMirror` 是 Java 编译器提供的一个接口, 用于表示 Java 类型, 包括基本数据类型、数组、泛型、通配符、类型变量、方法类型等.
        - `getEnclosedElements` 方法用于获取指定元素直接包含的子元素, 如类或接口的字段、方法、构造函数和内部类型; 包的顶级类和接口; 模块的包。
        - `getEnclosingElement` 方法用于获取当前元素的直接上层结构, 如类的包、方法的类、字段的类等.

    - `Types` 是 Java 编译器提供的一个工具接口, 提供了对 Java 类型(如类、接口、枚举等)进行分析、比较、转换等操作的方法.

- `AnnotationProcessor` 是 Java 编译器的一个工具, 用于在编译时扫描和处理注解.

    - `AbstractProcessor` 是所有注解处理器的基类. 编写自定义注解处理器时继承该类, 并实现 `process` 方法即可在编译期间实现自定义的注解处理逻辑.
    - `Filer` 注解处理工具中提供的一个接口, 用于创建新文件、类文件、资源文件等.

        - `Writer` 是 Java IO 提供的一个抽象类, 用于写入字符流, 如 json 文件.

    - `Messager` 是注解处理工具中提供的一个接口, 用于输出信息、警告、错误等.
    - Options: `Map<String,String>` 是传递给注解处理器的配置参数信息.
    - `ProcessingEnvironment` 是传递给注解处理器的编译时环境信息, 可以通过该对象获取到 `Filer`、`Elements`、`Types` 等工具对象.
    - 注解处理器的处理是分轮次（round）进行的, 每轮都会重复调用 process 方法. 第一轮编译器扫描所有源文件, 并调用 process 方法, 之后判断当前轮次是否有新的源文件生成, 如果有则继续扫描, 否则结束处理.

- `AutoService` 是 Google 提供的一个库, 用于简化 `AnnotationProcessor` 的 SPI(Service Provider Interface) 注册.
- `JavaPoet` 是一个用于生成 Java 源代码的库, 通过 `JavaPoet` 可以在编译时生成 Java 代码, 用于生成路由表.

    - `ClassName` 用于表示类名, 如 `com.alibaba.arouter.facade.annotation.Route`.
    - `ParameterizedTypeName` 用于表示类型, 如 List`<String>`、Map<String, Integer> 等.
    - `ParameterSpec` 用于表示方法参数, 可以通过 `ParameterizedTypeName` 指定类型.
    - `MethodSpec` 用于表示方法, 可以通过 `ParameterSpec` 指定方法参数.

- 反射机制: Java 提供的用于在运行时获取类的信息、属性、方法、构造方法等, 并通过反射机制调用类的方法、获取属性值等.

    - `Class` 类用于表示类的信息, 包括类名、属性、方法、构造方法等.
    - `Field` 类用于表示类的属性信息, 包括属性名、属性类型、属性值等.
    - `Method` 类用于表示类的方法信息, 包括方法名、方法参数、方法返回值等.
    - `Constructor` 类用于表示类的构造方法信息, 包括构造方法参数、构造方法访问修饰符等.

##### arouter-annotation

声明了 ARouter 框架中使用的注解类型和一些枚举类

- `@Route(path: String, group: String = "", name: String = "", extras: Int = 0, priority: Int = -1)` 用于标注路由路径信息.
- `@Autowired(name: String = "", required: Boolean = false, desc: String = "")` 用于标注目的对象内部的属性, 用于自动注入参数.
- `@Interceptor(priority: Int, name: String = "")` 用于标注拦截器信息.
- `RouteType` 枚举类, 用于定义路由类型.

    - `ACTIVITY`, `FRAGMENT`: 页面路由类型, 用于打开某个页面.
    - `SERVICE`: 后台服务路由类型, 用于打开某个需要后台运行的服务.
    - `PROVIDER`: 接口服务提供者路由类型, 用于获取某个接口的具体实现.
    - `ContentProvider`: 内容提供者路由类型, 用于获取某个内容提供者的实例. 内容提供者可以提供数据给其他应用程序.
    - `BOARDCAST`: 广播路由类型, 用于发送广播.
    - `METHOD`: 方法路由类型, 用于调用某个方法.

- `RouteMeta` 数据类, 用于封装路由信息, 包括路径、组、名称、类型、优先级、降级策略、拦截器、参数等信息.

    - `type: RouteType`: 路由类型.
    - `rawType: Element`: 路由目标类原始信息
    - `destination: Class<?>`: 路由目标类具体
    - `path: String`: 路由跳转路径, 为 `@Route` 注解中的 `path` 属性.
    - `group: String`: 路由路径所在组, 一般为默认组(路径第一个 `/` 后的字符串, 没有则分组为 null).
    - `priority: int`: 路由优先级.
    - `extra: int`: 路由附加信息.
    - `paramsType: Map<String, Integer>`: 路由注入的所有参数类型.
    - `name: String`: 路由名称.
    - `injectConfig: Map<String, Autowired>`: 路由注入的所有参数配置.

- `TypeKind` 枚举类, 用于定义所支持的自动注入参数类型.
    - 基本类型: `BOOLEAN`, `BYTE`, `SHORT`, `INT`, `LONG`, `CHAR`, `FLOAT`, `DOUBLE`.
    - 其他类型: `STRING`, `SERIALIZABLE`, `PARCELABLE`, `OBJECT`.

##### arouter-compiler

实现了注解处理器, 用于在编译时扫描组件内所有使用了预设注解的类, 属性, 或方法, 然后根据注解中的信息生成一个路由表, 包含路径到目标类的映射关系和参数信息.

项目中要处理注解自动生成路由表代码, 则必须依赖 `arouter-compiler` 模块, 并在 `build.gradle` 文件中配置 `kapt` 插件. 以下是 `arouter-compiler` 中包含的注解处理器:

- `AutowiredProcessor` 支持解析 `@Autowired` 注解.
- `InterceptorProcessor` 支持解析 `@Interceptor` 注解.
- `RouteProcessor` 支持解析 `@Route` 和 `@Autowired` 注解.

注解处理器的处理顺序: `AutowiredProcessor` -> `InterceptorProcessor` -> `RouteProcessor`.

注解处理时分模块处理, 区分模块采用 `build.gradle` 文件中的 `AROUTER_MODULE_NAME` 参数定义的模块名称.

```gradle
javaCompileOptions {
    annotationProcessorOptions {
        arguments = [AROUTER_MODULE_NAME: project.getName(), AROUTER_GENERATE_DOC: "enable"]
    }
}
```

支持生成路由文档, 通过 `AROUTER_GENERATE_DOC` 参数开启文档生成. 最终生成的文档是一个 JSON 格式的文件, 包含了所有模块的路由信息. 文档生成的路径是在 `build/generated/source/apt` 目录下. 文件名为 `arouter-map-of-模块名.json`. 详细怎么生成的本文不进行讲解.

###### AutowiredProcessor

`@Autowired` 注解用于标注目的对象内部的属性, 用于自动注入参数. 注意点如下:

- 仅支持为 Activity, Fragment 类型的目的对象内部注入基本数据类型、自定义对象、集合类型、IProvider 类型等.
- IProvider 类型的参数注入默认通过其实际类类型(直接实现)或其接口类型(间接实现)来获取实例, 也可以通过 `@Autowired` 注解的 `name` 属性来指定实例名称, 用于区分同一接口的不同实现.
- 参数注入需要 `SerializationService` 服务支持, 用于序列化和反序列化参数. 内部已经有一个默认实现了, 也可以通过实现 `SerializationService` 接口和添加 `@Route` 注解来自定义序列化服务.

`AutowiredProcessor` 是 `@Autowired` 的注解处理器, 其最终目的是为每个需要注入参数的类型生成一个帮助类, 用于自动注入参数.

参数注入的注解处理过程主要分为两个步骤:

- 第一步是扫描所有使用了 `@Autowired` 注解的元素, 并根据元素的上层结构分类存储到内存中.

  ```java
  // 获取所有使用了 @Autowired 注解的元素
  Map<TypeElement, List<Element>> parentAndChild; // 用于存储父元素和子元素的映射关系
  Set<? extends Element> autowiredElements = roundEnv.getElementsAnnotatedWith(Autowired.class);
  for (Element element : autowiredElements) {
      TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
      List<Element> elements = autowiredMap.get(enclosingElement);
      parentAndChild[enclosingElement].add(element);
  }
  ```

- 第二步是为每个需要注入参数的类型生成一个帮助类, 用于自动注入参数.

  ```java
  // 遍历所有需要注入参数的类型, 生成帮助类
  for (parentElement, childElements : parentAndChild) {
      MethodSpec.Builder injectMethodBuilder: PUBLIC Override inject(Object target) // 统一注入方法的构造器
  
      injectMethodBuilder.addStatement("serializationService = ARouter.getInstance().navigation(SerializationService.class)"); // 内置序列化服务实现.
      injectMethodBuilder.addStatement("$T t = ($T)target", ClassName.get(parent), ClassName.get(parent)); // 强制类型转换为目标类型.
  
      // 生成注入代码
      for (Element element : childElements) {
          Autowired fieldConfig = element.getAnnotation(Autowired.class);
          String fieldName = element.getSimpleName().toString();
          String name = autowired.name();
          boolean required = autowired.required();
          String desc = autowired.desc();
          // iProvider 类型的参数注入时可以选择是否指定实例名称来支持多实现注入. 因此需要额外处理.
          when element is iProvider : 
              if (name.isEmpty()) {
                  injectMethodBuilder.addStatement(
                      "substitute." + fieldName + " = ARouter.getInstance().navigation($T.class)",
                      ClassName.get(element.asType())
                  );
                  // 示例: substitute.testProvider = ARouter.getInstance().navigation(TestProvider.class);
              } else {
                  injectMethodBuilder.addStatement(
                      "substitute." + fieldName + " = ($T)ARouter.getInstance().build($S).navigation()",
                      ClassName.get(element.asType()),
                      fieldConfig.name()
                  );
                  // 示例: substitute.testProvider = (TestProvider)ARouter.getInstance().build("testProvider").navigation();
              }
              // 判断是否必须注入, 必须则需要添加非空判断代码
              if (fieldConfig.required()) {
                  injectMethodBuilder.beginControlFlow("if (substitute." + fieldName + " == null)");
                  injectMethodBuilder.addStatement(
                      "throw new RuntimeException(\"The field '" + fieldName + "' is null, in class '\" + $T.class.getName() + \"!\")", ClassName.get(parent));
                      injectMethodBuilder.endControlFlow();
              }
              // 示例: if (substitute.testProvider == null) throw new RuntimeException("The field 'testProvider' is null, in class 'com.xxx.TestActivity'!");   
          when other:
              // 其他类型的参数注入
              String statement = "substitute." + fieldName + " = (${ClassName.get(element.asType())})" + "substitute."; // 这里强制类型转换其实只有 Serializable 类型需要, 其他类型都是自动转换的.
              when parentElement is Activity:
                  statement += "getIntent().";
              when parentElement is Fragment:
                  statement += "getArguments().";
              
              // 然后根据参数类型生成不同的注入代码
              when element.asType() is BOOLEAN:
                  statement += "getBoolean" + (isActivity ? "Extra" : "") + "($S, " + "substitute." + fieldName + ")";
                  injectMethodBuilder.addStatement(statement, StringUtils.isEmpty(fieldConfig.name()) ? fieldName : fieldConfig.name());
                  // 示例: substitute.testBoolean = substitute.getIntent().getBooleanExtra("testBoolean", substitute.testBoolean);
                  // 示例: substitute.name = substitute.getIntent().getExtras() == null ? substitute.name : substitute.getIntent().getExtras().getString("name", substitute.name);
              ...
              when element.asType() is OBJECT:
                  statement = "serializationService.parseObject(substitute." + (isActivity ? "getIntent()." : "getArguments().") + (isActivity ? "getStringExtra($S)" : "getString($S)") + ", new " + ".TypeWrapper" + "<$T>(){}.getType())";
                  // 如果解析的是对象类型, 需要额外添加一个 TypeWrapper 类型, 用于获取对象的类型信息.
                  injectMethodBuilder.beginControlFlow("if (null != serializationService)");
                  injectMethodBuilder.addStatement(
                      "substitute." + fieldName + " = " + statement,
                      (StringUtils.isEmpty(fieldConfig.name()) ? fieldName : fieldConfig.name()),
                      ClassName.get(element.asType())
                  );
                  injectMethodBuilder.nextControlFlow("else");
                  injectMethodBuilder.addStatement(
                      "$T.e(\"" + Consts.TAG + "\", \"You want automatic inject the field '" + fieldName + "' in class '$T' , then you should implement 'SerializationService' to support object auto inject!\")", AndroidLog, ClassName.get(parent));
                  injectMethodBuilder.endControlFlow();
                  // 示例: substitute.obj = serializationService.parseObject(substitute.getIntent().getStringExtra("obj"), new TypeWrapper<TestObj>(){}.getType());
              // 判断是否必须注入, 必须则需要添加非空判断代码
              if (fieldConfig.required()) {
                  ...
              }
              
      // 生成注入帮助类代码, 包含注入参数的帮助方法和用于序列化和反序列化参数的服务实现.
      TypeSpec.Builder helper = TypeSpec.classBuilder(parent.getSimpleName() + "$$ARouter$$Autowired")
          .addSuperinterface(ClassName.get(ISyringe))
          .addModifiers(PUBLIC);
      FieldSpec jsonServiceField = FieldSpec.builder(TypeName.get(SerializationService.asType()), "serializationService", Modifier.PRIVATE).build();
      helper.addField(jsonServiceField);
      helper.addMethod(injectMethodBuilder.build());
      // 生成帮助类文件
      // packageName 与 parentElement 的包名相同
      avaFile.builder(packageName, helper.build()).build().writeTo(mFiler);
      }
  }
  ```

###### InterceptorProcessor

`@Interceptor` 注解用于标注拦截器信息. 注意点如下:

- 拦截器注解只支持标注实现了 `IInterceptor` 接口的类型.
- 拦截器的优先级用于标识拦截器的执行顺序, 数值越小优先级越高. 不能出现相同优先级的拦截器.

`InterceptorProcessor` 是 `@Interceptor` 的注解处理器, 其最终目的是生成一个拦截器表, 实际是一个类文件, 包含了所有拦截器信息的映射关系.

拦截器表的生成过程主要分为两个步骤:

- 第一步是扫描所有使用了 `@Interceptor` 注解的类, 并将其拦截器信息存储到内存中.
- 根据拦截器的优先级排序, 生成一个拦截器表, 包含了所有拦截器的映射关系.

大概生成的类文件如下:

```java
public class ARouter$$Interceptors$$ModuleName implements IInterceptorGroup {
    @Override
    public void loadInto(Map<Integer, Class<? extends IInterceptor>> interceptors) {
        interceptors.put(7, Test1Interceptor.class);
        interceptors.put(90, TestInterceptor90.class);
    }
}
```

###### RouteProcessor

`@Route` 注解用于位支持类标注其路由信息(如路径、组、名称、优先级、附加标志位). 注意点如下:

- 路由注解只支持标注类, 包括 Activity, Fragment, Service, IProvider 类型.
- 路由信息必须包含路径信息, 同时以 `/` 开头.
- 路由信息的组信息用于模块内分组加载路由信息, 不提供则要求路径至少包含两级, 采用第一级作为组名.
- Activity 和 Fragment 额外支持 `@Autowired` 注解实现自动注入目的对象内部的属性值. 因此处理时需要额外处理 `@Autowired` 注解.

`RouteProcessor` 是 `@Route` 的注解处理器, 其最终目的是生成一个路由表, 实际是多个类文件, 包含了所有路由信息的映射关系和参数信息.

路由表的生成需要分模块和分组处理, 也就是两级映射和加载关系. 分模块确保模块之间的解耦, 方便单独开发. 分组则是为了按需加载(延迟加载)路由信息, 节约资源.

- 每个模块内部都会生成两个根映射表, 名称是 `ARouter$$Root$$模块名` 和 `ARouter$$Providers$$模块名`, 其内部分别包含了所有路由组到组内映射表的映射关系, 以及所有路由路径到 IProvider 类型的映射关系.
- 每个组内部都会生成一个组内映射表, 名称是 `ARouter$$Group$$组名`, 其内部包含了所有路由路径到对应目标类类型的映射关系.

所有根映射表和组内映射表共同构成了一个完整的路由表. 在 app 内初始化 ARouter 时, 会依次加载所有模块的根映射表, 然后根据根映射表中的组名加载对应的组内映射表, 最终获取到所有的从路径到目标类信息的映射关系, 用于后续的路由跳转(基于反射机制创建目标类实例).

路由表的生成过程主要分为两个步骤:

- 第一步是扫描所有使用了 `@Route` 注解的类, 并将其路由信息存储到内存中.

    - `groupMap: Map<String, List<RouteMeta>>` 用于分组存储不同组和其内包含的路由信息. <组名, 组内路由信息列表>
    - `rootMap: Map<String, String>` 用于存储根路由信息, 用于生成类文件时的顺序. <组名, 组内映射表类名>
    - `process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv)` 方法, 用于处理注解.

        - `annotations` 包含了本轮处理器感兴趣的注解类型集合. 每个 TypeElement 代表一个注解类型, 通过此信息可以从 roundEnv 中查找对应的元素.
        - `roundEnv` 提供了当前编译轮次的上下文信息, 可以通过它查询使用了特定注解的类、方法、字段等元素.

  ```java
  // 获取所有使用了 @Route 注解的元素
  Set<? extends Element> routeElements = roundEnv.getElementsAnnotatedWith(Route.class);
  
  // 分组存储所有的路由信息
  for (element : routeElements) {
      TypeMirror elementType; // 获取元素的类型
      Route routeAnnotation; // 获取元素的注解
      RouteMeta routeMeta; // 创建元素对应的路由信息
  
      when elementType is Activity or Fragment:
          Map<String, Integer> paramsType; // 存储所有要注入的参数的类型
          Map<String, Autowired> injectConfig; // 存储所有要注入的参数的配置(如名称、是否必须, 描述)
          injectParamCollector(element, paramsType, injectConfig); // 递归收集所有要注入的参数信息, 分别存储在 paramsType 和 injectConfig 中.
  
          routeMeta = new RouteMeta(route, element, ACTIVITY or Fragment, paramsType, injectConfig);
      when other(iProvider, Service) as type:
          routeMeta = new RouteMeta(route, element, iProvider or Service);
  
      groupMap[routeMeta.group()].add(routeMeta); // 这里每组的 routeMeta 按路径顺序存储
  }
  ```

- 第二步是根据内存中的路由信息生成路由表(根映射表和组内映射表), 并写入到类文件中, 所有类文件统一组织到一个包路径下.

  ```java
  
  // 生成根映射表类文件包括两种: ARouter$$Root$$模块名
  MethodSpec.Builder loadIntoMethodOfProviderBuilder: PUBLIC Override loadInto(Map<String, RouteMeta> providers) // 用于加载 IProvider 类型的路由信息的 loadInto 方法构造器
  MethodSpec.Builder loadIntoMethodOfRootBuilder: PUBLIC Override loadInto(Map<String, Class<? extends IRouteGroup>> routes) // 用于加载组内映射表的 loadInto 方法构造器
  
  // 分组生成组内映射表
  for (groupName, routeMetas in groupMap):
      MethodSpec.Builder loadIntoMethodOfGroupBuilder: PUBLIC Override loadInto(Map<String, RouteMeta> atlas) // 组内映射表内部用于加载路由信息的 loadInto 方法构造器
      for (routeMeta in routeMetas):
          ClassName className = ClassName.get(routeMeta.getRawType()) // 获取元素类型的类名
          
          // 原项目额外对直接实现 IProvider 接口, 还是实现 IProvider 的子接口进行了区分
          // 这里的处理方式会导致子接口的实现类只能有一个, 难以理解为什么要这么做.
          when routeMeta.getType():
              implement iProvider: 
                  loadIntoMethodOfProviderBuilder.addStatement(
                      "providers.put($S, $T.build($T." + routeMeta.getType() + ", $T.class, $S, $S, null, " + routeMeta.getPriority() + ", " + routeMeta.getExtra() + "))",
                      (routeMeta.getRawType()).toString(),
                      RouteMeta.class,
                      RouteType.class,
                      className,
                      routeMeta.getPath(),
                      routeMeta.getGroup());
              implement subInterface of iProvider:
                  loadIntoMethodOfProviderBuilder.addStatement(
                      ... // 同上
                      subInterface.toString(),
                      ... // 同上
                  );
                  // 示例: providers.put("com.alibaba.android.arouter.demo.testservice.HelloService", RouteMeta.build(RouteType.PROVIDER, HelloService.class, "/service/hello", "service", null, -1, -2147483648));
          
          // 生成支持自动注入的参数类型映射表: Map<String, TypeKind>
          Map<String, Integer> paramsType = routeMeta.getParamsType();
          String paramsTypeMapBody = ""
          for (name, type in paramsType):
              paramsTypeMapBody += "put(\"" + name + "\", " + type + "); "
              // 示例: put("name", 8); put("age", 3);
          
          loadIntoMethodOfGroupBuilder.addStatement(
              "atlas.put($S, $T.build($T." + routeMeta.getType() + ", $T.class, $S, $S, " + (StringUtils.isEmpty(paramsTypeMapBody) ? null : ("new java.util.HashMap<String, Integer>(){{" + paramsTypeMapBody + "}}")) + ", " + routeMeta.getPriority() + ", " + routeMeta.getExtra() + "))",
              routeMeta.getPath(),
              RouteMeta.class,
              RouteType.class,
              className,
              routeMeta.getPath().toLowerCase(),
              routeMeta.getGroup().toLowerCase());
          // 示例: atlas.put("/kotlin/test", RouteMeta.build(RouteType.ACTIVITY, KotlinTestActivity.class, "/kotlin/test", "kotlin", new java.util.HashMap<String, Integer>(){{put("name", 8); put("age", 3); }}, -1, -2147483648));
  
      // 生成最终的组内映射表类文件
      String groupFileName = "ARouter$$Group$$" + groupName;
      JavaFile.builder("com.alibaba.android.arouter.routes", 
          TypeSpec.classBuilder(groupFileName)
              .addSuperinterface(ClassName.get(IRouteGroup.class))
              .addModifiers(Modifier.PUBLIC)
              .addMethod(loadIntoMethodOfGroupBuilder.build())
              .build()
          )
          .build()
          .writeTo(filer);
      // 示例: 
      // package com.alibaba.android.arouter.routes;
      // public class ARouter$$Group$$kotlin implements IRouteGroup {
      //      @Overridepublic void loadInto(Map<String, RouteMeta> atlas) { ... }
      // }
  
      // 缓存根映射表信息
      rootMap.put(groupName, groupFileName);
  
  // 生成根映射表类文件
  for (groupName, groupFileName in rootMap):
      loadIntoMethodOfRootBuilder.addStatement("routes.put($S, $T.class)", entry.getKey(), ClassName.get("com.alibaba.android.arouter.routes", entry.getValue()));
  
  // Provider 的根映射表类文件
  JavaFile.builder("com.alibaba.android.arouter.routes",
      TypeSpec.classBuilder("ARouter$$Providers$$" + moduleName)
          .addSuperinterface(ClassName.get(IProviderGroup.class))
          .addModifiers(Modifier.PUBLIC)
          .addMethod(loadIntoMethodOfProviderBuilder.build())
          .build()
      )
      .build()
      .writeTo(filer);
  
  // Root 的根映射表类文件
  JavaFile.builder("com.alibaba.android.arouter.routes",
      TypeSpec.classBuilder("ARouter$$Root$$" + moduleName)
          .addSuperinterface(ClassName.get(IRouteRoot.class))
          .addModifiers(Modifier.PUBLIC)
          .addMethod(loadIntoMethodOfRootBuilder.build())
          .build()
      )
      .build()
      .writeTo(filer);
                  
  ```

##### arouter-api

ARouter 框架对外暴露的核心类, 用于提供路由表的加载和路由跳转功能. 主要包含以下几个部分(按照包含顺序):

- `ARouter` 类: 单例类, 提供对外暴露给使用者的 API 接口
    - `_ARouter` 类: 单例类, `ARouter` 类中所有接口的代理功能实现类.
        - `LogisticsCenter` 类: 路由表的中心类, 用于加载路由表, 并提供路由跳转的方法.

`ARouter` 对外主要暴露了以下几个主要功能(按照可调用顺序):

- `init` 方法: 线程安全, 初始化 ARouter 框架, 加载路由表(实际加载由 `LogisticsCenter` 执行)
    - `getInstance` 方法: 双检锁获取 ARouter 单例对象实例.
        - `build` 方法: 构造路由请求信息载体类, 用于后续的页面跳转或服务调用, 支持通过 path 和 Uri 进行构建.
            - build 过程支持首先通过注册的 `PathReplaceService` 类型服务对 `path` 或 `Uri` 进行预处理. 默认无此实现.
            - 最终返回一个 `Postcard` 对象, 其内部包含了当前路由请求的所有信息.
            - 后续可以继续通过 `Postcard` 对象进行其他路由参数的设置, 如???.
        - `navigation(service) -> T` 方法: 不需要 path, 直接通过继承自 IProvider 的接口类型获取对应的实现类.
            - 首先通过 `LogisticsCenter` 根据接口类型的名称, 通过`buildProvider` 和 `completion` 内部构造一个 `Postcard` 对象, 包含完整的路由信息.
            - 然后通过 `Postcard` 对象调用 `getProvider` 方法获取对应的实现类.
        - `navigation(context, postcard, requestCode, callback) -> Object` 方法: 通过构造的 Postcard 对象进行跳转.
            - 第一步支持使用注册的预处理服务 `PretreatmentService` 确认是否需要跳转.
            - 第二步通过 `LogisticsCenter` 的 `completion` 方法完成路由路径的加载. 这里支持加载失败时通过注册的 `DegradeService` 降级服务进行降级处理.
            - 第三步通过 `InterceptorService` 服务执行所有的拦截器, 并在拦截器执行完成后执行路由跳转.
                - `ACTIVITY` 类型的路由跳转通过 `startActivity` 方法进行跳转, 支持结果回调, 转场动画, 额外参数等.
                - `PROVIDER` 类型的路由跳转可以直接获取对应的实现类.
                - `BOARDCAST|CONTENT_PROVIDER|FRAGMENT` 类型的路由跳转直接返回实际对象, FRAGMENT会注入额外的参数.
                - `METHOD|SERVICE` 类型的路由不支持, 直接返回 null.
        - `addRouteGroup` 方法: 动态添加路由组信息, 一般用于按需加载插件时使用.
        - `inject` 方法: 通常在需要注入参数的对象中调用, 实现为当前对象自动注入参数.
            - 方法通过固定 `path` 获取 `AutowiredService` 接口的实现类.
            - 基础实现见 `AutowiredServiceImpl` 类, 此类通过利用自动生成的注入帮助类(见 `@Autowired` 注解处理过程)实现自动注入参数.
            - 注入过程是递归的, 会递归注入目的对象及其父类的可支持注入的所有属性.
            - 注入参数来自于路由 `Postcard` 对象通过 `with` 或 `withXxx` 方法设置的参数.

`LogisticsCenter` 类主要提供了以下几个功能:

- `init` 方法: 加载所有本地路由表到内存中.
    - 加载原理 1: 运行时通过 DexFile 加载 dex 文件中的所有类名, 并通过反射加载路由表.
        - 首先通过 apk 文件, 以及 Android5.0 以下 secondary-dexes 文件夹下所有的额外的 dex 文件压缩包文件去获取 dex 文件的路径.
        - 然后通过 DexFile 类加载 dex 文件, 获取 dex 文件中所有的类名, 并过滤掉不符合要求的类名, 即不包含指定包名的类名. (java最终生成类文件的类名是包名 + 代码类名)
        - 缓存所有的类名, 用于后续的路由表通过缓存加速加载.
        - 遍历所有的类名, 分种类(`IRouteRoot`, `IInterceptorGroup`, `IProviderGroup`)的通过反射构造对应类对象, 并调用其 `loadInto` 方法加载路由表到 Warehouse 的全局静态变量中(即内存中的路由表). 注意此时加载的仅是根映射表, 服务提供者, 拦截器提供者的类信息映射关系. 完整的加载会在后续的路由跳转时按需进行.
    - 加载原理 2: 编译时通过 `arouter-auto-register` 插件生成的 `loadRouterMap` 方法加载路由表.
- `buildProvider` 方法: 根据接口类型的全名或小名获取对应的实现类.
    - 首先通过接口类型的名称从内存中的路由表中获取对应的 `RouteMeta` 对象.
    - 然后通过 `RouteMeta` 对象存有的目标类类型信息构造 `Postcard` 对象.
- `completion` 方法: 通过 `Postcard` 对象完成整体路由路径上的所有信息的加载.
    - 首先通过 `Postcard` 对象获取路由路径所在组, 并通过组名加载对应的组内映射表.
    - 然后通过组内映射表获取对应的目标的 `RouteMeta` 对象, 利用其存储的路由信息和目标类类型信息继续完善 `Postcard` 对象. 注意, 这里包含 uri 中 Query 参数的解析(仅支持可注入参数)和 provider 的构建.

`Postcard` 类: 路由请求的载体类, 扩展了 `RouteMeta`, 用于进一步封装路由请求的所有信息.

- 参数 (`ARouter` 的 `build` 路由请求构造过程可选手动设置的参数):
    - `path: String`: 路由跳转路径, 一般为 `@Route` 注解中的 `path` 属性或 `Uri` 对象的 `path` 属性.
    - `group: String`: 路由路径所在组, 一般为默认组(路径第一个 `/` 后的字符串, 没有则分组为 null).
    - `uri: Uri`: 路由跳转的 Uri, 一般用于深度链接跳转内部页面, 其 `path` 属性为路由跳转路径, 其他属性待定.
    - `mBundle: Bundle`: 路由跳转时要传递给目标对象的参数, 可以通过 `with` 或 `withXxx` 方法设置参数.
    - `timeout: Long`: 路由跳转超时时间, 默认用于控制设置的拦截器执行的超时时间.
    - `greenChannel: Boolean`: 是否使用绿色通道, 用于跳过拦截器.
    - `flags: Int`: 用于控制 Activity 类型路由请求的行为标志位, 如 `FLAG_ACTIVITY_NEW_TASK` 等.
    - `enterAnim: Int | exitAnim: Int`: 用于控制 Activity 类型路由请求的进入和退出动画效果.
    - `optionsCompat: ActivityOptionsCompat`: 用于控制 Activity 类型路由请求的转场动画效果, 仅在 Android 5.0 以上有效.
    - `action: String`: 用于控制 Activity 类型路由请求的行为, 如 `Intent.ACTION_VIEW` 等.
- 参数(`ARouter` 的 `navigation` 过程自动设置的参数):
    - `type: RouteType`: 路由类型.
    - `rawType: Element`: 路由目标类原始信息
    - `destination: Class<?>`: 路由目标类具体
    - `priority: int`: 路由优先级.
    - `extra: int`: 路由附加信息.
    - `paramsType: Map<String, Integer>`: 路由注入的所有参数类型.
    - `name: String`: 路由名称.
    - `injectConfig: Map<String, Autowired>`: 路由注入的所有参数配置.
    - `provider: IProvider`: 存储 IProvider 类型的实现类, 会由 `LogisticsCenter` 自动加载.
    - `serializationService: SerializationService`: 序列化服务, 用于序列化和反序列化参数.
    - `context: Context`: 路由请求的上下文.
- `navigation(__)` 类型方法, 用于发起由 `path` 或 `Uri` 构造的路由请求, 支持返回对象实例和回调等.
    - 实际路由跳转过程主要是通过 `ARouter` 的 `navigation(context, ...)` 方法实现.

##### arouter-gradle-plugin

## 插件化框架

插件化框架的核心目标是在原有 app 的基础上, 实现动态加载一个或多个插件(独立 apk 或 jar 文件), 并在 app 中使用插件中的功能和资源. 独立出来的插件可以单独进行开发, 测试, 发布, 升级等流程, 从而实现一些比较重要的功能, 如模块化开发, 动态更新, 热修复, 功能扩展等功能.

因为涉及到 app 和插件之间的交互, 所以插件化框架的实现一般需要解决以下几个问题(不同的插件化框架可能会有不同的实现方式):

- 插件代码加载
- 系统组件注册
- 资源加载
- 插件和宿主, 以及插件和插件之间的通信

### RePlugin 解析

360 开源的一个 Android 插件化框架.

#### 设计理念

- 插件代码加载: 通过类加载器 `ClassLoader` 实现插件的加载和卸载.
- 系统组件注册: 通过坑位组件实现插件中的组件(如 Activity)的注册.
- 资源加载: 

#### 使用介绍

#### 源码解析

RePlugin 包含编译时和运行时两部分, 同时又区分了宿主和插件两种不同的角色. 编译时宿主会通过 `replugin-host-gradle` 插件自动生成插件化框架所需的配置文件, 插件信息, 辅助类文件等. 运行时宿主会通过 `replugin-host-lib` 模块加载插件, 并实现插件的加载, 卸载, 组件注册, 资源加载等操作.

##### 前置知识

> [!cite]
> ![[Gradle#Gradle 插件开发|Gradle 插件开发]]
> Android Binder 通信机制
> Android ClassLoader 原理
> Android 四大组件启动流程

##### replugin-host-gradle (宿主插件)

##### replugin-host-lib (宿主库)

##### replugin-plugin-gradle (插件插件)

##### replugin-plugin-lib (插件库)
