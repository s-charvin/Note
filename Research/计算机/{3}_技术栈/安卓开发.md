---
tags: 
title: 安卓开发
description: ""
author: ""
categories: ""
keywords:
  - ""
draft: true
layout: ""
date: 2024-07-31 10:44:21
lastmod: 2024-08-12 13:47:23
---

> [!todo]
> https://developer.android.com/courses/android-basics-compose/course
> https://developer.android.com/courses/unit/kotlin-basics-unit-1
> https://www.geeksforgeeks.org/kotlin-android-tutorial/
> https://developer.android.com/courses/




## Android 应用程序组成

### 清单文件 `AndroidManifest.xml`

安卓操作系统与安卓应用程序之间由清单文件 `AndroidManifest.xml` 进行连接, 该清单文件位于应用程序的根目录下, 用于告知系统应用程序的基本信息, 如应用程序的名称、图标、版本号、权限以及各种组件等. 


以下是一个简单的清单文件示例及其内容解析:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <!-- 应用程序信息 -->
    <application
        android:name=".MyApplication"
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.MyApplication3"
        tools:targetApi="31">

        <!-- 活动声明 -->
        <activity
            android:name=".MainActivity"
            android:launchMode="singleTop"
            android:taskAffinity=""
            android:allowTaskReparenting="true"
            android:exported="true"
            android:label="@string/title_activity_main"
            android:permission="com.example.MY_PERMISSION"
            >
        <intent-filter>
            <action android:name="android.intent.action.MAIN" />
            <category android:name="android.intent.category.LAUNCHER" />
        </intent-filter>
        </activity>

        <activity
            android:name=".SecondActivity"
            android:exported="true"
            android:label="@string/title_activity_second">
        <intent-filter>
            <action android:name="com.example.SECOND" />
            <category android:name="android.intent.category.DEFAULT" />
        </intent-filter>
        </activity>

        <!-- 服务声明 -->
        <service
            android:name=".MyService"
            android:exported="true">
            <intent-filter>
                <action android:name="com.example.MY_SERVICE" />
            </intent-filter>
        </service>

        <!-- 广播接收器声明 -->
        <receiver
            android:name=".MyReceiver"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.BOOT_COMPLETED" />
            </intent-filter>
        </receiver>

        <!-- 内容提供程序声明 -->
        <provider
            android:name=".MyProvider"
            android:authorities="com.example.myprovider"
            android:exported="true"
            android:grantUriPermissions="true">
            <grant-uri-permission android:pathPattern="/myprovider/*" />
            </provider>
    </application>

    <!-- 权限声明 -->
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission android:name="android.permission.CAMERA" />
    <uses-permission android:name="android.permission.RECORD_AUDIO" />
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />

    <!-- 使用特性 -->
    <uses-feature android:name="android.hardware.camera" />
    <uses-feature android:name="android.hardware.microphone" />
    <uses-feature android:name="android.hardware.location.gps" />

</manifest>
```

**顶部声明**
- `<?xml version="1.0" encoding="utf-8"?>`：声明 XML 文件的版本和编码方式. 
- `<manifest>`：根元素, 包含应用的所有配置. 
    - `xmlns:android="http://schemas.android.com/apk/res/android"`：定义 `android` 命名空间, 用于引用安卓系统提供的属性. 
    - `xmlns:tools="http://schemas.android.com/tools"`：定义 `tools` 命名空间, 用于引用开发工具 (如 Android Studio) 提供的一些自定义属性. 
**`<application>` 元素**

包含应用级别的配置信息, 定义应用的全局属性和组件. 
- `android:name=".MyApplication"`: 指定应用的自定义 `Application` 类. 
- `android:allowBackup="true"`: 允许用户备份和恢复应用的数据. 
- `android:dataExtractionRules="@xml/data_extraction_rules"`: 指定数据提取规则, 通常用于自动备份功能. 
- `android:fullBackupContent="@xml/backup_rules"`: 指定完整备份内容的规则. 
- `android:icon="@mipmap/ic_launcher"`: 指向用于标识应用的图标的资源
- `android:label="@string/app_name"`: 指定应用的显示名称. 
- `android:roundIcon="@mipmap/ic_launcher_round"`: 指定圆形应用图标 (通常用于圆形图标需求的设备). 
- `android:supportsRtl="true"`: 指定应用是否支持从右到左 (RTL) 的布局方向. 
- `android:theme="@style/Theme.MyApplication3"`: 指定应用的主题. 
- `tools:targetApi="31"`: 指定目标 API 级别, 主要用于开发工具进行静态代码检查, 不影响实际运行时的行为. 

**`<activity>` 元素**

定义一个活动 (Activity), 是应用的一个主要组件, 代表一个用户界面. 
- `android:name=".MainActivity"`: 指定活动的类名, `.MainActivity` 表示该活动在应用包名下. 
- `android:launchMode="singleTop"`: 指定活动的启动模式. 这里是 `singleTop`, 表示如果活动已经在栈顶, 不会重新创建新的实例. 
- `android:taskAffinity=""`: 指定活动的任务亲和性, 控制活动创建时所在的任务栈. 默认会在当前任务栈, 如果设置了亲和值, 则会寻找具有相同亲和值的任务栈, 如果没有则创建新的任务栈.
- `android:allowTaskReparenting="true"`: 指定当活动所在任务栈进入前台时, 是否可以将活动移动到其他具有相同亲和性的任务栈.
- `android:clearTaskOnLaunch="true"`: 每当用户离开该任务并再次返回时, 任务栈中的所有活动都会被清除, 仅保留根活动.
- `android:alwaysRetainTaskState="true"`: 拒绝系统在用户长时间离开任务栈时清除除了根活动之外的所有活动.
- `android:finsihOnTaskLaunch="true"`: 指定活动是否在任务启动时结束.
- `android:exported="true"`: 指定活动是否可以由应用之外的组件启动. `true` 表示可以被其他应用访问. 
- `android:label="@string/title_activity_main"`: 指定活动的显示名称. 
- `android:permission="com.example.MY_PERMISSION"`: 指定活动自身被调用时需要的权限.
- `<intent-filter>`: 定义了活动能够响应的意图 (Intent) , 通常用于配置应用的启动活动和处理特定的动作. 
    - `<action>`: 定义意图的动作. 
        - `android:name="android.intent.action.MAIN"`: 表示该活动是应用的主入口点, 会为其创建程序图标.
        - `android:name="com.example.SECOND"`: 自定义的动作名称. 
    - `<category>`: 定义意图的类别. 
        - `android:name="android.intent.category.LAUNCHER"`: 表示该活动会出现在应用启动器中, 作为应用的启动活动. 
        - `android:name="android.intent.category.DEFAULT"`: 默认的意图类别. 

**`<service>` 元素**

定义一个服务 (Service) , 是一个后台运行的组件, 用于执行长时间运行的操作. 
- `android:name=".MyService"`: 指定服务的类名. 
- `android:exported="true"`: 指定服务是否可以被其他应用访问. 
- `<intent-filter>`: 定义了服务能够响应的意图. 
    - `<action>`: 定义意图的动作. 
        - `android:name="com.example.MY_SERVICE"`: 自定义的动作名称. 

**`<receiver>` 元素**

定义一个广播接收器 (Broadcast Receiver) , 用于接收系统广播事件. 
- `android:name=".MyReceiver"`: 指定广播接收器的类名. 
- `android:exported="true"`: 指定广播接收器是否可以被其他应用访问. 
- `<intent-filter>`: 定义了广播接收器能够响应的意图. 
    - `<action>`: 定义意图的动作. 
        - `android:name="android.intent.action.BOOT_COMPLETED"`: 表示系统启动完成后发送的广播. 

**`<provider>` 元素**

定义一个内容提供程序 (Content Provider) , 用于管理应用程序的数据集. 
- `android:name=".MyProvider"`: 指定内容提供程序的类名. 
- `android:authorities="com.example.myprovider"`: 指定内容提供程序的权限. 
- `android:exported="true"`: 指定内容提供程序是否可以被其他应用访问. 
- `android:grantUriPermissions="true"`: 指定内容提供程序是否授予 URI 权限. 
- `<grant-uri-permission>`: 定义了内容提供程序授予的 URI 权限. 
    - `android:pathPattern="/myprovider/*"`: 匹配 URI 的路径模式. 

**`<uses-permission>` 元素**

定义应用程序需要的权限. 
- `android:name="android.permission.INTERNET"`: 访问互联网的权限. 
- `android:name="android.permission.ACCESS_NETWORK_STATE"`: 访问网络状态的权限. 
- `android:name="android.permission.CAMERA"`: 使用摄像头的权限. 
- `android:name="android.permission.RECORD_AUDIO"`: 录制音频的权限. 
- `android:name="android.permission.ACCESS_FINE_LOCATION"`: 访问精确位置的权限. 

**`<uses-feature>` 元素**

定义应用程序需要的硬件功能. 
- `android:name="android.hardware.camera"`: 摄像头硬件功能. 
- `android:name="android.hardware.microphone"`: 麦克风硬件功能. 
- `android:name="android.hardware.location.gps"`: GPS 定位硬件功能. 

### 应用程序基础: Application

应用程序的基础是 `Application` 类, 一个单例类, 每个应用程序都有一个 `Application` 实例, 它是整个应用程序的入口点, 负责应用程序的初始化和全局状态的管理, 可以通过 `getApplication()` 方法获取. 
- 在应用程序启动时初始化一些全局的资源或配置, 例如第三方库 (如分析工具、数据库库等). 
- 在应用程序的生命周期中管理全局状态, 例如用户登录状态、网络连接状态等. 
- 监控整个应用程序的生命周期, 处理一些全局的状态变化. 
    - `onCreate()`: 应用程序创建时调用. 
    - `onTerminate()`: 应用程序终止时调用. 

```kotlin
class MyApplication : Application() {
    override fun onCreate() {
        super.onCreate()
        // 初始化Firebase
        FirebaseApp.initializeApp(this)
        // 初始化Crashlytics
        Fabric.with(this, Crashlytics())
        // 初始化数据库
        Realm.init(this)
        // 初始化全局数据
        someGlobalData = "This is some global data"
    }
}
```

### 应用程序四大组件: 活动、服务、广播接收器、内容提供程序

Android 应用程序由四个主要组件组成:
- 活动 (Activity): 用户与应用程序进行交互的主要入口点, 通常表示一个具有用户界面的屏幕
- 服务 (Service): 在后台执行长时间运行的操作或远程处理
- 广播接收器 (Broadcast Receiver): 在系统广播事件发生时接收系统广播
- 内容提供程序 (Content Provider): 管理应用程序的数据集

活动可以启动服务来执行后台任务; 注册广播接收器来接收系统或应用的广播以更新 UI; 使用内容提供程序来访问和管理数据; 启动其他活动, 并传递数据. 

广播接收器被动接收系统或应用的广播事件, 然后可以启动服务来执行后台任务, 也可以通过内容提供程序来访问和管理数据. 

服务通常是由活动或广播接收器启动, 可以通过内容提供程序来访问和管理数据. 

内容提供程序为程序提供标准的数据管理接口, 包括查询、插入、更新和删除. 

此外还有些附加组件:
- 片段 (Fragment): 可重用的 UI 组件
- 意图 (Intent): 用于在组件之间传递消息
- 视图 (View): 用户界面的构建块
- 布局 (Layout): 定义视图的结构和外观
- 资源 (Resource): 应用程序的非代码资源, 如图像、字符串和布局文件

#### 活动 (Activity)

每个活动都是一个类, 继承自 `Activity` 类或其子类, 用于表示 Android 应用程序用户界面的一个屏幕. Android 应用启动时, 会首先进入设置的主 `Activity` 的初始化过程. 此外, 每个应用程序可以包含多个活动, 所有活动必须在清单文件 `AndroidManifest.xml` 中进行声明, 当一个应用调用另一个应用时, 发起调用的应用可以调用另一个应用中的其他 `activity`. 例如, 浏览器应用可能会启动社交媒体应用的分享 `activity`.

每个活动都有一个生命周期, 包括以下主要状态:
- `onCreate(Bundle savedInstanceState)`: 活动创建时调用
- `onStart()`: 活动开始时调用, 初始化的资源应在 `onStop` 释放
- `onResume()`: 活动恢复时调用(可见且在前台 )  <-----|
- `onPause()`: 活动暂停时调用(可见但不在前台)  ----->|  不建议释放与 ui 相关的资源和耗时操作
- `onStop()`: 活动停止时调用(不可见), 系统会自动保存组件状态, 即使活动被销毁.
- `onRestart()`: 活动重新启动时调用
- `onDestroy()`: 活动销毁时调用

辅助方法:
- `onSaveInstanceState(Bundle outState)`: 保存活动除布局或视图之外的自定义状态, 以便在活动重新创建时恢复, 缺点是只能保存少量数据, 因为要在主线程进行序列化操作.
- `onRestoreInstanceState(Bundle savedInstanceState)`: 恢复保存的状态, 与 `onSaveInstanceState` 配合使用, 一般使用 `onCreate` 方法就足够了.
- `startActivity(Intent intent, Bundle options)`: 启动另一个活动
- `startActivityForResult(Intent intent, int requestCode)`: 启动另一个活动并获取结果, 结果通过 `onActivityResult` 方法返回
- `setResult(int resultCode, Intent data)`: 当被其他活动启动时, 设置返回结果. 
- `onActivityResult(int requestCode, int resultCode, Intent data)`: 当其他活动响应了 `Intent` 后, 并通过 `setResult` 设置了返回结果, 会调用此方法. 

自定义默认启动活动模式
- `launchMode.standard`: 标准模式, 每次启动都会创建新的实例, 并将启动时的 `Intent` 传递给新的实例. 比如新闻应用中每次点击文章链接都会创建新的文章页面实例.
- `launchMode.singleTop`: 栈顶复用模式, 如果活动已经在栈顶, 不会重新创建新的实例, 而是调用 `onNewIntent` 方法来处理新的 `Intent`. 如果活动不在栈顶, 会创建新的实例. 比如点击消息通知栏的消息进入消息详情页面, 如果在消息通知栏消失前点击多次, 不会创建新的实例, 而是复用当前页面.
- `launchMode.singleTask`: 栈内复用模式, 如果活动已经在栈中, 会将该活动上面的所有活动出栈, 并调用 `onNewIntent` 方法来处理新的 `Intent`. 如果活动不在栈中, 会创建新的实例. 比如点击应用图标或导航栏的主页面, 我的页面等进入页面, 如果页面已经在栈中, 会将页面上面的所有活动出栈`.
- `launchMode.singleInstance`: 单实例模式, 如果没有包含此活动的任务栈, 则创建一个单独的任务栈管理此活动, 并且该活动独占任务栈, 不会与其他活动共享任务栈. 如果已经有包含此活动的任务栈, 则直接把此任务栈置于前台展示, 不会创建新的实例. 比如播放视频的全屏模式, 独立登录页面等, 会创建一个新的任务栈, 并且独占任务栈.
- `launchMode.singleInstancePerTask`: 单示例和栈内复用模式, 如果没有包含此活动的任务栈, 则创建一个单独的任务栈管理此活动, 此活动会置于栈底, 后续启动的活动也会在此任务栈中. 如果已经有包含此活动的任务栈, 则直接把此任务栈置于前台展示, 不会创建新的实例, 同时将此活动顶部的其他活动出栈. 


```kotlin
class MainActivity : AppCompatActivity() {
    lateinit var textView: TextView
    var gameState: String? = null
    var currentScore = 0
    var currentLevel = 0
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        if (savedInstanceState != null) {
            with(savedInstanceState) {
                gameState = getString(GAME_STATE_KEY)
                textView.text = getString(TEXT_VIEW_KEY)
                currentScore = getInt(STATE_SCORE)
                currentLevel = getInt(STATE_LEVEL)
            }
        }
        setContentView(R.layout.activity_main)
        textView = findViewById(R.id.text_view)
    }

    override fun onStart() {
        super.onStart()
        Log.d(TAG, "onStart")
    }

    override fun onResume() {
        super.onResume()
        Log.d(TAG, "onResume")
    }

    override fun onPause() {
        super.onPause()
        Log.d(TAG, "onPause")
    }

    override fun onStop() {
        super.onStop()
        Log.d(TAG, "onStop")
    }

    override fun onSaveInstanceState(outState: Bundle?) {
        outState?.run {
            putString(GAME_STATE_KEY, gameState)
            putString(TEXT_VIEW_KEY, textView.text.toString())
            putInt(STATE_SCORE, currentScore)
            putInt(STATE_LEVEL, currentLevel)
        }
        // Call superclass to save any view hierarchy.
        super.onSaveInstanceState(outState)
    }
}
```



活动之间可以通过意图 (Intent) 进行通信, 意图可以用于启动活动、启动服务、发送广播等. 

#### 服务 (Service)

服务是可以在后台执行长时间运行操作或远程处理(下载文件、播放音乐、更新数据等)的组件, 不提供用户界面, 即使应用程序处于后台或被销毁, 服务仍然可以继续运行. 每个服务都是一个类, 继承自 `Service` 类或其子类. 服务必须在清单文件 `AndroidManifest.xml` 中进行声明. 

服务可以通过活动的 `startService()` 或 `bindService()` 方法启动, 通过 `stopService()` 或 `unbindService()` 方法停止. 区别在于 `startService()` 启动的服务会一直运行, 直到调用 `stopService()` 停止, 而 `bindService()` 是在其他 app 或系统组件中绑定服务, 绑定后服务会一直运行直到所有绑定的组件都解绑. 

每个服务也有一个生命周期, 包括以下主要状态:
- `onStartCommand()`: 服务启动时调用
- `onCreate()`: 服务创建时调用
- `onBind()`: 服务绑定时调用
- `onUnbind()`: 服务解绑时调用
- `onRebind()`: 服务重新绑定时调用
- `onDestroy()`: 服务销毁时调用

#### 广播接收器 (Broadcast Receiver)

广播接收器是用于接收系统或应用的广播事件的组件, 当特定事件发生时, 广播接收器会接收并处理广播消息. 每个广播接收器都是一个类, 继承自 `BroadcastReceiver` 类或其子类. 广播接收器必须在清单文件 `AndroidManifest.xml` 中进行声明. 

广播接收器可以通过 `registerReceiver()` 方法注册, 通过 `unregisterReceiver()` 方法注销. 也可以通过清单文件声明静态注册, 这样即使应用程序未运行, 也可以接收广播. 

广播接收器可以接收系统广播事件, 常见的系统广播事件包括:
- `android.intent.action.BOOT_COMPLETED`: 系统启动完成时发送的广播
- `android.intent.action.SCREEN_ON`: 屏幕开启时发送的广播
- `android.intent.action.SCREEN_OFF`: 屏幕关闭时发送的广播
- `android.intent.action.ACTION_POWER_CONNECTED`: 充电器连接时发送的广播
- `android.intent.action.ACTION_POWER_DISCONNECTED`: 充电器断开时发送的广播
- `android.intent.action.BATTERY_LOW`: 电池电量低时发送的广播
- `android.intent.action.BATTERY_OKAY`: 电池电量恢复正常时发送的广播

广播接收器也可以通过活动的`sendBroadcast()` 方法发送自定义的广播事件. 

#### 内容提供程序 (Content Provider)

内容提供程序是用于管理应用程序的数据集的组件, 提供包括查询、插入、更新和删除等数据接口, 支持跨应用程序访问数据. 存储方式包括数据库, 文件, 网络等.

每个内容提供程序都是一个类, 继承自 `ContentProvider` 类或其子类. 内容提供程序必须在清单文件 `AndroidManifest.xml` 中进行声明. 

内容提供程序可以通过查询, 插入, 更新和删除方法来操作数据. 想访问内容提供程序可以通过预定义的 URI (Uniform Resource Identifier) 来标识和访问数据集, URI 由以下部分组成:`<prefix>://<authority>/<data_type>/<id>`

`ContentProvider` 类中的方法:
- `query()`: 查询数据
- `insert()`: 插入数据
- `update()`: 更新数据
- `delete()`: 删除数据
- `getType()`: 获取数据类型
- `onCreate()`: 当提供者被启动时调用

#### 意图 (Intent)

意图是一种异步消息传递机制, 


意图是用于在组件之间异步传递消息的对象, 用于在将组件绑定, 同时在组件之间传递消息, 如启动活动、启动服务、发送广播等. 
- 显式意图 (Explicit Intent): 指定要启动的组件的类名, 如告诉系统在 Gmail 应用程序中启动发送电子邮件的 `Activity`. 启动时可以修改组件的启动模式.
- 隐式意图 (Implicit Intent): 指定要执行的操作, 由系统根据意图的动作和数据类型选择合适的组件, 然后系统 UI 询问用户选择哪个应用程序来处理该意图, 如在任何可以完成发送电子邮件工作的活动中启动发送电子邮件的 `Activity`.

标志:
- `FLAG_ACTIVITY_NEW_TASK`: 对应 `launchMode` 的 `singleTask`
- `FLAG_ACTIVITY_SINGLE_TOP`: 对应 `launchMode` 的 `singleTop`
- `FLAG_ACTIVITY_CLEAR_TOP`: 如果正在启动的活动已经在当前任务中运行, 那么系统将销毁其上的所有其他活动, 而不是启动该活动的新实例.
- `FLAG_ACTIVITY_CLEAR_TOP` + `FLAG_ACTIVITY_NEW_TASK`: 如果正在启动的活动已经在当前任务中运行, 那么系统将销毁其上的所有其他活动, 并将此活动置于新任务的顶部.

```xml
<uses-permission android:name="com.example.MY_PERMISSION" /> <!-- 调用其他活动需要申请对应活动定义的权限 -->

<activity android:name=".ExampleActivity">
    <intent-filter>
        <action android:name="com.example.EXAMPLE_ACTION" /> <!-- 自定义的动作名称 -->
        <category android:name="android.intent.category.DEFAULT" /> <!-- 默认的意图类别, 表示该活动可以接收启动意图 -->
        <data android:mimeType="text/plain" /> <!-- 可以发送的数据类型 -->
    </intent-filter>
</activity>
```

```kotlin
// 调用意图
val intent = Intent(this, ExampleActivity::class.java)
intent.action = "com.example.EXAMPLE_ACTION"
intent.type = "text/plain"
intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
startActivity(intent)
```


## 项目架构

### 架构原则

原则:
- 组件分离
  - 单一职责
  - 高内聚低耦合
    - 不要将 `ViewModel` 传入 `RecyclerView` 等视图的适配器(Adapter), 而是通过适配器或视图状态的 Callback 接口实现 ViewModel 的访问.
- 通过数据模型驱动界面
  - 尽量持久化存储
- 单一数据源
  - 分配单一的数据持有者
  - 只有持有者可以修改或转变数据, 修改尽量通过提供接口来实现

### 架构结构

UI Layer(界面层, 唯一职责是使用和显示界面状态)
- 界面: 使用 `View` 或 `Jetpack Compose` 等构建视图元素来呈现数据.
  - 界面会向状态容器发送用户事件通知, 状态容器会处理事件对应的逻辑并更新界面状态. 
  - 界面通过使用适当的生命周期感知型协程构建器从状态容器收集最新的界面状态(View: `repeatOnLifecycle`, Compose: `collectAsStateWithLifecycle`). (循环往复)
  - 如果界面不可见或未处于活动状态, 除非明确要求, 否则状态生成和收集的过程可以暂停, 防止消耗任何资源. (生命周期感知型协程构建器会自动控制)
  - 不要替换 activity 或 fragment 的生命周期方法, 可以改为使用 `LifecycleObserver` 监听生命周期事件. 或是通过 `repeatOnLifecycle` 来监听生命周期状态事件(`CREATED`、`DESTROYED`、`INITIALIZED`、`RESUMED`、`STARTED`).
- 界面状态: 由状态容器提供, 向界面提供数据(`_UiState`, 类似于 `Model`, 尽可能是不可变的.).
  - 要显示的数据, 控制是否要展示的状态, 控制是否要跳转的状态, 界面的回调函数, 界面的补充信息(突然要弹窗展示的信息)
- 状态容器: 负责存储和提供界面状态, 并且包含执行相应任务所必需的处理逻辑.
  - 状态容器分两种, 一种由普通的类实现(界面逻辑状态容器), 绑定到界面的生命周期, 存储不需要长期保留的界面状态和界面逻辑. 一个种由 `ViewModel` 实现(业务逻辑状态容器), 用于处理业务逻辑, 将数据从数据层或网域层转换为屏幕界面状态, 通过数据流向界面提供数据, 通过回调函数向界面提供事件处理逻辑.
  - `ViewModel` 不要放入容器视图的适配器中, 会增加耦合, 可以通过采用回调的方式(界面状态中放回调或适配器定义回调参数)进行.
  - 在 `ViewModel` 中应该立即处理事件, 并通过事件的处理结果引发状态更新, 而不能将来自 `ViewModel` 的事件发送到界面.
  - `ViewModel` 不要存储对任何与生命周期相关的类型的引用, 如 `Activity`, `Fragment`, `Context` 或 `Resources` 作为依赖项传递. 因为 `ViewModel` 生命周期长, 持有的引用在设备状态更改导致被销毁重建时, 旧实例无法被垃圾回收.
  - `ViewModel` 通过数据流(`StateFlow`, `LiveData`)向界面提供界面状态数据, 通过回调函数向界面提供事件处理逻辑.
  - `ViewModel` 通过内置的协程作用域 `viewModelScope` 来执行异步任务(`suspend` 函数), 如从数据源获取数据以及更新界面状态数据.
  - `ViewModel` 应该在屏幕级别的组件中使用, 如 `activity`, `fragment` 等屏幕级别的组件. 对于嵌套的 `fragment`, 如果与父级共享一个 `ViewModel`, 可以通过 `ViewModelProvider` 来获取父级 `fragment` 的 `ViewModel`.
- 界面事件(包括用户交互、本地资源状态改变、外部资源状态改变产生的事件等)
  - 如果事件需要执行界面逻辑 (与修改界面元素的状态相关, 如可展开项的状态) , 界面便可以直接处理这些事件. 
  - 如果事件需要执行业务逻辑 (如刷新屏幕上的数据, 更新数据库数据) , 则应用由 `ViewModel` 处理此事件. 

Domain Layer(网域层, 负责封装复杂的业务逻辑, 或者由多个 `ViewModel` 重复使用的简单业务逻辑)
- 合并数据层的多个存储库数据
- 存储可重复使用的简单业务逻辑, 相比于存放在 `Utils` 类中, 使得业务逻辑更加清晰, 便于维护.

Data Layer(数据层, 负责处理数据的获取和存储)
- 由多个存储库(`Repositories`)组成, 其中每个存储库都可以包含零到多个数据源(`Data Sources`).
- 存储库负责处理数据变化, 解决不同数据源冲突, 对数据源抽象化处理, 编码业务逻辑, 提供公开数据访问的函数接口.
- 每个数据源类仅负责处理一个数据源, 数据源可以是文件、网络来源或本地数据库(数据库、`DataStore`、`SharedPreferences`、Firebase API、GPS 位置信息提供程序、蓝牙数据提供程序、网络连接状态提供程序), 且只能由存储库访问.
- 多个存储库可以组合成一个 Manager 存储库, 以便在一个存储库中处理多个数据源.
- 数据源尽可能包含本地数据源和远程数据源, 以便在没有网络连接时使用本地数据源.
- 调用数据源或存储库时, 推荐通过协程(或多线程)来异步获取数据以及与保持数据在不同层之间的流动, 以避免阻塞主线程. 耗时长的操作可以通过 `WorkManager` 来执行. 比如在程序启动时在后台逐一初始化数据源, 以避免启动时的卡顿.
- 从网络数据源读取数据时, 可以通过指数退避算法需要处理网络连接失败、超时等异常情况.

#### 生命周期感知型组件

`Activity` 或 `Fragment` 通常会在其生命周期中执行一些操作, 如初始化数据、加载数据、释放资源等. 普通的生命周期方法在编写时会导致代码冗长, 比如初始化和释放资源的代码分散在了多个生命周期方法中, 使代码难以维护. 不同声明周期方法是异步执行的, 因为执行时间不同, 有时候可能会导致不同的生命周期方法之间的数据不一致.

生命周期感知型组件用于解决这些问题, 通过 `Lifecycle`(`LifecycleRegistry` 是其具体实现的类) 和 `LifecycleObserver`(`DefaultLifecycleObserver` 和 `LifecycleEventObserver` 是其具体实现的类) 来观察和响应具有生命周期变化的组件(如 `Activity` 或 `Fragment`等实现了 `LifecycleOwner` 接口的组件)的生命周期事件, 从而在生命周期状态发生变化时执行相应的操作.

- `Lifecycle`(`LifecycleRegistry`) 存储了具有生命周期变化的组件的生命周期状态, 并且可以在生命周期状态发生变化时通知所有注册的 `LifecycleObserver` 对象. 通过`addObserver()` 方法来添加 `LifecycleObserver` 对象, 通过 `removeObserver()` 方法来移除 `LifecycleObserver` 对象.
- `DefaultLifecycleObserver` 是一个接口, 用于观察具有生命周期变化的组件的生命周期事件, 从而在生命周期状态发生变化时执行相应的操作. 通过实现 `LifecycleObserver` 接口并重写 `onCreate()`, `onStart()`, `onResume()`, `onPause()`, `onStop()`, `onDestroy()` 等方法来执行相应的操作. 
- `LifecycleEventObserver` 是一个接口, 用于观察具有生命周期变化的组件的生命周期事件, 从而在生命周期状态发生变化时执行相应的操作. 通过实现 `LifecycleEventObserver` 接口并重写 `onStateChanged()` 方法来执行相应的操作. 如果同时实现了 `DefaultLifecycleObserver` 接口, 则 `DefaultLifecycleObserver` 的方法会优先执行.

注意事项:
- 当 `onSaveInstanceState()` 被调用时, Android 认为当前的 UI 状态应该被保存, 因此不建议在这之后再更改 UI. 然而, `onStop()` 通常在 `onSaveInstanceState()` 之后调用, 此时 `Lifecycle` 会从 `RESUMED` 变为 `CREATED`, 分发 `ON_STOP` 事件. 如果在 `onSaveInstanceState()` 和 `onStop()` 之间对 UI 进行更改, 可能导致应用导航状态不一致. [这是个问题](https://developer.android.com/topic/libraries/architecture/lifecycle?hl=zh-cn#onStop-and-savedState)!

```kotlin
class MyObserver : DefaultLifecycleObserver {
    override fun onCreate(owner: LifecycleOwner) {
        // 在 onCreate() 方法中执行初始化操作
    }

    override fun onDestroy(owner: LifecycleOwner) {
        // 在 onDestroy() 方法中执行释放资源操作
    }
}

class MyActivity : AppCompatActivity() {
    private val myObserver = MyObserver()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        lifecycle.addObserver(myObserver) // getLifecycle()
    }

    override fun onDestroy() {
        super.onDestroy()
        lifecycle.removeObserver(myObserver)
    }
}
```

每个 ` LifecycleOwner` 对象都有一个协程作用域, 可以通过 `lifecycleScope` 属性来获取; 每一个 `ViewModel` 对象都有一个协程作用域, 可以通过 `viewModelScope` 属性来获取.
生命周期感知型组件的协程作用域用于在生命周期范围内启动协程, 以便在生命周期状态发生变化时取消协程.

如果需要在 `LifecycleOwner` 对象只要进入到指定的生命周期状态就执行某个操作, 可以使用 `repeatOnLifecycle()` 函数, 该函数会在 `LifecycleOwner` 对象进入到指定的生命周期状态时执行指定的操作, 并且会在 `LifecycleOwner` 对象退出指定的生命周期状态时取消操作.

```kotlin
class MyActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        lifecycleScope.launch {

            // 随状态变化而反复执行
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                // 在 STARTED 状态下执行操作
            }

            // 单次长时间操作, 随状态变化可恢复运行直到运行完成
            whenStarted {
                // 在第一次 STARTED 状态下执行操作
            }

            whenResumed {
                // 在第一次 RESUMED 状态下执行操作
            }

            whenCreated {
                // 在第一次 CREATED 状态下执行操作
            }
        }
    }
}

class MyFragment : Fragment() {
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        viewLifecycleOwner.lifecycleScope.launch {
            viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {
                // 在 STARTED 状态下执行操作
            }
        }
    }
}

class MyViewModel : ViewModel() {
    init {
        viewModelScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                // 在 STARTED 状态下执行操作
            }
        }
    }
}
```


#### ViewModel(未完成)

`ViewModel` 是一个用于持久存储界面相关状态数据, 处理界面业务逻辑的类. 防止因为 `activity` 或 `fragment` 的重建而导致数据丢失. 同时, `ViewModel` 的作用域被限定为 `ViewModelStoreOwner` 的生命周期范围内, 通常是 `activity` 或 `fragment` 的生命周期范围内. 只有在 `activity` 或 `fragment` 在非配置更改的情况下被销毁时, `ViewModel` 才会被销毁, 比如调用 `finish()` 方法.

```kotlin
class MyViewModel : ViewModel() {
    private val _data = MutableStateFlow<String>()
    val data: StateFlow<String> = _data.asStateFlow()

    fun updateData(newData: String) {
        _data.value = newData
    }
}

class MyActivity : AppCompatActivity() {
    private val viewModel: MyViewModel by viewModels() // 使用 by viewModels() 代理属性来获取 ViewModel 实例, 这通常在 onCreate() 之前

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        viewModel = ViewModelProvider(this).get(SimpleViewModel::class.java) // 使用 ViewModelProvider 手动创建 ViewModel 实例


        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.data.collect { data ->
                    // 更新界面数据
                }
            }
        }
    }
}
```

因为 `ViewModelProvider` 只能通过默认的无参构造函数来创建 `ViewModel` 实例. 当 `ViewModel` 需要依赖外部组件时, 可以通过构造函数注入或 Hilt 库进行依赖注入, 并只能通过 `ViewModelProvider.Factory` 来创建 `ViewModel` 实例.

```kotlin
class MyViewModel @ViewModelInject constructor(
    private val repository: MyRepository
) : ViewModel() {
    private val _data = MutableStateFlow<String>()
    val data: StateFlow<String> = _data.asStateFlow()

    fun updateData(newData: String) {
        _data.value = newData
    }
}

class MyViewModelFactory @Inject constructor(
    private val repository: MyRepository
) : ViewModelProvider.Factory {
    override fun <T : ViewModel?> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(MyViewModel::class.java)) {
            return MyViewModel(repository) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}

class MyActivity : AppCompatActivity() {
    private val viewModel: MyViewModel by viewModels { MyViewModelFactory(repository) } // 使用 by viewModels() 代理属性来获取 ViewModel 实例, 这通常在 onCreate() 之前

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        var factory = MyViewModelFactory(repository)
        viewModel = ViewModelProvider(this, factory).get(SimpleViewModel::class.java) // 使用 ViewModelProvider 手动创建 ViewModel 实例

        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.data.collect { data ->
                    // 更新界面数据
                }
            }
        }
    }
}

```

可以通过 `SavedStateHandle` 在 `ViewModel` 中保存和恢复与界面状态相关的数据, 避免因为系统因内存不足等原因终止应用程序时导致的数据丢失, 从而在重启应用程序时恢复数据.


#### LiveData(未完成)

`LiveData` 是一种可观察的数据存储器类, 可以感知 `LifecycleOwner` 的生命周期状态, 并且只在 `LifecycleOwner` 处于活动状态时通知观察者.
`MutableLiveData` 是 `LiveData` 的子类, 用于存储可变数据, 并且可以通过 `setValue()` 或 `postValue()` 方法来更新数据.

```kotlin
class MyViewModel : ViewModel() {
    private val _data = MutableLiveData<String>()
    val data: LiveData<String> = _data

    fun updateData(newData: String) {
        _data.value = newData
    }
}

class MyActivity : AppCompatActivity() {
    private val viewModel: MyViewModel by viewModels()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        val observer = Observer<String> { data ->
            // 更新界面数据

        }
        viewModel.data.observe(this, observer)
    }
}
```

[将协程与 LiveData 一起使用](https://developer.android.com/topic/libraries/architecture/coroutines?hl=zh-cn#livedata:~:text=%E9%A1%B9%20%E6%B5%AA%E8%B4%B9%E8%B5%84%E6%BA%90%E3%80%82-,%E5%B0%86%E5%8D%8F%E7%A8%8B%E4%B8%8E%20LiveData%20%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8,-%E4%BD%BF%E7%94%A8%20LiveData%20%E6%97%B6)


#### StateFlow

`StateFlow` 是一种可观察的数据存储器类, 可以感知 `LifecycleOwner` 的生命周期状态, 并且只在 `LifecycleOwner` 处于活动状态时通知观察者.
`MutableStateFlow` 是 `StateFlow` 的子类, 用于存储可变数据, 并且可以通过 `value` 属性来更新数据.

```kotlin
class MyViewModel : ViewModel() {
    private val _data = MutableStateFlow<String>("")
    val data: StateFlow<String> = _data.asStateFlow()

    fun updateData(newData: String) {
        _data.value = newData
    }
}

class MyActivity : AppCompatActivity() {
    private val viewModel: MyViewModel by viewModels()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.data.collect { data ->
                    // 更新界面数据
                }
            }
        }
    }
}
```

#### DataStore

#### Room

#### WorkManager

### 依赖管理
- 通过构造函数注入或 Hilt 库进行依赖注入
- 依赖注入使类能够定义其依赖项而不构造它们. 在运行时, 另一个类负责提供这些依赖项.
- 服务定位器: 服务定位器模式提供了一个注册表, 类可以从中获取其依赖项而不构造它们.

### 项目测试
- 测试内容
  - 对 ViewModel (包括 Flow) 进行单元测试
  - 对数据层实体进行单元测试. 即对代码库和数据源进行单元测试
  - 进行界面导航测试 (可在持续集成环境中用作回归测试) 
  - 测试 StateFlow 和 LiveData 的行为
    - 尽可能对 value 属性进行断言
    - 如果使用 WhileSubscribed, 您应该创建一个 collectJob

### 模块组织
- 项目模块化: 将应用程序拆分为多个模块, 以便更容易管理和维护, 以下是从高到低的模块组织结构:
  - 应用模块(app): 包含界面入口点, 依赖于功能模块, 支持产品变种(`productFlavors`), 编译为不同的二进制文件, 如不同设备或不同版本的 APK 文件, 以及不同的构建类型(`buildTypes`), 如调试和发布版本.
  - 功能模块(feature): 包含特定功能的代码, 可以独立编译和测试, 依赖于数据模块.
  - 数据模块(data): 包含存储库(`Repository`)、数据源(`DataSource`)和模型类(`Model`), 用于封装特定领域的所有数据和业务逻辑, 将存储库公开为外部 API.
  - 通用模块(core): 包含应用程序中多个模块之间共享的代码, 如工具类、扩展函数、自定义视图等.
  - 测试模块(test): 包含单元测试和 UI 测试, 用于测试应用程序的各个部分.
- 注意事项:
  - 模块间需要相互依赖并通信时, 可以通过将相关逻辑放在另一个中介模块中进行解耦, 以避免直接依赖. 同时此中介模块可以被其他任何需要此逻辑的模块复用.
  - 高级模块(业务逻辑)不应该直接依赖于低级模块的具体实现, 而是应该依赖于其抽象接口. 这样可以方便低级模块的替换, 扩展和测试. 具体项目中可以同时创建一个 `api` 模块和一个 `impl` 模块, `api` 模块定义接口, `impl` 模块实现接口.


()[!https://developer.android.com/static/topic/libraries/architecture/images/mad-arch-ui-udf-in-action.png?hl=zh-cn]


### 架构代码样例


```

data class Author(
    val id: String,
    val name: String,
)

data class LoginUiState(
    val isLoading: Boolean = false,
    val errorMessage: String? = null,
    val isUserLoggedIn: Boolean = false
)

class LoginViewModel : ViewModel() {
    private val _uiState = MutableStateFlow(LoginUiState())
    val uiState: StateFlow<LoginUiState> = _uiState.asStateFlow()
    /* ... */
}

class LoginActivity : AppCompatActivity() {
    private val viewModel: LoginViewModel by viewModels()

    override fun onCreate(savedInstanceState: Bundle?) {
        /* ... */

        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.uiState.collect { uiState ->
                    if (uiState.isUserLoggedIn) {
                        // Navigate to the Home screen.
                    }
                    ...
                }
            }
        }
    }
}

private const val DOB_VALIDATION_KEY = "dobValidationKey"

class DobValidationFragment : Fragment() {

    private var validationInProgress: Boolean = false
    private val viewModel: DobValidationViewModel by viewModels()

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        val binding = // ...
        validationInProgress = savedInstanceState?.getBoolean(DOB_VALIDATION_KEY) ?: false

        binding.continueButton.setOnClickListener {
            viewModel.validateDob()
            validationInProgress = true
        }

        viewLifecycleOwner.lifecycleScope.launch {
            viewModel.uiState
                .flowWithLifecycle(viewLifecycleOwner.lifecycle)
                .collect { uiState ->
                    // Update other parts of the UI ...

                    // If the input is valid and the user wants
                    // to navigate, navigate to the next screen
                    // and reset `validationInProgress` flag
                    if (uiState.isDobValid && validationInProgress) {
                        validationInProgress = false
                        navController.navigate(...) // Navigate to next screen
                    }
                }
        }

        return binding
    }

    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)
        outState.putBoolean(DOB_VALIDATION_KEY, validationInProgress)
    }
}



data class NewsItem(
    val title: String,
    val body: String,
    val bookmarked: Boolean = false,
    val publicationDate: String,
    val onBookmark: () -> Unit
)

data class Message(val id: Long, val message: String)
data class NewsUiState(
    val isSignedIn: Boolean = false, // 状态属性
    val isPremium: Boolean = false,
    val isFetchingArticles: Boolean = false, // 加载状态
    val newsItems: List<NewsItem> = listOf(), // 数据
    val userMessages: List<Message> = listOf() // 反馈信息
)
val NewsUiState.canBookmarkNews: Boolean get() = isSignedIn && isPremium // 其他属性的派生属性
interface NewsRepository{}

class NewsViewModel : ViewModel() {
    private val repository: NewsRepository
    private val formatDateUseCase: FormatDateUseCase,
    private val _uiState = MutableStateFlow(NewsUiState())
    val uiState: StateFlow<NewsUiState> = _uiState.asStateFlow()
    val newsListUiItems = repository.latestNews.map { news ->
        NewsItemUiState(
            title = news.title,
            body = news.body,
            bookmarked = news.bookmarked,
            publicationDate = formatDateUseCase(news.publicationDate),
            // Business logic is passed as a lambda function that the
            // UI calls on click events.
            onBookmark = {
                repository.addBookmark(news.id)
            }
        )
    }

    private var fetchJob: Job? = null

    fun fetchArticles(category: String) {
        fetchJob?.cancel()
        fetchJob = viewModelScope.launch {
            try {
                val newsItems = repository.newsItemsForCategory(category)
                _uiState.update {
                    it.copy(newsItems = newsItems)
                }
            } catch (ioe: IOException) {
                // Handle the error and notify the UI when appropriate.
                _uiState.update {
                    val messages = getMessagesFromThrowable(ioe)
                    it.copy(userMessages = messages)
                 }
            }
        }
    }

    fun refreshNews() {
        viewModelScope.launch {
            // If there isn't internet connection, show a new message on the screen.
            if (!internetConnection()) {
                _uiState.update { currentUiState ->
                    currentUiState.copy(userMessages = arrayOf(["No Internet connection"]))
                }
                return@launch
            }

            // Do something else.
        }
    }

    fun userMessageShown() {
        _uiState.update { currentUiState ->
            currentUiState.copy(userMessage = null)
        }
    }

}

class NewsActivity : AppCompatActivity() {
    private lateinit var binding2: ActivityLoginBinding
    private lateinit var binding: ActivityLatestNewsBinding
    private val viewModel: NewsViewModel by viewModels()

    override fun onCreate(savedInstanceState: Bundle?) {
        ...

        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                // 界面根据新数据, 更新要显示的数据
                viewModel.uiState
                    .map { it.isFetchingArticles }
                    .distinctUntilChanged()
                    .collect { progressBar.isVisible = it }
                // 根据状态的更改, 界面进行响应
                viewModel.uiState.collect { uiState ->
                    // 根据一些信息的更改, 界面进行一些通知
                    uiState.userMessage?.let {
                        // TODO: Show Snackbar with userMessage.
    
                        // Once the message is displayed and
                        // dismissed, notify the ViewModel.
                        viewModel.userMessageShown()
                    }
                } 
            }
        }

        binding.expandButton.setOnClickListener {
            binding.expandedSection.visibility = View.VISIBLE
        }

        binding.refreshButton.setOnClickListener {
            viewModel.refreshNews()
        }

        binding2.helpButton.setOnClickListener {
            navController.navigate(...) // Open help screen
        }
    }
}

data class ArticleApiModel(
    val id: Long,
    val title: String,
    val content: String,
    val publicationDate: Date,
    val modifications: Array<ArticleApiModel>,
    val comments: Array<CommentApiModel>,
    val lastModificationDate: Date,
    val authorId: Long,
    val authorName: String,
    val authorDateOfBirth: Date,
    val readTimeMin: Int
)

data class Article(
    val id: Long,
    val title: String,
    val content: String,
    val publicationDate: Date,
    val authorName: String,
    val readTimeMin: Int
)

class NewsRemoteDataSource(
  private val newsApi: NewsApi,
  private val ioDispatcher: CoroutineDispatcher
) {
    /**
     * Fetches the latest news from the network and returns the result.
     * This executes on an IO-optimized thread pool, the function is main-safe.
     */
    suspend fun fetchLatestNews(): List<ArticleHeadline> =
        // Move the execution to an IO-optimized thread since the ApiService
        // doesn't support coroutines and makes synchronous requests.
        withContext(ioDispatcher) {
            newsApi.fetchLatestNews()
        }
    }

// Makes news-related network synchronous requests.
interface NewsApi {
    fun fetchLatestNews(): List<ArticleHeadline>
}

// NewsRepository is consumed from other layers of the hierarchy.
class NewsRepository(
    private val newsRemoteDataSource: NewsRemoteDataSource,
        // This could be CoroutineScope(SupervisorJob() + Dispatchers.Default).
    private val externalScope: CoroutineScope
) {
    suspend fun fetchLatestNews(): List<ArticleHeadline> =
        newsRemoteDataSource.fetchLatestNews()
    // Mutex to make writes to cached values thread-safe.
    private val latestNewsMutex = Mutex()

    // Cache of the latest news got from the network.
    private var latestNews: List<ArticleHeadline> = emptyList()

    suspend fun getLatestNews(refresh: Boolean = false): List<ArticleHeadline> {
        return if (refresh) {
            externalScope.async {
                newsRemoteDataSource.fetchLatestNews().also { networkResult ->
                    // Thread-safe write to latestNews.
                    latestNewsMutex.withLock {
                        latestNews = networkResult
                    }
                }
            }.await()
        } else {
            return latestNewsMutex.withLock { this.latestNews }
        } 
    }
}

class RefreshLatestNewsWorker(
    private val newsRepository: NewsRepository,
    context: Context,
    params: WorkerParameters
) : CoroutineWorker(context, params) {

    override suspend fun doWork(): Result = try {
        newsRepository.refreshLatestNews()
        Result.success()
    } catch (error: Throwable) {
        Result.failure()
    }
}

private const val REFRESH_RATE_HOURS = 4L
private const val FETCH_LATEST_NEWS_TASK = "FetchLatestNewsTask"
private const val TAG_FETCH_LATEST_NEWS = "FetchLatestNewsTaskTag"

class NewsTasksDataSource(
    private val workManager: WorkManager
) {
    fun fetchNewsPeriodically() {
        val fetchNewsRequest = PeriodicWorkRequestBuilder<RefreshLatestNewsWorker>(
            REFRESH_RATE_HOURS, TimeUnit.HOURS
        ).setConstraints(
            Constraints.Builder()
                .setRequiredNetworkType(NetworkType.TEMPORARILY_UNMETERED)
                .setRequiresCharging(true)
                .build()
        )
            .addTag(TAG_FETCH_LATEST_NEWS)

        workManager.enqueueUniquePeriodicWork(
            FETCH_LATEST_NEWS_TASK,
            ExistingPeriodicWorkPolicy.KEEP,
            fetchNewsRequest.build()
        )
    }

    fun cancelFetchingNewsPeriodically() {
        workManager.cancelAllWorkByTag(TAG_FETCH_LATEST_NEWS)
    }
}

```

## UI

应用的界面 (UI) 就是您在屏幕上所看到的内容 (文本、图片、按钮和许多其他类型的元素) 及其在屏幕上的布局方式.


### 界面状态保存

### 临时存放

Jetpack Compose 可以使用在项目的 Android 自动生成的 `R` 类中通过资源 ID 访问 Android 项目中定义的资源. 
- `painterResource()` 函数会加载可绘制图片资源, 并将资源 ID (在本例中为 `R.drawable.androidparty` ) 作为实参. 
- `stringResource()` 

`onCreate()` 函数中的 [`setContent()`](https://developer.android.com/reference/kotlin/androidx/compose/ui/platform/ComposeView?hl=zh-cn#setContent(kotlin.Function0)) 函数用于通过可组合函数定义布局. 


可组合函数 Jetpack Compose 是用于构建 Android 界面的新款工具包. 任何标有 `@Composable` 注解的函数都可通过 `setContent()` 函数或其他可组合函数进行调用. 该注解可告知 Kotlin 编译器 Jetpack Compose 使用的这个函数会生成 UI. 

注解

```kotlin
@Composable
@Preview
```

修饰符 [`Modifier`](https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier?hl=zh-cn) 用于扩充或修饰可组合项, 如修饰组件的布局. 
- 内边距修饰符 (`Modifier.padding`) 在 `Text` 可组合项的周围添加空间. 
```
Modifier.padding(
    start = 16.dp,
    top = 16.dp,
    end = 16.dp,
    bottom = 16.dp
)

Modifier
    .padding(16.dp)
    .align(alignment = Alignment.End)
```
- 背景颜色修饰符 `Modifier.background` 


![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-add-images/img/df69881d07b064d0.gif?hl=zh-cn)



基本标准布局元素是 `Column`、`Row,` 和 `Box`. 
- [`Box`](https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/package-summary?hl=zh-cn#Box(androidx.compose.ui.Modifier,androidx.compose.ui.Alignment,kotlin.Boolean,kotlin.Function1)) 布局是 Compose 中的标准布局元素之一. 使用 `Box` 布局可将元素堆叠在一起. `Box` 布局还可用于配置它所包含的元素的特定对齐方式. 

应用在某些情况下可能会被翻译成其他语言, 一些固定的 `String` 数据类型可以提取到资源文件中进行管理, 避免硬编码导致无法进行翻译.

@JvmOverloads constructor 用于自动在 java 中生成各种重载的构造函数


[ConstraintLayout之ConstraintSet - enzo的博客](https://enzowyf.github.io/constraintset.html)

// 设置控件尺寸  
// constrainWidth/constrainHeight  
// constrainDefaultWidth/constrainDefaultHeight  
// constrainMaxWidth/constrainMaxHeight  
// constrainMinWidth/constrainMinHeight
  
// 设置控件间直接约束关系  
  
// 控件 start 的某边与 end 的某边对齐, margin 用于设置边与边中间间距  
// connect(int startID, int startSide, int endID, int endSide, int margin)  
// connect(int startID, int startSide, int endID, int endSide)  
  
// 控件 center 置于另两个控件 first 和 second 之间, bias(0~1) 用于设置位置偏移比例  
// center(int centerID, int firstID, int firstSide, int firstMargin, int secondID, int secondSide, int secondMargin, float bias)  
// 控件 center 水平居中于另一个控件 centerID, leftId/rightId 用于设置左右边界控件  
// centerHorizontally(int centerID, int leftId, int leftSide, int leftMargin, int rightId, int rightSide, int rightMargin, float bias)  
  
// 方向: ConstraintSet.TOP/BOTTOM/START/END/LEFT/RIGHT/BASELINE(TextView)  
  
// 控件 viewId 与 toView 水平居中  
// centerHorizontally(int viewId, int toView)  
// 控件 viewId 与 toView 垂直居中  
// centerVertically(int viewId, int toView)  
  
// 修改控件属性  
// setVisibility/setAlpha/setRotation  
// setRotationX/setRotationY  
// setScaleX/setScaleY/setTransformPivot/setTransformPivotX/setTransformPivotY  
// setTranslation/setTranslationX/setTranslationY/setTranslationZ  
// setElevation

RecyclerView ( `RecyclerView` 和 `RecyclerView.LayoutManager` )
- 数据驱动：需要一个数据源来提供要显示的数据, 见 `RecyclerView.Adapter` 和 `RecyclerView.ViewHolder`
- 可重用性：支持视图的重用机制, 通过重用池来减少内存开销, 见 `onCreateViewHolder` 和 `onBindViewHolder`
- 布局管理：支持多种布局, 通过不同的布局管理器来控制视图的显示方式 (如网格、列表等) , 见 `LinearLayoutManager` 、 `GridLayoutManager` 、 `StaggeredGridLayoutManager`
- 自定义单元格：允许自定义单元格, 以便显示复杂的内容. 创建自定义的 `ViewHolder` 子类, 然后在 `Adapter` 中使用这个 `ViewHolder`, 在 `onCreateViewHolder` 和 `onBindViewHolder` 方法中绑定 `ViewHolder`.

### 基础组件
`AbsListView` 是一个抽象类, 不能用作应用程序布局中的 `View` 元素, 尽管您可以将其用作 `Base Class` 来实现您自己的 `View`. 在
`AbsoluteLayout` 要被弃用了. 允许您指定其子级的确切位置 (x/y 坐标) 的布局. 与没有绝对定位的其他类型的布局相比, 绝对布局不太灵活且更难以维护. 
`AbsSeekBar` 和 `AbsSpinner ` 全是抽象类.
`ActionMenuView`, 操作菜单视图, 支持接收菜单项单击事件的接口(看到有人当做底部菜单栏使用的).
`Adapter` 适配器就像数据源和用户界面之间的桥梁. 它从各种数据源读取数据, 将其转换为 `View` 对象, 并将其提供给链接的 `Adapter` 视图以创建 UI 组件. 
`AdapterView` 适配器视图可用于以列表或网格等形式有效地显示由适配器提供的大量数据. `Adapter` 获取数据并根据该数据创建一个 `View , 然后将该 `View` 提供给 `AdapterView`. 然后 `AdapterView` 以想要的方式显示数据. 
`AlphabetIndexer` 实现 `SectionIndexer` 接口的适配器的辅助类. 如果适配器中的项目通过简单的基于字母的排序进行排序, 则此类提供了一种使用二分搜索对大型列表进行快速索引的方法. 在 `ListView` 或 `RecyclerView` 中, 可以使用 `AlphabetIndexer` 来为列表提供分节导航. 
`AnalogClock` 被弃用了
`BaseAdapter`
- `ArrayAdapter` 通过此类可以从数组获取 `AdapterView`, 
- `CursorAdapter`
- `SimpleAdapter`
- `ResourceCursorAdapter`
- `SimpleCursorAdapter`

`AutoCompleteTextView` 可编辑的文本视图, 在用户键入时自动显示完成建议. 建议列表显示在下拉菜单中, 用户可以从中选择一个项目来替换编辑框的内容. 建议列表是从数据适配器获取的
`CalendarView` 用于显示和选择日期的日历小部件. 
`CheckBox`, 创建一个复选框选项, 每个复选框都是单独管理的, 必须为每个复选框注册点击监听器. 
`CheckedTextView`, 扩展 `TextView` 支持 `Checkable` 界面和显示. 也就是说文本支持选中后复选支持.
`Chronometer` 基于 `TextView` 实现的计时器. 控制和展示计时时间.
`CompoundButton` 复合按钮, 抽象类, 具有两种状态的按钮, 选中和未选中(开和关). 当按下或单击按钮时, 状态会自动更改. 主要派生出了 `CheckBox`, `RadioButton`, `Switch`, `ToggleButton`
`DialerFilter` 被弃用
`DigitalClock` 被弃用
`EdgeEffect` 用于在可滑动控件边缘提供视觉反馈, 例如 `ScrollView` 在滑动到边界时显示的弧形颜色效果. 
`EditText` 用于输入和修改文本的用户界面元素, 支持输入类型选择, 文本类型, 密码类型等.
`ExpandableListView` 可扩展列表视图, 显示垂直滚动的两级列表中的项目的视图, 与 `ListView` 的不同之处在于允许两个级别：可以单独展开以显示其子级的组. 
`Filter` 过滤器使用过滤模式来异步约束数据, 细节待定.
`FrameLayout` 框架布局, 可以添加多个子视图进行叠放, 新添加的视图, 会覆盖在旧视图上面.
`Gallery` 被弃用了. 可以参考新的 `HorizontalScrollView` 和 `ViewPager`
`GridLayout` 矩形网格布局, 可以指定网格的列数和行数. `GridLayout` 基本上将其子级放置在矩形网格中. 该网格有一组许多细线, 将视图区域分隔成单元格, N列的网格, 那么我们将有N+1 个从0 开始的网格索引. 子项占据一个或多个连续的单元格, 由其 `rowSpec` 和 `columnSpec` 布局参数定义, 占据相同单元格的子项, 可能会产生重叠.
`GridView` 网格视图, 将多个子项显示在支持滚动的二维网格的视图. 数据通过 Adapter 适配器与GridView 连接, 并将每条数据插入到将在 GridView 中显示的适当项目中. 
`HeaderViewListAdapter`,  一个基类, 目前不需要学习.
`HorizontalScrollView` 水平滚动视图, 也只支持水平滚动, 需要在其中放置一个包含要滚动的全部内容的子项, 在水平方向上, 呈现用户可以滚动浏览的顶级项目的水平数组. 
`ImageButton` 图像按钮, 显示一个带有图像 (而不是文本) 的按钮, 用户可以按下或单击该按钮. 
`ImageSwitcher` 图像切换器, 当在两个 `ImageView` 上设置新图像时, `ViewSwitcher` 在两个 `ImageView` 之间切换. 添加到 `ImageSwitcher` 的视图必须都是 `ImageView`. 
`ImageView` 图像视图, 显示图片资源, 例如 `Bitmap` 或者 `Drawable` 资源.  I
`LinearLayout` 线性布局, 将其他视图水平排列在单列中或垂直排列在单行中的布局. 
`ListPopupWindow` 列表弹出窗口, `ListPopupWindow` 将自身锚定到主视图并显示一个选项列表, 能够显示 `ListAdapter` 中的项目. , 进行包括定位、滚动父项以适应下拉菜单、与 IME (如果存在) 进行合理交互等. 
`ListView` 显示可垂直滚动的视图集合, 其中每个视图都位于列表中前一个视图的正下方. 
`Magnifier` 放大镜, `Android` 放大镜小部件. 可由附加到窗口的任何视图使用. 
`MediaController` 媒体控制器.  如果拥有 “android.permission.MEDIA_CONTENT_CONTROL” 权限或者是启用的通知侦听器, 或者直接从会话所有者获取 `MediaSession.Token`, 则可以通过 `MediaSessionManager` 创建 `MediaController`. 允许应用程序与正在进行的媒体会话交互. 媒体按钮和其他命令可以发送到会话. 可以注册回调以接收来自会话的更新, 例如元数据和播放状态变化. 
`MultiAutoCompleteTextView`,可编辑的文本视图, 扩展 `AutoCompleteTextView`, 可以显示用户正在键入的文本子字符串的补全建议, 而不只是整个内容. `AutoCompleteTextView` 仅提供有关整个文本的建议. 但是 `MultiAutoCompleteTextView` 为文本的子字符串提供了多种建议. 
`NumberPicker` 数字选择器, 一个小部件, 使用户能够从预定义范围中选择一个数字, 支持显示为可编辑输入字段, 上面有一个递增按钮, 下面有一个递减按钮. 也支持将当前值显示为可编辑输入字段, 上面的值较小, 下面的值较大. 点击较小或较大的值可以通过向上或向下动画数轴来选择该值, 以使所选值成为当前值. 向上或向下滑动允许当前值多次递增或递减. 长按较小和较大值还可以快速更改当前值. 点击当前值可以输入所需的值. 还支持将当前值显示为滚动垂直选择器, 所选值位于中心, 上方和下方是前一个和后一个数字, 并由分隔线分隔. 通过垂直滑动来更改该值. 
`OverScroller` 过滚, 封装了滚动能力, 同时支持超出滚动操作范围的能力.
`PopupMenu` 弹出菜单, `PopupMenu` 在锚定到视图的模式弹出窗口中显示菜单. 如果有空间, 弹出窗口将出现在锚视图下方；如果没有空间, 则弹出窗口将出现在锚视图上方. 如果 `IME` 可见, 则弹出窗口不会与其重叠, 直到触摸它为止. 触摸弹出窗口外部会将其关闭. 
`PopupWindow` 弹出窗口.  此类表示可用于显示任意视图的弹出窗口. 弹出窗口是一个浮动容器, 出现在当前活动的顶部. 
`ProgressBar` 进度条. 指示操作进度的用户界面元素. 进度条支持两种表示进度的模式：确定和不确定. 不确定模式是进度条的默认模式, 显示循环动画, 但不指示具体的进度量. 当想要显示已发生特定数量的进度时, 请对进度栏使用确定模式. 例如, 正在检索的文件的剩余百分比、写入数据库的批次中的记录数量或正在播放的音频文件的剩余百分比. 
`QuickContactBadge`, 显示为一个小徽章, 用户单击该徽章即可快速创建联系人, 例如将电话号码或电子邮件添加到联系人列表. 

- AbsListView  
- AbsListView.LayoutParams  
- AbsoluteLayout  
- AbsoluteLayout.LayoutParams  
- AbsSeekBar  
- AbsSpinner  
- ActionMenuView  
    - ActionMenuView.LayoutParams  
- AdapterView  
- AdapterView.AdapterContextMenuInfo  
- AdapterViewAnimator  
- AdapterViewFlipper  
- AlphabetIndexer  
- AnalogClock  
- ArrayAdapter  
- AutoCompleteTextView  
- BaseAdapter  
- BaseExpandableListAdapter  
- Button  
- CalendarView  
- CheckBox  
- CheckedTextView  
- Chronometer  
- CompoundButton  
- CursorAdapter  
- CursorTreeAdapter  
- DatePicker  
- DialerFilter  
- DigitalClock  
- EdgeEffect  
- EditText  
- ExpandableListView  
    - ExpandableListView.ExpandableListContextMenuInfo  
- Filter  
    - Filter.FilterResults  
- FrameLayout  
    - FrameLayout.LayoutParams  
- Gallery  
    - Gallery.LayoutParams  
- GridLayout  
    - GridLayout.Alignment  
    - GridLayout.LayoutParams  
    - GridLayout.Spec  
- GridView  
- HeaderViewListAdapter  
- HorizontalScrollView  
- ImageButton  
- ImageSwitcher  
- ImageView  
- LinearLayout  
    - LinearLayout.LayoutParams  
- ListPopupWindow  
- ListView  
    - ListView.FixedViewInfo  
- Magnifier  
    - Magnifier.Builder  
- MediaController  
- MultiAutoCompleteTextView  
    - MultiAutoCompleteTextView.CommaTokenizer  
- NumberPicker  
- OverScroller  
- PopupMenu  
- PopupWindow  
- ProgressBar  
- QuickContactBadge  
- RadioButton  
- RadioGroup  
    - RadioGroup.LayoutParams  
- RatingBar  
- RelativeLayout  
    - RelativeLayout.LayoutParams  
- RemoteViews  
    - RemoteViews.DrawInstructions  
    - RemoteViews.DrawInstructions.Builder  
    - RemoteViews.RemoteCollectionItems  
    - RemoteViews.RemoteCollectionItems.Builder  
    - RemoteViews.RemoteResponse  
    - RemoteViews.RemoteViewOutlineProvider  
- RemoteViewsService  
- ResourceCursorAdapter  
- ResourceCursorTreeAdapter  
- Scroller  
- ScrollView  
- SearchView  
- SeekBar  
- ShareActionProvider  
- SimpleAdapter  
- SimpleCursorAdapter  
- SimpleCursorTreeAdapter  
- SimpleExpandableListAdapter  
- SlidingDrawer  
- Space  
- Spinner  
- StackView  
- Switch  
- TabHost  
    - TabHost.TabSpec  
- TableLayout  
    - TableLayout.LayoutParams  
- TableRow  
    - TableRow.LayoutParams  
- TabWidget  
- TextClock  
- TextSwitcher  
- TextView  
    - TextView.SavedState  
- TimePicker  
- Toast  
    - Toast.Callback  
- ToggleButton  
- Toolbar  
    - Toolbar.LayoutParams  
- TwoLineListItem  
- VideoView  
- ViewAnimator  
- ViewFlipper  
- ViewSwitcher  
- ZoomButton  
- ZoomButtonsController  
- ZoomControls

- InlineContentView
- InlinePresentationSpec
    - InlinePresentationSpec.Builder

### androidx 扩展组件

- ActionBar
    - ActionBar.LayoutParams
    - ActionBar.Tab
- ActionBarDrawerToggle
- AlertDialog
    - AlertDialog.Builder
- AppCompatActivity
- AppCompatDelegate
- AppCompatDialog
- AppCompatDialogFragment
- AppCompatViewInflater
- AppLocalesMetadataHolderService

- ActionMenuView
    - ActionMenuView.LayoutParams
- AppCompatAutoCompleteTextView
- AppCompatButton
- AppCompatCheckBox
- AppCompatCheckedTextView
- AppCompatEditText
- AppCompatImageButton
- AppCompatImageView
- AppCompatMultiAutoCompleteTextView
- AppCompatRadioButton
- AppCompatRatingBar
- AppCompatSeekBar
- AppCompatSpinner
- AppCompatTextView
- AppCompatToggleButton
- LinearLayoutCompat
    - LinearLayoutCompat.LayoutParams
- ListPopupWindow
- PopupMenu
- SearchView
- ShareActionProvider
- SwitchCompat
- ThemedSpinnerAdapter.Helper
- Toolbar
    - Toolbar.LayoutParams
    - Toolbar.SavedState
- TooltipCompat

### androidx 碎片组件(Fragment)

 `Fragment`是 `Activity` 中使用的一种可重用 UI 组件, 可以在 `Activity` 中被添加、替换、移除, 也可以在 `Fragment` 中嵌套其他 `Fragment`, 有自己的生命周期, 可以与 `Activity` 共享生命周期. 
 - `Fragment` 生命周期回调方法: `onCreate()` , `onCreateView()` , `onViewCreated()` , `onViewStateRestored()` , `onStart()` , `onResume()` , `onPause()` , `onStop()` , `onSaveInstanceState()` , `onDestroyView()` , `onDestroy()` 
 - `Fragment` 生命周期状态: `CREATED`, `STARTED`, `RESUMED`, `DESTROYED`. 可以由 `getLifecycle().getCurrentState()` 获取当前状态
 - `Fragment` 视图状态: `INITIALIZED` , `CREATED` , `STARTED` , `RESUMED` , `DESTROYED`. 可以由 `getViewLifecycleOwner().getLifecycle().getCurrentState()` 获取当前状态

实际开发中, `Fragment` 需要一个托管它的视图容器, 通常是一个 `FrameLayout` 等布局容器. 新的 API 提供了 `FragmentContainerView` 来代替 `FrameLayout`, 支持更好的视觉效果设置, 和额外的编辑器功能.

可以根据不同的场景获取不同的 `FragmentManager` 管理实例, 来管理场景内 `Fragment` 的添加、替换、移除等操作. `FragmentManager` 通过事务(`FragmentTransaction`) 和回退栈(`BackStack`) 来管理 `Fragment` 的状态和生命周期. 

回退栈是一个后进先出的栈, 用于存储 `Fragment` 的状. 在应用的任意时刻, 只能有一个 `FragmentManager` 可以控制 `Fragment` 的回退栈, 所以在多 `Fragment` 的情况下, 需要使用 `setPrimaryNavigationFragment()` 方法在不同的导航片段之间切换主要导航控制权, 以便正确管理回退栈. 吃外如果需要支持多个回退栈, 可以使用 `saveBackStack()` 和 `restoreBackStack()` 方法来保存和恢复回退栈, 比如在导航栏切换时.

事务是一组针对`Fragment`的操作集合, 通过 `beginTransaction()` 或 kotlin 扩展方法 `commit` 来创建和提交事务, 可以包括任意数量的操作. 事务执行时可以通过 `addToBackStack()` 方法在回退栈中保存事务, 这样可以通过 `popBackStack()` 方法来回退到上一个状态. 没添加到回退栈的事务会被立即执行, 但不会保存状态, 比如删除任务会立即删除和销毁, 无法回撤.

如果设备发生了配置变化 (如屏幕旋转) , Activity 及其所有 Fragment 都会被销毁并重新创建, 此时需要注意 `Fragment` 的实例初始化问题.

- Fragment
    - DialogFragment
    - PreferenceFragmentCompat
    - ListFragment

```kotlin
class MyFragment : Fragment() {
    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        return inflater.inflate(R.layout.fragment_my, container, false)
    }
}

class MyActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        if (savedInstanceState == null) {
            supportFragmentManager.beginTransaction()
                .add(R.id.fragment_container, MyFragment())
                .commit()
            // 或者
            supportFragmentManager.commit {
                add<MyFragment>(R.id.fragment_container)
            }
        }
    }
}
```

- FragmentContainer: 一个抽象类, 用于管理 Fragment 的容器, 通常是一个 ViewGroup
- FragmentContainerView: 一个 ViewGroup, 用于管理 Fragment 的容器

- FragmentManager: 
    - 在 Activity 中通过 `getSupportFragmentManager()` 获取管理实例
    - 在 Fragment 中通过 `getChildFragmentManager()` 获取管理实例
    - 在 Child Fragment 中通过 `getParentFragmentManager()` 获取管理实例
    - 通过 `beginTransaction()` 创建事务, 类型为 `FragmentTransaction`
    - 通过 `commit()` 提交事务
    - 通过 `popBackStack()` 弹出回退栈
    - 通过 `addToBackStack()` 添加到回退栈
    - 通过 `add`, `replace`, `remove`, `hide`, `show` 等方法操作 Fragment
    - 通过 `findFragmentById()` 和 `findFragmentByTag()` 查找 Fragment
    - 通过 `getFragments()` 获取当前所有 Fragment
    - 通过 `setReorderingAllowed()` 设置是否允许事务操作的重新排序
    - 通过 `setCustomAnimations` 设置自定义动画, 应用于调用位置后续的所有 `Fragment` 操作
        - `setCustomAnimations(enter: Int, exit: Int, popEnter: Int, popExit: Int)`
- Fragment.SavedState
- FragmentActivity
- FragmentController
- FragmentFactory: 用于创建 Fragment 实例的工厂, 可以通过自定义工厂来控制 Fragment 的实例创建过程. 默认情况下, Fragment 会通过反射机制创建实例, 通过 `FragmentFactory` 可以自定义创建逻辑.
- FragmentHostCallback
- FragmentKt
- FragmentManager.FragmentLifecycleCallbacks
- FragmentManagerKt
- FragmentManagerNonConfig
- FragmentPagerAdapter
- FragmentStatePagerAdapter
- FragmentTabHost
- FragmentTransaction
- FragmentTransactionKt
- FragmentViewModelLazyKt
- ViewKt


```kotlin
class MainActivity : AppCompatActivity() {
    // 创建 Fragment 实例
    val fragment = MyFragment()
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        if (savedInstanceState == null) {

            supportFragmentManager.commit {
                setReorderingAllowed(true)
                add<MyFragment>(R.id.fragment_container_view)
            }
        }
    }
}
```

### androidx 导航组件(Navigation)

特点: 
- 固定起始目的地
- 通过堆栈管理目的地
- 向上和后退按钮功能一致
- 深度链接支持(深度链接时, 现有返回堆栈都将被删除, 基于导航图重建新的返回堆栈)

组成:
- Host: `NavHostFragment` 和 `NavHost`, 用来存储和展示所有导航目的地对象的 `Fragment` 容器组件, 使用时需要手动指定导航图
  - `navGraph` 属性绑定导航图
  - `defaultNavHost` 属性设置为 true, 以便使得此导航组件首先处理系统返回键事件.
- Graph: `NavGraph`, 定义导航目的地连接关系的数据结构, 构成一个导航图
  - 目的地类型: `fragment`, `activity`, `dialog`. 
    - `fragment`, 目的对象充满整个 Host 区域
    - `activity`, 退出导航图所在的 `Activity`, 启动一个新的 `Activity`
    - `dialog`, 展示在之前的内容上方
- Controller: `NavController`, 管理目的地之间导航, 处理深层链接, 处理返回堆栈等的协调员
  - 保存导航图并公开允许您的应用程序在图中的目的地之间移动的方法
  - 使用导航组件时，您可以使用 NavController 类创建导航控制器。 NavController 是中央导航 API。它跟踪用户访问过的目的地，并允许用户在目的地之间移动。
- Destination: `NavDestination`, 导航图中的节点, 通常在构建导航图时创建
- Route: 任何可序列化的数据类型, 通过 Route 进行导航到达目的地

目的地类型有三种: `Hosted` , `Dialog` , `Activity`
- `Hosted` 会使得目的内容占满整个导航内容区域
- `Dialog` 会使得目的内容展示在之前的内容上方
- `Activity` 会退出导航图所在的 Activity, 启动一个与导航组件分开管理的新 Android 活动


### androidx 分页组件(paging)

### 自定义 View

通常的自定义 View 流程:
- 继承自 `View` 或者 `ViewGroup` 类

```kotlin
/**
 * 自定义 View
 * params context 应用上下文
 * params attrs 属性集合, 用于在 xml 中使用自定义组件时, 为组件传递自定义属性(不使用时, 可以传递 null)
 * params defStyleAttr 默认样式, 用于在 xml 中使用自定义组件时, 为组件传递默认样式. 可以通过在 xml 中设置 style 属性来覆盖默认样式.
 */
class MyView(context: Context, attrs: AttributeSet, defStyleAttr: Int) : View(context, attrs, defStyleAttr) {
    // 1. 定义属性
    private var mText: String = ""

    // 2. 初始化属性
    init {
        val typedArray = context.obtainStyledAttributes(attrs, R.styleable.MyView, defStyleAttr, 0)
        mText = typedArray.getString(R.styleable.MyView_text) ?: ""
        typedArray.recycle()
    }
}

// 使用
<com.example.MyView
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    app:text="Hello World!" />

val myView = MyView(context).apply {
    text = "Hello World!"
    layoutParams = ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT)
}
```


- 重写 `override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int)` 方法, 在其中测量自定义 View 的大小
- 重写 `override fun onDraw(canvas: Canvas?)` 方法, 在其中绘制自定义 View 的内容
- 重写 `override fun onLayout(changed: Boolean, left: Int, top: Int, right: Int, bottom: Int)` 方法, 在其中布局自定义 View 的子 View
- 重写 `override fun onTouchEvent(event: MotionEvent?): Boolean` 方法, 在其中处理自定义 View 的触摸事件

#### `onMeasure` 方法

> [!cite]
>
> [onMeasure详解](https://blog.csdn.net/dmk877/article/details/49558367)

每个视图都有一个 `onMeasure` 方法, 用于测量视图的大小, 并通过 `setMeasuredDimension(width, height)` 方法设置视图的最终大小. 视图的大小由两部分组成: 宽度和高度, 其最终大小会受到父视图的测量要求 `MeasureSpec`(大小和模式), 视图自身的 `LayoutParams` 以及视图内容等因素的影响. 
- `MeasureSpec.EXACTLY` 精确模式, 视图大小是确定的, 由 `MeasureSpec.getSize()` 获取. 对应布局属性 `match_parent` 或者 `具体数值dp`
- `MeasureSpec.AT_MOST` 最大模式, 视图大小不能超过 `MeasureSpec.getSize()`, 通常是父视图的大小. 对应布局属性 `wrap_content`.
- `MeasureSpec.UNSPECIFIED` 未指定模式, 视图大小不受限制, 可以任意大小. 通常用于 `ScrollView` 中的子视图.

```java
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),
            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));
}

private void setMeasuredDimension(int measuredWidth, int measuredHeight) {
    mMeasuredWidth = measuredWidth;
    mMeasuredHeight = measuredHeight;
}
```

最根源的父视图是 `Activity` 绑定的 `Window` 视窗内的 `DecorView`. `Window` 视窗用于包含和管理应用的窗口内容有关的所有视图; `DecorView` 是一个继承自 `FrameLayout` 类型的根布局, 它的大小一般是手机屏幕的大小. 

```java
public class Activity ... { ...
    mWindow = new PhoneWindow(this, window, activityConfigCallback);
    public void setContentView(@LayoutRes int layoutResID) {
        mWindow.setContentView(layoutResID);
        initWindowDecorActionBar();
    }
}

public class PhoneWindow ... { ...
    public void setContentView(int layoutResID) {
        installDecor();
    }

    private void installDecor() {
        if (mDecor == null) {
            mDecor = new DecorView(context, -1, this, getAttributes());;
        }
        if (mContentParent == null) {
            ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);
            mContentParent = generateLayout(mDecor);
        }
    }
}
```

此外 `PhoneWindow` 又有一个 `mContentParent: FrameLayout` 容器, 用于存放实际的应用内容区域的视图, 大小通常是 `DecorView` 的大小减去状态栏和导航栏的高度.

`DecorView extends FrameLayout -> ViewGroup -> View` 也是个视图, 同时它也就有自己的 `onMeasure` 方法来测量自己的大小. 但是 `DecorView` 并没有父视图, 那么它的大小是怎么确定的呢?

首先每一个 `View` 都会通过 `measure(widthMeasureSpec, heightMeasureSpec)` 方法来测量自己的大小, 因此只需要搞清楚这里的 `widthMeasureSpec` 和 `heightMeasureSpec` 的来源即可. 这里需要去追溯到 `ViewRootImpl`.

在 `PhoneWindow` 创建的同时, 会创建一个 `ViewRootImpl` 对象自动与 `DecorView` 绑定, 用于管理当前窗口内部视图树内所有视图的绘制和事件分发. 而 `DecorView` 就可以通过 `getViewRootImpl()` 通过得到的 `ViewRootImpl` 对象来触发 `ViewRootImpl` 的 `performTraversals()` 方法来重新测量自己的大小.

```java
public class PhoneWindow ... { ...
    private void openPanel(final PanelFeatureState st, KeyEvent event) {
        ...
        final WindowManager wm = getWindowManager();
        wm.addView(st.decorView, lp);
        ...
    }
}

// WindowManagerImpl
public final class WindowManagerGlobal { ...
    public void addView(View view, ViewGroup.LayoutParams params, ...) {
        ViewRootImpl root;
        root = new ViewRootImpl(view.getContext(), display);
        mViews.add(view);
        mRoots.add(root);
        ...
    }
}
```

`ViewRootImpl` 会在自己的 `performTraversals()` 方法中计算 `DecorView` 需要的根测量规格 `childWidthMeasureSpec` 或 `childHeightMeasureSpec`.

简单来说这两个测量规格的计算取决于窗口的类型, 如果是特殊窗口类型, 直接使用设备的宽高, 如果是 `WRAP_CONTENT` 类型, 则扣除系统栏的高度后, 当前窗口在屏幕上显示的实际矩形区域, 其他情况直接使用 `WindowManager` 获取的屏幕尺寸. 具体的计算还有更多细节.

然后 `ViewRootImpl` 会利用计算好的根测量规格调用 `performMeasure()` 方法来执行 `DecorView` 的 `measure(...)` 方法, 从而使得 `DecorView` 根据根测量规格来测量自己的大小.

```java
public final class ViewRootImpl ... {
    private void performTraversals() {
        ...
        int desiredWindowWidth;
        int desiredWindowHeight;
        Rect frame = mWinFrame;
        if (mFirst) {
            final Configuration config = mContext.getResources().getConfiguration();
            if (shouldUseDisplaySize(lp)) {
                Point size = new Point();
                mDisplay.getRealSize(size);
                desiredWindowWidth = size.x;
                desiredWindowHeight = size.y;
            } else if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT
                    || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
                desiredWindowWidth = dipToPx(config.screenWidthDp);
                desiredWindowHeight = dipToPx(config.screenHeightDp);
            } else {
                desiredWindowWidth = frame.width();
                desiredWindowHeight = frame.height();
            }
        } else {
            desiredWindowWidth = frame.width();
            desiredWindowHeight = frame.height();
        }

        // Ask host how big it wants to be
        windowSizeMayChange |= measureHierarchy(mView, layoutParams, contextResources,
                desiredWindowWidth, desiredWindowHeight);
    }

    private boolean measureHierarchy(host, lp, res, desiredWindowWidth, desiredWindowHeight) {
        ...
        final DisplayMetrics packageMetrics = res.getDisplayMetrics();
            childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);
            childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);
            performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);
        ...
    }

    private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) {
        mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);
    }
}
```

其中 `measure(...)` 方法中有一个默认的根据测量规格计算大小的实现, 即 `onMeasure()` 方法, 它会直接使用所提供的测量规格提供的大小. (因为一般传入的模式不会是 `MeasureSpec.UNSPECIFIED`)

#### `onLayout` 方法

每个视图都有一个 `onLayout` 方法, 用于布局当前视图相对于父视图的位置, 并通过 `setFrame(left, top, right, bottom)` 方法设置视图的最终位置. 视图的位置由四个坐标值组成: 左上角的 x 坐标和 y 坐标, 右下角的 x 坐标和 y 坐标, 其最终位置取决于设置的坐标, 分别对应以下四个属性:
- `mLeft——View.getLeft()`: 当前视图的左边界到父视图的左边界的距离
- `mTop——View.getTop()`: 当前视图的顶部到父视图顶部的距离
- `mRight——View.getRight()`: 当前视图的右边界到父视图的左边界的距离
- ``mBottom——View.getBottom(): 当前视图的底部到父视图的顶部的距离

```java
public void layout(int l, int t, int r, int b) {
    ...
    int oldL = mLeft;
    int oldT = mTop;
    int oldB = mBottom;
    int oldR = mRight;
    boolean changed = setFrame(l, t, r, b);
    if (changed) {
        onLayout(changed, l, t, r, b);
    }
}

protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
}

protected boolean setFrame(int left, int top, int right, int bottom) {
    boolean changed = false;

    if (mLeft != left || mRight != right || mTop != top || mBottom != bottom) {
        changed = true;

        int oldWidth = mRight - mLeft;
        int oldHeight = mBottom - mTop;
        int newWidth = right - left;
        int newHeight = bottom - top;
        boolean sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight);

        invalidate(sizeChanged);

        mLeft = left;
        mTop = top;
        mRight = right;
        mBottom = bottom;
        mRenderNode.setLeftTopRightBottom(mLeft, mTop, mRight, mBottom);
    }
    return changed;
}


```

最根源的父视图是 `Activity` 绑定的 `Window` 视窗内的 `DecorView`. 与 `onMeasure` 方法的介绍类似, `DecorView` 可以通过触发绑定的 `ViewRootImpl` 对象的 `performTraversals()` 方法来重新布局自己的子视图. 默认的根布局区域就是 `onMeasure` 方法中确定的测量大小所占区域.

```java
public final class ViewRootImpl ... {
    private void performTraversals() {
        windowSizeMayChange |= measureHierarchy(mView, layoutParams, contextResources,
                desiredWindowWidth, desiredWindowHeight);
        
        if (mWidth != frame.width() || mHeight != frame.height()) {
            mWidth = frame.width();
            mHeight = frame.height();
        }
        performLayout(lp, mWidth, mHeight);
    }

    private void performLayoutWindowManager.LayoutParams lp, int desiredWindowWidth,
            int desiredWindowHeight {
        mView.layout(0, 0, mView.getMeasuredWidth(), mView.getMeasuredHeight());

        // 这里如果布局失败, 会尝试使用 desiredWindowWidth 和 desiredWindowHeight 参数重新计算视图大小, 并重新布局
    }
}
```

#### `getMeasuredWidth` 和 `getWidth` 方法的区别

- `getMeasureWidth()` 方法在 `measure()` 过程结束后就可以获得到它的值.
- `getWidth()` 方法要在 `layout()`过程结束后才能获取到.

自定义控件的时候在 `onLayout` 方法中一般采用 `getMeasuredWidth` 来获得控件的宽度.
在除了 `onLayout` 之外的方法中采用 `getWidth` 方法来获取控件的宽度.


```java
public class View ... {
    public final int getMeasuredWidth() {
        return mMeasuredWidth & MEASURED_SIZE_MASK;
    }

    public final int getWidth() {
        return mRight - mLeft;
    }
}
```

#### TextPaint

`TextPaint` 是 `Paint` 的子类, 用于绘制文本的画笔. `TextPaint` 除了继承了 `Paint` 的所有属性和方法外, 还有一些专门用于绘制文本的属性和方法.

- `TextPaint.setTextSize(float textSize)`: 设置文本大小
- `TextPaint.setTypeface(Typeface typeface)`: 设置字体样式
- `TextPaint.setUnderlineText(boolean underlineText)`: 设置是否显示下划线
- `TextPaint.setStrikeThruText(boolean strikeThruText)`: 设置是否显示删除线

文本的基本信息 `Paint.FontMetrics`:
- `baseline`: 基线, 文本绘制的基准线, 用于绘制文本的起始位置
- `ascent`: 文本中字符的最高点到基线的距离
- `descent`: 文本中字符的最低点到基线的距离
- `top`: 文本中字符可以达到的最高点到基线的距离
- `leading`: 

文本居中的计算方法: `int baseline = viewHeight / 2 + (fontMetrics.descent - fontMetrics.ascent) / 2 - fontMetrics.descent;`

### 动画和过渡

> [!cite]
> 
> [](https://developer.android.com/guide/fragments/animate)
> [Frame Animation（逐帧动画）](https://developer.aliyun.com/article/567019)

#### Frame动画(帧动画)

帧动画: 通过一系列的图片帧来实现动画效果, 适用于帧数较少的动画效果
- 动画文件定义位置: `res/drawable/`
- 动画启动尽量在 `onWindowFocusChanged` 方法中启动, 以避免动画启动时界面未绘制完成的问题
- 使用时以 `ImageView` 为载体, 通过 `ImageView.setBackgroundResource()` 方法设置动画资源, 并通过将背景转换为 `AnimationDrawable` 对象来启动动画

```kotlin
// rocket_thrust_anim.xml
<?xml version="1.0" encoding="utf-8"?>
<animation-list 
    xmlns:android="http://schemas.android.com/apk/res/android"
    <-- 动画是否只播放一次 --/>
    android:oneshot="false"
    >
    <item android:drawable="@drawable/rocket_thrust1" android:duration="200" />
    <item android:drawable="@drawable/rocket_thrust2" android:duration="200" />
    <item android:drawable="@drawable/rocket_thrust3" android:duration="200" />
</animation-list>

<ImageView
    android:id="@+id/rocket_image"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:background="@drawable/rocket_thrust_anim" />

// 使用
ImageView rocketImage = (ImageView) findViewById(R.id.rocket_image);
rocketImage.setBackgroundResource(R.drawable.rocket_thrust);
AnimationDrawable rocketAnimation = (AnimationDrawable) rocketImage.getBackground();
rocketAnimation.start();
```

#### Tween Animation（补间动画, 平移, 缩放, 旋转, 透明度）
> [!cite]
>
> [Tween(补间动画)完全解析](https://blog.csdn.net/dmk877/article/details/51912104)

补间动画: 通过对视图的属性进行动画操作, 适用于简单的动画效果
- 动画文件定义位置: `res/anim/`
- 使用时以 `View` 为载体, 通过 `View.startAnimation()` 方法启动动画

```xml
<translation xmlns:android="http://schemas.android.com/apk/res/android"
    // 平移动画
    android:fromXDelta="0" // 起始位置 x 坐标 (px值, 百分比值, 百分比 p 值)
    android:toXDelta="100" // 结束位置 x 坐标
    android:fromYDelta="0" // 起始位置 y 坐标
    android:toYDelta="100" // 结束位置 y 坐标

// 百分比 p 值表示相对于父容器宽或高的百分比值, 0% 表示起始位置, 100% 表示结束位置
/>

<scale xmlns:android="http://schemas.android.com/apk/res/android"
    // 缩放动画
    android:fromXScale="1.0" // 起始 x 缩放比例, 0-1 缩小, 1-∞ 放大
    android:toXScale="0.5" // 结束 x 缩放比例
    android:fromYScale="1.0" // 起始 y 缩放比例
    android:toYScale="0.5" // 结束 y 缩放比例

    android:pivotX="50%" // 视图缩放的中心 x 坐标 (px 值, 百分比值, 百分比 p 值)
    android:pivotY="50%" // 视图缩放的中心 y 坐标
/>

<rotate xmlns:android="http://schemas.android.com/apk/res/android"
    // 旋转动画
    android:fromDegrees="0" // 起始角度
    android:toDegrees="360" // 结束角度
    android:pivotX="50%" // 旋转中心 x 坐标 (px 值, 百分比值, 百分比 p 值)
    android:pivotY="50%" // 旋转中心 y 坐标
/>

<alpha xmlns:android="http://schemas.android.com/apk/res/android"
    // 透明度动画
    android:fromAlpha="1.0" // 起始透明度
    android:toAlpha="0.0" // 结束透明度
/>

<set xmlns:android="http://schemas.android.com/apk/res/android"
    // 组合动画
    android:shareInterpolator="true" // 是否共享插值器, false 时需要为每个子动画设置插值器
    android:ordering="together" // 动画执行顺序, together 为同时执行, sequential 为顺序执行. 可以通过 startOffset 属性自定义每个动画开始前的延迟时间
>

    <alpha
        ...
    />

    <scale
        ...
    />

    ...

</set>

<any 
    // 通用属性
    android:duration="1000" // 动画持续时间
    android:startOffset="1000" // 动画开始前的延迟时间
    android:fillBefore="true" // 动画结束后是否回到初始状态, 默认为 true
    android:fillEnabled="true" // 是否启用 fillBefore, 默认为 true
    android:fillAfter="true" // 动画结束后是否保持结束状态, 默认为 false, 优先于 fillBefore
    android:repeatCount="infinite" // 动画重复次数, 默认为 0, 0 为不重复, -1 为无限重复
    android:repeatMode="reverse" // 动画重复模式, 默认为 restart, reverse 为反向重复
    android:interpolator="@android:anim/accelerate_decelerate_interpolator" // 动画插值器
/>
```

默认可用的插值器:
- `@android:anim/linear_interpolator`: 线性匀速
- `@android:anim/decelerate_interpolator`: 减速
- `@android:anim/accelerate_interpolator`: 加速
- `@android:anim/overshoot_interpolator`: 快速超出终点一小步后回弹到终点
- `@android:anim/anticipate_interpolator`: 先回退一小步再加速
- `@android:anim/accelerate_decelerate_interpolator`: 先加速后减速
- `@android:anim/anticipate_overshoot_interpolator`: 先回退一小步再加速, 最后超出重点一小步后回弹到终点
- `@android:anim/bounce_interpolator`: 加速到终点后持续弹跳直至停止
- `@android:anim/cycle_interpolator`: 周期运动

```xml
// 自定义插值器
<linearInterpolator xmlns:android="http://schemas.android.com/apk/res/android" /> // 无法自定义参数
<decelerate_interpolator xmlns:android="http://schemas.android.com/apk/res/android" android:factor="2" /> // 可设置减速因子
<accelerate_interpolator xmlns:android="http://schemas.android.com/apk/res/android" android:factor="2" /> // 可设置加速因子
<overshootInterpolator xmlns:android="http://schemas.android.com/apk/res/android" android:tension="2" /> // 可设置超出终点后的张力(回拉力)
<anticipate_interpolator xmlns:android="http://schemas.android.com/apk/res/android" android:tension="2" /> // 可设置回退一小步的张力
<accelerateDecelerateInterpolator xmlns:android="http://schemas.android.com/apk/res/android" /> // 无法自定义参数
<anticipateOvershootInterpolator xmlns:android="http://schemas.android.com/apk/res/android" android:tension="2" android:extraTension="2" /> // 可设置回退一小步的张力和超出终点后的张力
<bounceInterpolator xmlns:android="http://schemas.android.com/apk/res/android" /> // 无法自定义参数
<cycleInterpolator xmlns:android="http://schemas.android.com/apk/res/android" android:cycles="2" /> // 
```

#### Property Animation（属性动画）

属性动画: 通过对视图的属性进行动画操作, 适用于复杂的动画效果. 
- 针对属性值进行动画操作, 因此适用于任何对象的任何属性, 而不仅限于平移, 缩放, 旋转, 透明度等.
- 动画操作可以针对于对象本身, 而不是如补间动画那样只是改变了视图对象的显示效果.
- 属性动画支持所有的通用属性, 如动画持续时间, 动画插值器等.

**代码使用方式**

- `ValueAnimator`

构造时直接传入起始值, 中间值(可选, 可多个), 结束值. 使用时需要通过动画监听器来监听动画过程中属性值的变化, 并在监听器中根据当前属性值来更新目标对象的属性值(如视图的位置), 从而实现动画效果. 注意动画监听器有两种, 一种是专属 `ValueAnimator`的 `AnimatorUpdateListener` 用于监听动画过程中属性值的变化, 另一种是 `AnimatorListener` 用于监听动画的开始, 结束, 取消, 重复等事件.

```kotlin
// 创建 ValueAnimator 对象
val valueAnimator = ValueAnimator.ofInt(0, 100).apply {
    // 设置动画持续时间
    duration = 1000
    // 设置动画插值器
    interpolator = AccelerateDecelerateInterpolator()
    // 添加动画监听器
    addUpdateListener {
        val value = it.animatedValue as Int
        view.layout(value, value, value + view.width, value + view.height)
    }
}
// 启动动画
valueAnimator.start()
```

- `ObjectAnimator`

`ObjectAnimator` 是 `ValueAnimator` 的子类, 用于对对象的属性进行动画操作. 构造时需要传入目标对象, 属性名称, 起始值, 中间值(可选, 可多个), 结束值. 使用时直接调用 `start()` 方法启动动画. 注意对象属性必须可以 get 和 set.

```kotlin
// 创建 ObjectAnimator 对象
val objectAnimator = ObjectAnimator.ofFloat(view, "translationX", 0f, 100f).apply {
    // 设置动画持续时间
    duration = 1000
    // 设置动画插值器
    interpolator = AccelerateDecelerateInterpolator()
}
// 启动动画
objectAnimator.start()
```


- `TimeAnimator`

`TimeAnimator` 是 `ValueAnimator` 的子类, 用于监听动画过程中的时间变化. 使用时需要通过动画监听器来监听动画过程中时间的变化, 并在监听器中根据当前时间来更新目标对象的属性值, 从而实现动画效果. 注意动画监听器有两种, 一种是专属 `TimeAnimator`的 `TimeListener` 用于监听动画过程中时间的变化, 另一种是 `AnimatorListener` 用于监听动画的开始, 结束, 取消, 重复等事件.

```kotlin
// 创建 TimeAnimator 对象
val timeAnimator = TimeAnimator().apply {
    // 添加动画监听器
    setTimeListener { animation, totalTime, deltaTime ->
        view.layout(deltaTime.toInt(), deltaTime.toInt(), deltaTime.toInt() + view.width, deltaTime.toInt() + view.height)
    }
}
// 启动动画
timeAnimator.start()
```

- `AnimatorSet`

借助 `AnimatorSet` 可以将多个动画组合在一起, 并设置它们的执行顺序, 重复次数, 重复模式等. 使用时需要通过 `play()` 方法将多个动画添加到 `AnimatorSet` 中, 然后通过 `start()` 方法启动动画.

```kotlin
// 创建 ObjectAnimator 对象
val objectAnimator1 = ...
val objectAnimator2 = ...
val objectAnimator3 = ...
val objectAnimator4 = ...
val objectAnimator5 = ...

// 创建 AnimatorSet 对象
val animatorSet = AnimatorSet().apply {
    // 设置动画执行顺序
    play(objectAnimator1).before(objectAnimator2)
    playTogether(objectAnimator2, objectAnimator3).before(objectAnimator4)
    playSequentially(objectAnimator4, objectAnimator5)
    // 设置动画重复次数
    repeatCount = ValueAnimator.INFINITE
    // 设置动画重复模式
    repeatMode = ValueAnimator.REVERSE
}
// 启动动画
animatorSet.start()
```

**xml 使用方式**

- 动画文件定义位置: `res/animator/`
- 使用时需要每个动画都需要绑定目标对象的属性名称, 并通过 `setTarget()` 方法绑定目标对象, 然后再通过 `start()` 方法启动动画.

```xml
<objectAnimator xmlns:android="http://schemas.android.com/apk/res/android"
    android:propertyName="translationX" // 动画属性名称
    android:valueFrom="0" // 起始值
    android:valueTo="100" // 结束值
    android:valueType="floatType" // 属性值类型
/>

<any 
    // 通用属性
    android:duration="1000" // 动画持续时间
    android:startOffset="1000" // 动画开始前的延迟时间
    android:fillBefore="true" // 动画结束后是否回到初始状态, 默认为 true
    android:fillEnabled="true" // 是否启用 fillBefore, 默认为 true
    android:fillAfter="true" // 动画结束后是否保持结束状态, 默认为 false, 优先于 fillBefore
    android:repeatCount="infinite" // 动画重复次数, 默认为 0, 0 为不重复, -1 为无限重复
    android:repeatMode="reverse" // 动画重复模式, 默认为 restart, reverse 为反向重复
    android:interpolator="@android:anim/accelerate_decelerate_interpolator" // 动画插值器
/>

```

#### 布局动画


## 网络库(HttpURLConnection, OkHttp, Retrofit, 内部库)

网络请求库 = 网络请求 + 数据解析 + 线程切换(异步) + 异常处理

### HttpURLConnection

> [!TODO]

### OkHttp

> [!cite]
> [【OkHttp】OkHttp Get 和 Post 请求 ( 同步 Get 请求 | 异步 Get 请求 | 同步 Post 请求 | 异步 Post 请求 )-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/2249988)
> [网络请求框架OkHttp3全解系列 (一) ：OkHttp的基本使用-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/1667338)
> [由浅入深, 聊聊OkHttp的那些事(易懂, 不繁琐) - 掘金](https://juejin.cn/post/7199431845367922745?searchId=20240806152219108948FAF7C05048547D)
> [ \[Android\] 主流网络请求框架 OkHttp 全方位详析 - 掘金](https://juejin.cn/post/7345756317557817354?searchId=20240806152219108948FAF7C05048547D)
> [从OKHttp框架看代码设计](https://juejin.cn/post/6844903449469943821?searchId=2024080615223180876F5097A608E5EACE)
> [HTTP客户端连接, 选择HttpClient还是OkHttp？](https://juejin.cn/post/6844904040644476941?searchId=2024080615223180876F5097A608E5EACE)
> [OkHttp的完整指南](https://juejin.cn/post/7068162792154464264?searchId=2024080615223180876F5097A608E5EACE)
> [雨露均沾的OkHttp—WebSocket长连接 (使用篇)  - 掘金](https://juejin.cn/post/6847009772198166536?searchId=2024080615223180876F5097A608E5EACE)
> [官方推荐使用的OkHttp4网络请求库全面解析！](https://juejin.cn/post/7212536164057776184?searchId=2024080615223180876F5097A608E5EACE)
> [OkHttp 拦截器的一些骚操作 - 掘金](https://juejin.cn/post/6844903606718562317?searchId=2024080615223180876F5097A608E5EACE)
> [一篇文章带你走通 OkHttp+Retrofit+Rxjava - 掘金](https://juejin.cn/post/6844903464082866190?searchId=2024080615223180876F5097A608E5EACE)
> [使用 Retrofit 2.0 + OkHttp 3.0 实现缓存处理 - 掘金](https://juejin.cn/post/6844903444285751309?searchId=2024080615223180876F5097A608E5EACE)
> [OKHttp源码解析(一)--初阶-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/1199021)

- 简洁易用的 API：通过构建 Request 对象和使用 Call 对象来发起同步或异步的网络请求. 
- 支持现代的 HTTP 协议, 包括 HTTP/2 和 SPDY
- 连接池和缓存：OkHttp 内置了连接池和响应缓存, 可以有效地管理和复用网络连接, 并提供可配置的缓存机制, 减少重复的网络请求. 
- 自动重试 ：在请求失败时自动重试请求, 从而提高请求可靠性. 
- 拦截器：提供拦截器机制, 允许在发送请求和接收响应的过程中进行自定义处理, 例如添加公共参数、日志记录等. 
- 支持gzip压缩 ：支持接受和解压 GZIP 压缩的响应数据, 减小网络传输的数据量, 提升网络性能. 

#### 使用

![](安卓开发.assets/file-20240806154800379.png)

```kotlin
val client = OkHttpClient.Builder() // 1. 创建 OkHttpClient 实例
    .connectTimeout(5000L, java.util.concurrent.TimeUnit.MILLISECONDS)
    .readTimeout(5000L, java.util.concurrent.TimeUnit.MILLISECONDS)
    .writeTimeout(5000L, java.util.concurrent.TimeUnit.MILLISECONDS)
    .retryOnConnectionFailure(true)
    .followRedirects(true)
    .followSslRedirects(true)
    .cache(null) // 设置缓存
    .authenticator(null) // 设置身份验证器
    .certificatePinner(null) // 设置证书锁定器
    .connectionPool(null) // 设置连接池
    .connectionSpecs(listOf()) // 设置连接规范
    .cookieJar(null) // 设置 Cookie 管理器
    .dispatcher(null) // 设置分发器
    .dns(null) // 设置 DNS 解析器
    .eventListenerFactory(null) // 设置事件监听器工厂
    .proxy(null) // 设置代理
    .protocols(listOf()) // 设置支持的协议
    .proxyAuthenticator(null) // 设置代理身份验证器
    .proxySelector(null) // 设置代理选择器
    .socketFactory(null) // 设置 Socket 工厂
    .hostnameVerifier(null) // 设置主机名验证器
    .build()

val getRequest = Request.Builder() // 2. 创建 Request 对象
    .url("https://reqres.in/api/users?page=2")
    .header("name", "value")
    .addHeader("name", "value")
    .cacheControl(null) // 设置缓存控制
    .build()

// 3. 同步请求
val response1 = client.newCall(getRequest).execute().use { response ->
    response.body?.string() ?: ""
}

// 3. 异步请求, 如果当前 request 已执行, 抛出错误
val response2 = client.newCall(get).enqueue(object : Callback {
    override fun onFailure(call: Call?, e: IOException) {
        //
    }

    override fun onResponse(call: Call?, response: Response) {
        val content = response.body?.string() ?: ""
    }
})
```

#### 原理

> [!cite]
> [由浅入深, 聊聊OkHttp的那些事(易懂, 不繁琐) - 掘金](https://juejin.cn/post/7199431845367922745?searchId=20240806152219108948FAF7C05048547D)
> [面试官：听说你熟悉OkHttp原理？ - 掘金](https://juejin.cn/post/6844904087788453896?searchId=20240806152219108948FAF7C05048547D)

![](安卓开发.assets/file-20240806152547281.png)

> [!TODO]

### Retrofit

> [!TODO]

### 内部库






## 临时

### Git – 断点续传git大项目
假设要从GitHub拉取OpenCV：https://github.com/opencv/opencv进行编译, 可以按照以下的方法. 
1. 首先新建一个项目文件夹, 初始化空白 git 仓库
```
mkdir opencv
cd opencv
git init
```
2. 添加远程仓库
```
git remote add origin https://github.com/opencv/opencv
```
3. 拉取所有分支、标签和完整历史记录
```
git fetch origin --prune --tags +refs/heads/*:refs/remotes/origin/*

origin：指定远程仓库名. 
--prune：删除本地没有的远程分支. 
--tags：获取所有标签. 
+refs/heads/*:refs/remotes/origin/*：获取远程仓库的所有分支, 并将其映射到本地的 refs/remotes/origin/ 下, 一般可以不加此选项
```
4. 如果第3步中断或者失败, 则重复执行第3步, 直到完成下载
5. 下载完成之后, 检出需要的分支或标签, 如 master
```
git branch -r
git tag
git checkout master
```
6.  更新所有本地分支和远程分支的映射关系
```
git pull origin --all
```
7. 再执行git checkout master命令
在Linux系统下, 可以写一个shell脚本, 自动循环进行git fetch.


### 为什么减少依赖很重要？

这段内容强调了在开发 Android 应用时, 应该尽量减少对 Android 框架类 (如 Context、Toast 等) 的直接依赖, 将这些依赖隔离在少数核心组件中. 这样做的主要目的是提高代码的可测试性和模块化, 降低耦合度. 
1. 提高可测试性：当类依赖于 Android 框架时 (例如需要一个 Context 实例) , 在编写单元测试时, 必须模拟这些依赖对象, 这可能会增加复杂性. 如果业务逻辑不依赖于 Android 框架类, 那么编写单元测试就变得更加容易, 因为你只需要测试纯粹的业务逻辑, 而不必处理 Android 特有的依赖. 
2. 降低耦合度：如果类依赖于 Android 框架, 它们就只能在 Android 环境中运行 (例如设备或模拟器). 通过减少这种依赖性, 代码可以更独立、更灵活, 可以在不同的环境中复用, 且不容易受到 Android 特定 API 的限制. 
举例说明
不良的依赖设计
考虑以下示例, 一个 UserManager 类直接依赖于 Context 来获取资源或展示 Toast：

```
class UserManager(private val context: Context) {

    fun showWelcomeMessage() {
        // 使用 Context 来显示 Toast 消息
        Toast.makeText(context, "Welcome!", Toast.LENGTH_SHORT).show()
    }
}
```

在这个设计中, UserManager 类直接依赖于 Context, 这会带来以下问题：
- 难以测试：在测试时, 你需要提供一个 Context 实例, 这可能会使测试更加复杂和笨重. 
- 耦合性高：UserManager 只能在 Android 环境中使用, 因为它需要一个 Context 实例. 
改进后的设计
现在我们将 UserManager 中与 Android 相关的操作抽离到一个单独的接口中, 这样就可以减少对 Android 类的直接依赖：
```
interface MessageDisplayer {
    fun showMessage(message: String)
}

class ToastMessageDisplayer(private val context: Context) : MessageDisplayer {
    override fun showMessage(message: String) {
        Toast.makeText(context, message, Toast.LENGTH_SHORT).show()
    }
}

class UserManager(private val messageDisplayer: MessageDisplayer) {

    fun showWelcomeMessage() {
        // 使用抽象接口来显示消息
        messageDisplayer.showMessage("Welcome!")
    }
}
```
在这个改进的设计中：
- MessageDisplayer：定义了一个抽象接口, 它不依赖于 Android 框架. 这个接口可以有不同的实现, 比如 ToastMessageDisplayer 用于 Android 环境. 
- ToastMessageDisplayer：是 MessageDisplayer 的具体实现, 负责实际显示 Toast 消息. 它依赖 Context, 但这种依赖被隔离在了这个具体的类中. 
- UserManager：现在只依赖于 MessageDisplayer 接口, 而不是直接依赖 Context. 这使得 UserManager 可以轻松地进行单元测试, 因为你可以传递一个简单的 MessageDisplayer mock 对象. 
在测试中的优势
在测试 UserManager 时, 你不再需要依赖 Context 或 Android 特有的类：
```
class FakeMessageDisplayer : MessageDisplayer {
    var message: String? = null

    override fun showMessage(message: String) {
        this.message = message
    }
}

fun testShowWelcomeMessage() {
    val fakeMessageDisplayer = FakeMessageDisplayer()
    val userManager = UserManager(fakeMessageDisplayer)

    userManager.showWelcomeMessage()

    assert(fakeMessageDisplayer.message == "Welcome!")
}
```
在这个测试中, FakeMessageDisplayer 是 MessageDisplayer 的一个简单实现, 允许你检查 UserManager 的行为而不需要 Context. 
总结
减少对 Android 类的直接依赖, 通过使用接口或抽象类来隔离 Android 相关操作, 可以让你的应用更加模块化和可测试. 你可以将业务逻辑与 Android 特有的实现细节分开, 使代码更灵活、更容易测试, 也更符合 SOLID 原则中的单一职责和依赖倒置原则. 


### 文件读写和权限说明

> [!todo]
> (记一个 Android 14 适配引发的Android 存储权限问题)[https://www.cnblogs.com/joy99/p/17809113.html]
> (Android 文件读写最全解析)[https://www.cnblogs.com/joy99/p/17809113.html]
> (Android 数据存储五种方式使用与总结.md)[https://github.com/helen-x/AndroidInterview/blob/master/android/Android%20%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%BA%94%E7%A7%8D%E6%96%B9%E5%BC%8F%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%80%BB%E7%BB%93.md]

sharedPreferences: 基于XML文件存储的键值对数据, 根据第一个参数name获得相应的SharedPreferences对象
- MODE_PRIVATE: 只能被本应用程序读、写
- MODE_WORLD_READABLE: 其他应用程序可以读, 但不能写
- MODE_WORLD_WRITEABLE: 其他应用程序可以读, 写
- MODE_MULTI_PROCESS: 当多个进程同时读写同一个 SharedPreferences 时, 会检查文件是否修改


## Android 多线程
任务执行和管理: `Thread` | `Runnable` | `Executors` | `WorkManager` (`AsyncTask` 弃用了) | `ThreadPoolExecutor`
任务反馈及交互:  `Callable` | `Future` | `FutureTask` | `Handler` | `HandlerThread` | 

### 直接创建和管理线程及其任务

子类化 `Thread`. 通过复写 `run` 方法自定义线程任务, 同时可以通过创建的线程对象管理线程, 如 运行、睡眠、挂起、停止.

```
class MyThread(name: String) : Thread(name) {
    private var ticket = 100
    override fun run() {
        while (ticket > 0) {
            ticket--
            Thread.sleep(1000)
        }
    }
}

// 创建线程对象并启动
val mt = MyThread("线程名称")
mt.start()

// 使用匿名类创建和启动线程
Thread("线程名称") {
    var ticket = 100
    while (ticket > 0) {
        ticket--
        println("线程名称: 卖掉了1张票, 剩余票数为: $ticket")
        Thread.sleep(1000) // 卖票速度是1秒一张
    }
}.start()
```

### 任务与线程分离, 实现线程复用和资源共享

通过实现 `Runnable` 任务接口, 只需要定义一个 `run` 方法来自定义线程任务(即只关注于任务). 通过创建 `Runnable` 任务对象, 并将 `Runnable` 对象传递给一个或多个线程对象, 使得线程对象可以执行 `Runnable` 对象定义的线程任务, 同时共享此 `Runnable` 对象中的资源. 线程的管理仍是通过线程对象自身进行, 但是无需子类化 `Thread`.

```
class MyRunnable : Runnable {
    private var ticket = 100
    override fun run() {
        while (ticket > 0) {
            ticket--
            Thread.sleep(1000)
        }
    }
}

// 创建线程对象并启动任务
val myRunnable = MyRunnable()
val thread1 = Thread(myRunnable)
val thread2 = Thread(myRunnable)
thread1.start()
thread2.start()

// 使用匿名 Runnable 创建和启动线程
val runnable = Runnable {
    var ticket = 100
    while (ticket > 0) {
        ticket--
        Thread.sleep(1000)
    }
}

Thread(runnable, "线程名称1").start()
Thread(runnable, "线程名称2").start()

// 使用 lambda 表达式创建和启动线程, lambda 表达式会被自动转换成 Runnable. 
Thread {
    var ticket = 100
    while (ticket > 0) {
        ticket--
        Thread.sleep(1000)
    }
}.start()
```

### 使用线程池简化线程创建和生命周期管理

将任务提交给线程池, 根据需要分配线程来执行任务.
 
`Executor` 是一个接口, 只限制了实现任务提交到线程池和任务执行的功能.
`ExecutorService` 是在 `Executor` 的基础上进一步定义的接口, 提供了控制任务执行和更高级的任务提交功能.
- `shutdown()` 方法停止提交任务, 并允许先前提交的任务继续执行, 直到执行完成.
- `shutdownNow()` 方法停止提交任务, 并阻止等待先前提交的任务, 尝试停止当前正在执行的任务.
- `submit(...)` 方法提交任务, 并返回一个可用于取消任务执行和存放任务结果的 `Future` 对象.
- `invokeAny` 和 `invokeAll` 执行一组任务, 然后等到至少一个或全部任务完成.
`ScheduledExecutorService` 是在 `ExecutorService` 基础上进一步定义的接口, 提供了延迟和周期性执行任务的功能.
- `schedule(...)` 方法, 用于延迟执行任务.
- `scheduleAtFixedRate(...)` 方法, 用于周期性执行任务.
- `scheduleWithFixedDelay(...)` 方法, 用于周期性执行任务, 但是在任务完成后的固定延迟后再次执行.

完整的实现了 `ExecutorService` 或 `ScheduledExecutorService` 的线程池服务类型有: 
- `ForkJoinPool`
- `ScheduledExecutorService`
- `ThreadPoolExecutor`
  - `ScheduledThreadPoolExecutor`

`Executors` 是一个工具类, 提供了方便的工厂方法来创建以上列举的不同类型的线程池服务对象.

```
// 固定大小的线程池, 适用于需要限制线程数量, 且需要复用线程执行大量短期任务的场景
val executor = Executors.newFixedThreadPool(3) // ExecutorService
// 可缓存的线程池, 优先复用已有线程, 不足时根据需要创建新线程, 适用于执行大量生存期很短的异步任务
val executor = Executors.newCachedThreadPool()
// 只有一个线程, 所有任务按照提交顺序执行
val executor = Executors.newSingleThreadExecutor()
executor.execute { Thread.sleep(1000) } // 模拟任务执行时间
executor.shutdown()

// 定时任务线程池, 适用于需要延迟执行或周期性执行任务的场景
val scheduler = Executors.newScheduledThreadPool(2)
scheduler.schedule({ Thread.sleep(1000) }, 2, TimeUnit.SECONDS) // 延迟2秒后执行
scheduler.scheduleAtFixedRate({ Thread.sleep(1000) }, 1, 3, TimeUnit.SECONDS) // 延迟1秒后, 每3秒执行一次
scheduler.shutdown()

// 自定义线程池
val threadPool = ThreadPoolExecutor(
    2, // 核心线程数
    4, // 最大线程数
    60, // 空闲线程存活时间
    TimeUnit.SECONDS, // 时间单位
    LinkedBlockingQueue<Runnable>(2) // 任务队列
)
threadPool.execute { Thread.sleep(1000) } // 模拟任务执行时间
threadPool.shutdown()
```

### 异步获取任务结果

`ExecutorService` 和 `ScheduledExecutorService` 两种任务执行器类型的 `submit` 或 `schedule` 等方法均可以通过传递一个 `Callable` 任务对象来返回一个表示异步计算结果的 `Future` 或 `ScheduledFuture` 对象. 通过 `Future` 对象可以取消其所绑定的任务, 获取任务执行状态, 以及获取任务执行结果.

```
val executor = Executors.newSingleThreadExecutor()
val callableTask = Callable {
    Thread.sleep(1000)
    "Callable 任务执行结果"
}
val future: Future<String> = executor.submit(callableTask)
println("任务执行结果: ${future.get()}")
executor.shutdown()

Thread 可以通过 FutureTask 将任务进行封装, 其可以同时作为 Runnable 任务对象和 Future 对象作为任务载体, 同时获取和控制线程状态.
val futureTask = FutureTask<String> {
    "Hello"
}
Thread(futureTask).start()
val result = futureTask.get()
```

### 不同任务线程间进行消息传递

在线程中通过 `Handler`、`MessageQueue` 和 `Looper` 实现在不同线程间传递消息和执行任务.

- `MessageQueue` 用于在线程内部存储待处理的消息 `Message` 和任务 `Runnable`. 一种基于单链表的数据结构实现的消息队列, 支持对内部 `Message` 的插入 `enqueueMessage`、取出 `next`、移除 `removeMessages` 等操作. 此外, `MessageQueue` 与 `Looper` 绑定, 当创建 `Looper` 时, 会自动创建一个 `MessageQueue` 对象, 并将其绑定到当前线程, 不需要手动创建.
- `Looper` 负责循环处理消息队列中的消息. 每个线程可以通过内部调用 `Looper.prepare()` 创建一个 `Looper` 对象, 并通过 `Looper.loop()` 方法启动消息处理循环, 注意只能创建一个 `Looper` 对象, 主线程默认已经创建了一个 `Looper` 对象. 启动消息处理循环后, `Looper` 会不断从消息队列中取出消息, 并将其分发给目标 `Handler` 处理, 直到消息队列为空. 未处理完成或手动退出消息处理循环前, 线程会一直处于阻塞状态.
- `Handler` 用于发送和处理消息 `Message` 和任务 `Runnable`. 每个线程可以有多个 `Handler` 对象, 但是每个 `Handler` 对象只能绑定到一个指定的 `Looper` 对象(默认为当前线程的 `Looper`). 通过 `Handler` 的 `sendMessage` 方法向绑定的 `Looper` 的消息队列中发送消息, 通过 `Handler` 的 `post` 方法向消息队列中发送任务. 支持消息的延迟发送.
- `Message` 用于封装消息内容, 包括 `arg1` 和 `arg2` 两个存储整数的参数、`obj` 存储接收者对象的引用、`what` 存储消息类型或用户定义的消息代码、`target` 存储消息接收者的 `Handler` 对象、`callback` 存储消息处理回调函数等.

```kotlin
import android.os.Handler
import android.os.Looper
import android.os.Message

fun main() {
    // 主线程的 Handler, 用于发送消息到后台线程
    val mainHandler = Handler(Looper.getMainLooper())

    val backgroundThread = BackgroundThread()
    backgroundThread.start()

    mainHandler.post {
        println("主线程发送消息到后台线程")
        val message = Message.obtain()
        message.what = 1
        message.obj = "Hello from the Main Thread!"
        backgroundThread.getHandler()?.sendMessage(message)
    }
}

class BackgroundThread : Thread() {
    private var backgroundHandler: Handler? = null

    override fun run() {
        Looper.prepare()
        backgroundHandler = MyHandler(Looper.myLooper()!!)
        Looper.loop()
    }

    fun getHandler(): Handler? {
        return backgroundHandler
    }
}

// 自定义后台线程的消息处理逻辑
class MyHandler(looper: Looper) : Handler(looper) {
    override fun handleMessage(msg: Message) {
        when (msg.what) {
            1 -> {
                println("后台线程处理消息: ${msg.obj}")
                val mainHandler = Handler(Looper.getMainLooper())
                mainHandler.post {
                    println("主线程收到消息: ${msg.obj}")
                }
            }
        }
    }
}


```


在线程中通过 `HandlerThread` 和 `Handler` 实现在不同线程间传递消息和执行任务.

- `HandlerThread` 是一个带有 `Looper` 的线程类, 用于在后台线程中执行任务和处理消息. `HandlerThread` 继承自 `Thread` 类, 通过 `Looper` 实现了消息循环处理机制, 可以通过 `getLooper()` 方法获取 `Looper` 对象, 通过 `quit()` 方法退出消息循环.
- `HandlerThread` 与 `Handler` 结合使用, 可以实现在后台线程中执行任务和处理消息, 通过 `HandlerThread` 的 `getLooper()` 方法获取 `Looper` 对象, 并通过 `Handler` 的构造方法传入 `Looper` 对象, 从而实现消息的发送和处理.

```kotlin
import android.os.Handler
import android.os.HandlerThread
import android.os.Looper
import android.os.Message

fun main() {
    // 主线程的 Handler, 用于发送消息到后台线程
    val mainHandler = Handler(Looper.getMainLooper())

    // 创建并启动 HandlerThread
    val backgroundThread = HandlerThread("BackgroundThread")
    backgroundThread.start()
    val backgroundHandler = Handler(backgroundThread.getLooper())

    // 
    mainHandler.post {
        println("主线程发送消息到后台线程")
        val message = Message.obtain()
        message.what = 1
        message.obj = "Hello from the Main Thread!"
        backgroundHandler.sendMessage(message)
    }
}

class MyHandler(looper: Looper) : Handler(looper) {
    override fun handleMessage(msg: Message) {
        when (msg.what) {
            1 -> {
                println("后台线程处理消息: ${msg.obj}")
                // 处理完任务后, 将结果发送回主线程
                val mainHandler = Handler(Looper.getMainLooper())
                mainHandler.post {
                    println("主线程收到消息: ${msg.obj}")
                }
            }
        }
    }
}
```