---
tags: 
title: 安卓开发
description: ""
author: ""
categories: ""
keywords:
  - ""
draft: true
layout: ""
date: 2024-07-31 10:44:21
lastmod: 2024-08-12 13:47:23
---

> [!todo]
> https://developer.android.com/courses/android-basics-compose/course
> https://developer.android.com/courses/unit/kotlin-basics-unit-1
> https://www.geeksforgeeks.org/kotlin-android-tutorial/
> https://developer.android.com/courses/
> 
> 

## Android 应用程序组成

### 清单文件 `AndroidManifest.xml`

安卓操作系统与安卓应用程序之间由清单文件 `AndroidManifest.xml` 进行连接, 该清单文件位于应用程序的根目录下, 用于告知系统应用程序的基本信息, 如应用程序的名称、图标、版本号、权限以及各种组件等. 


以下是一个简单的清单文件示例及其内容解析:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <!-- 应用程序信息 -->
    <application
        android:name=".MyApplication"
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.MyApplication3"
        tools:targetApi="31">

        <!-- 活动声明 -->
        <activity
            android:name=".MainActivity"
            android:launchMode="singleTop"
            android:taskAffinity=""
            android:allowTaskReparenting="true"
            android:exported="true"
            android:label="@string/title_activity_main">
        <intent-filter>
            <action android:name="android.intent.action.MAIN" />
            <category android:name="android.intent.category.LAUNCHER" />
        </intent-filter>
        </activity>

        <activity
            android:name=".SecondActivity"
            android:exported="true"
            android:label="@string/title_activity_second">
        <intent-filter>
            <action android:name="com.example.SECOND" />
            <category android:name="android.intent.category.DEFAULT" />
        </intent-filter>
        </activity>

        <!-- 服务声明 -->
        <service
            android:name=".MyService"
            android:exported="true">
            <intent-filter>
                <action android:name="com.example.MY_SERVICE" />
            </intent-filter>
        </service>

        <!-- 广播接收器声明 -->
        <receiver
            android:name=".MyReceiver"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.BOOT_COMPLETED" />
            </intent-filter>
        </receiver>

        <!-- 内容提供程序声明 -->
        <provider
            android:name=".MyProvider"
            android:authorities="com.example.myprovider"
            android:exported="true"
            android:grantUriPermissions="true">
            <grant-uri-permission android:pathPattern="/myprovider/*" />
            </provider>
    </application>

    <!-- 权限声明 -->
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission android:name="android.permission.CAMERA" />
    <uses-permission android:name="android.permission.RECORD_AUDIO" />
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />

    <!-- 使用特性 -->
    <uses-feature android:name="android.hardware.camera" />
    <uses-feature android:name="android.hardware.microphone" />
    <uses-feature android:name="android.hardware.location.gps" />

</manifest>
```

**顶部声明**
- `<?xml version="1.0" encoding="utf-8"?>`：声明 XML 文件的版本和编码方式。
- `<manifest>`：根元素，包含应用的所有配置。
    - `xmlns:android="http://schemas.android.com/apk/res/android"`：定义 `android` 命名空间，用于引用安卓系统提供的属性。
    - `xmlns:tools="http://schemas.android.com/tools"`：定义 `tools` 命名空间，用于引用开发工具（如 Android Studio）提供的一些自定义属性。
**`<application>` 元素**

包含应用级别的配置信息，定义应用的全局属性和组件。
- `android:name=".MyApplication"`: 指定应用的自定义 `Application` 类。
- `android:allowBackup="true"`: 允许用户备份和恢复应用的数据。
- `android:dataExtractionRules="@xml/data_extraction_rules"`: 指定数据提取规则，通常用于自动备份功能。
- `android:fullBackupContent="@xml/backup_rules"`: 指定完整备份内容的规则。
- `android:icon="@mipmap/ic_launcher"`: 指向用于标识应用的图标的资源
- `android:label="@string/app_name"`: 指定应用的显示名称。
- `android:roundIcon="@mipmap/ic_launcher_round"`: 指定圆形应用图标（通常用于圆形图标需求的设备）。
- `android:supportsRtl="true"`: 指定应用是否支持从右到左（RTL）的布局方向。
- `android:theme="@style/Theme.MyApplication3"`: 指定应用的主题。
- `tools:targetApi="31"`: 指定目标 API 级别，主要用于开发工具进行静态代码检查，不影响实际运行时的行为。

**`<activity>` 元素**

定义一个活动（Activity），是应用的一个主要组件，代表一个用户界面。
- `android:name=".MainActivity"`: 指定活动的类名，`.MainActivity` 表示该活动在应用包名下。
- `android:launchMode="singleTop"`: 指定活动的启动模式。这里是 `singleTop`，表示如果活动已经在栈顶，不会重新创建新的实例。
- `android:taskAffinity=""`: 指定活动的任务亲和性。
- `android:allowTaskReparenting="true"`: 指定活动是否允许移动到其他任务中。
- `android:exported="true"`: 指定活动是否可以由应用之外的组件启动。`true` 表示可以被其他应用访问。
- `android:label="@string/title_activity_main"`: 指定活动的显示名称。
- `<intent-filter>`: 定义了活动能够响应的意图（Intent），通常用于配置应用的启动活动和处理特定的动作。
    - `<action>`: 定义意图的动作。
        - `android:name="android.intent.action.MAIN"`: 表示该活动是应用的主入口点。
        - `android:name="com.example.SECOND"`: 自定义的动作名称。
    - `<category>`: 定义意图的类别。
        - `android:name="android.intent.category.LAUNCHER"`: 表示该活动会出现在应用启动器中，作为应用的启动活动。
        - `android:name="android.intent.category.DEFAULT"`: 默认的意图类别。

**`<service>` 元素**

定义一个服务（Service），是一个后台运行的组件，用于执行长时间运行的操作。
- `android:name=".MyService"`: 指定服务的类名。
- `android:exported="true"`: 指定服务是否可以被其他应用访问。
- `<intent-filter>`: 定义了服务能够响应的意图。
    - `<action>`: 定义意图的动作。
        - `android:name="com.example.MY_SERVICE"`: 自定义的动作名称。

**`<receiver>` 元素**

定义一个广播接收器（Broadcast Receiver），用于接收系统广播事件。
- `android:name=".MyReceiver"`: 指定广播接收器的类名。
- `android:exported="true"`: 指定广播接收器是否可以被其他应用访问。
- `<intent-filter>`: 定义了广播接收器能够响应的意图。
    - `<action>`: 定义意图的动作。
        - `android:name="android.intent.action.BOOT_COMPLETED"`: 表示系统启动完成后发送的广播。

**`<provider>` 元素**

定义一个内容提供程序（Content Provider），用于管理应用程序的数据集。
- `android:name=".MyProvider"`: 指定内容提供程序的类名。
- `android:authorities="com.example.myprovider"`: 指定内容提供程序的权限。
- `android:exported="true"`: 指定内容提供程序是否可以被其他应用访问。
- `android:grantUriPermissions="true"`: 指定内容提供程序是否授予 URI 权限。
- `<grant-uri-permission>`: 定义了内容提供程序授予的 URI 权限。
    - `android:pathPattern="/myprovider/*"`: 匹配 URI 的路径模式。

**`<uses-permission>` 元素**

定义应用程序需要的权限。
- `android:name="android.permission.INTERNET"`: 访问互联网的权限。
- `android:name="android.permission.ACCESS_NETWORK_STATE"`: 访问网络状态的权限。
- `android:name="android.permission.CAMERA"`: 使用摄像头的权限。
- `android:name="android.permission.RECORD_AUDIO"`: 录制音频的权限。
- `android:name="android.permission.ACCESS_FINE_LOCATION"`: 访问精确位置的权限。

**`<uses-feature>` 元素**

定义应用程序需要的硬件功能。
- `android:name="android.hardware.camera"`: 摄像头硬件功能。
- `android:name="android.hardware.microphone"`: 麦克风硬件功能。
- `android:name="android.hardware.location.gps"`: GPS 定位硬件功能。

### 应用程序基础: Application

应用程序的基础是 `Application` 类, 一个单例类, 每个应用程序都有一个 `Application` 实例, 它是整个应用程序的入口点，负责应用程序的初始化和全局状态的管理, 可以通过 `getApplication()` 方法获取。
- 在应用程序启动时初始化一些全局的资源或配置，例如第三方库（如分析工具、数据库库等）。
- 在应用程序的生命周期中管理全局状态，例如用户登录状态、网络连接状态等。
- 监控整个应用程序的生命周期，处理一些全局的状态变化。
    - `onCreate()`: 应用程序创建时调用。
    - `onTerminate()`: 应用程序终止时调用。

```kotlin
class MyApplication : Application() {
    override fun onCreate() {
        super.onCreate()
        // 初始化Firebase
        FirebaseApp.initializeApp(this)
        // 初始化Crashlytics
        Fabric.with(this, Crashlytics())
        // 初始化数据库
        Realm.init(this)
        // 初始化全局数据
        someGlobalData = "This is some global data"
    }
}
```

### 应用程序四大组件: 活动、服务、广播接收器、内容提供程序

Android 应用程序由四个主要组件组成:
- 活动 (Activity): 用户与应用程序进行交互的主要入口点, 通常表示一个具有用户界面的屏幕
- 服务 (Service): 在后台执行长时间运行的操作或远程处理
- 广播接收器 (Broadcast Receiver): 在系统广播事件发生时接收系统广播
- 内容提供程序 (Content Provider): 管理应用程序的数据集

活动可以启动服务来执行后台任务; 注册广播接收器来接收系统或应用的广播以更新 UI; 使用内容提供程序来访问和管理数据; 启动其他活动，并传递数据。

广播接收器被动接收系统或应用的广播事件, 然后可以启动服务来执行后台任务, 也可以通过内容提供程序来访问和管理数据。

服务通常是由活动或广播接收器启动, 可以通过内容提供程序来访问和管理数据。

内容提供程序为程序提供标准的数据管理接口, 包括查询、插入、更新和删除。

此外还有些附加组件:
- 片段 (Fragment): 可重用的 UI 组件
- 意图 (Intent): 用于在组件之间传递消息
- 视图 (View): 用户界面的构建块
- 布局 (Layout): 定义视图的结构和外观
- 资源 (Resource): 应用程序的非代码资源，如图像、字符串和布局文件

#### 活动 (Activity)

活动是 Android 应用程序的一个主要组件，用于表示用户界面的一个屏幕, 通常包含用户界面元素，如按钮、文本框和图像，用于与用户进行交互。每个活动都是一个类，继承自 `Activity` 类或其子类。Android 系统初始化其应用程序是通过活动中的 `onCreate()` 开始的。

每个应用程序可以包含多个活动，所有活动必须在清单文件 `AndroidManifest.xml` 中进行声明。

每个活动都有一个生命周期，包括以下主要状态:
- `onCreate()`: 活动创建时调用
- `onStart()`: 活动开始时调用
- `onResume()`: 活动恢复时调用
- `onPause()`: 活动暂停时调用
- `onStop()`: 活动停止时调用
- `onDestroy()`: 活动销毁时调用
- `onRestart()`: 活动重新启动时调用

活动之间可以通过意图 (Intent) 进行通信，意图可以用于启动活动、启动服务、发送广播等。

#### 服务 (Service)

服务是可以在后台执行长时间运行操作或远程处理(下载文件、播放音乐、更新数据等)的组件，不提供用户界面, 即使应用程序处于后台或被销毁，服务仍然可以继续运行。每个服务都是一个类，继承自 `Service` 类或其子类。服务必须在清单文件 `AndroidManifest.xml` 中进行声明。

服务可以通过活动的 `startService()` 或 `bindService()` 方法启动，通过 `stopService()` 或 `unbindService()` 方法停止。区别在于 `startService()` 启动的服务会一直运行，直到调用 `stopService()` 停止，而 `bindService()` 是在其他 app 或系统组件中绑定服务，绑定后服务会一直运行直到所有绑定的组件都解绑。

每个服务也有一个生命周期，包括以下主要状态:
- `onStartCommand()`: 服务启动时调用
- `onCreate()`: 服务创建时调用
- `onBind()`: 服务绑定时调用
- `onUnbind()`: 服务解绑时调用
- `onRebind()`: 服务重新绑定时调用
- `onDestroy()`: 服务销毁时调用

#### 广播接收器 (Broadcast Receiver)

广播接收器是用于接收系统或应用的广播事件的组件，当特定事件发生时，广播接收器会接收并处理广播消息。每个广播接收器都是一个类，继承自 `BroadcastReceiver` 类或其子类。广播接收器必须在清单文件 `AndroidManifest.xml` 中进行声明。

广播接收器可以通过 `registerReceiver()` 方法注册，通过 `unregisterReceiver()` 方法注销。也可以通过清单文件声明静态注册，这样即使应用程序未运行，也可以接收广播。

广播接收器可以接收系统广播事件, 常见的系统广播事件包括:
- `android.intent.action.BOOT_COMPLETED`: 系统启动完成时发送的广播
- `android.intent.action.SCREEN_ON`: 屏幕开启时发送的广播
- `android.intent.action.SCREEN_OFF`: 屏幕关闭时发送的广播
- `android.intent.action.ACTION_POWER_CONNECTED`: 充电器连接时发送的广播
- `android.intent.action.ACTION_POWER_DISCONNECTED`: 充电器断开时发送的广播
- `android.intent.action.BATTERY_LOW`: 电池电量低时发送的广播
- `android.intent.action.BATTERY_OKAY`: 电池电量恢复正常时发送的广播

广播接收器也可以通过活动的`sendBroadcast()` 方法发送自定义的广播事件。

#### 内容提供程序 (Content Provider)

内容提供程序是用于管理应用程序的数据集的组件，提供包括查询、插入、更新和删除等数据接口，支持跨应用程序访问数据。存储方式包括数据库, 文件, 网络等.

每个内容提供程序都是一个类，继承自 `ContentProvider` 类或其子类。内容提供程序必须在清单文件 `AndroidManifest.xml` 中进行声明。

内容提供程序可以通过查询, 插入, 更新和删除方法来操作数据。想访问内容提供程序可以通过预定义的 URI (Uniform Resource Identifier) 来标识和访问数据集，URI 由以下部分组成:`<prefix>://<authority>/<data_type>/<id>`

`ContentProvider` 类中的方法:
- `query()`: 查询数据
- `insert()`: 插入数据
- `update()`: 更新数据
- `delete()`: 删除数据
- `getType()`: 获取数据类型
- `onCreate()`: 当提供者被启动时调用

#### 意图 (Intent)

意图是一种异步消息传递机制，


意图是用于在组件之间异步传递消息的对象，用于在将组件绑定, 同时在组件之间传递消息，如启动活动、启动服务、发送广播等。
- 显式意图 (Explicit Intent): 指定要启动的组件的类名
- 隐式意图 (Implicit Intent): 指定要执行的操作，由系统根据意图的动作和数据类型选择合适的组件

## UI

应用的界面 (UI) 就是您在屏幕上所看到的内容（文本、图片、按钮和许多其他类型的元素）及其在屏幕上的布局方式。

Jetpack Compose 可以使用在项目的 Android 自动生成的 `R` 类中通过资源 ID 访问 Android 项目中定义的资源。
- `painterResource()` 函数会加载可绘制图片资源，并将资源 ID（在本例中为 `R.drawable.androidparty` ）作为实参。
- `stringResource()` 



`onCreate()` 函数中的 [`setContent()`](https://developer.android.com/reference/kotlin/androidx/compose/ui/platform/ComposeView?hl=zh-cn#setContent(kotlin.Function0)) 函数用于通过可组合函数定义布局。


可组合函数 Jetpack Compose 是用于构建 Android 界面的新款工具包。任何标有 `@Composable` 注解的函数都可通过 `setContent()` 函数或其他可组合函数进行调用。该注解可告知 Kotlin 编译器 Jetpack Compose 使用的这个函数会生成 UI。

注解

```kotlin
@Composable
@Preview
```

修饰符 [`Modifier`](https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier?hl=zh-cn) 用于扩充或修饰可组合项, 如修饰组件的布局。
- 内边距修饰符 (`Modifier.padding`) 在 `Text` 可组合项的周围添加空间。
```
Modifier.padding(
    start = 16.dp,
    top = 16.dp,
    end = 16.dp,
    bottom = 16.dp
)

Modifier
    .padding(16.dp)
    .align(alignment = Alignment.End)
```
- 背景颜色修饰符 `Modifier.background` 


![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-add-images/img/df69881d07b064d0.gif?hl=zh-cn)



基本标准布局元素是 `Column`、`Row,` 和 `Box`。
- [`Box`](https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/package-summary?hl=zh-cn#Box(androidx.compose.ui.Modifier,androidx.compose.ui.Alignment,kotlin.Boolean,kotlin.Function1)) 布局是 Compose 中的标准布局元素之一。使用 `Box` 布局可将元素堆叠在一起。`Box` 布局还可用于配置它所包含的元素的特定对齐方式。

应用在某些情况下可能会被翻译成其他语言, 一些固定的 `String` 数据类型可以提取到资源文件中进行管理, 避免硬编码导致无法进行翻译.

@JvmOverloads constructor 用于自动在 java 中生成各种重载的构造函数


[ConstraintLayout之ConstraintSet - enzo的博客](https://enzowyf.github.io/constraintset.html)

// 设置控件尺寸  
// constrainWidth/constrainHeight  
// constrainDefaultWidth/constrainDefaultHeight  
// constrainMaxWidth/constrainMaxHeight  
// constrainMinWidth/constrainMinHeight
  
// 设置控件间直接约束关系  
  
// 控件 start 的某边与 end 的某边对齐, margin 用于设置边与边中间间距  
// connect(int startID, int startSide, int endID, int endSide, int margin)  
// connect(int startID, int startSide, int endID, int endSide)  
  
// 控件 center 置于另两个控件 first 和 second 之间, bias(0~1) 用于设置位置偏移比例  
// center(int centerID, int firstID, int firstSide, int firstMargin, int secondID, int secondSide, int secondMargin, float bias)  
// 控件 center 水平居中于另一个控件 centerID, leftId/rightId 用于设置左右边界控件  
// centerHorizontally(int centerID, int leftId, int leftSide, int leftMargin, int rightId, int rightSide, int rightMargin, float bias)  
  
// 方向: ConstraintSet.TOP/BOTTOM/START/END/LEFT/RIGHT/BASELINE(TextView)  
  
// 控件 viewId 与 toView 水平居中  
// centerHorizontally(int viewId, int toView)  
// 控件 viewId 与 toView 垂直居中  
// centerVertically(int viewId, int toView)  
  
// 修改控件属性  
// setVisibility/setAlpha/setRotation  
// setRotationX/setRotationY  
// setScaleX/setScaleY/setTransformPivot/setTransformPivotX/setTransformPivotY  
// setTranslation/setTranslationX/setTranslationY/setTranslationZ  
// setElevation




RecyclerView ( `RecyclerView` 和 `RecyclerView.LayoutManager` )
- 数据驱动：需要一个数据源来提供要显示的数据, 见 `RecyclerView.Adapter` 和 `RecyclerView.ViewHolder`
- 可重用性：支持视图的重用机制，通过重用池来减少内存开销, 见 `onCreateViewHolder` 和 `onBindViewHolder`
- 布局管理：支持多种布局，通过不同的布局管理器来控制视图的显示方式（如网格、列表等）, 见 `LinearLayoutManager` 、 `GridLayoutManager` 、 `StaggeredGridLayoutManager`
- 自定义单元格：允许自定义单元格，以便显示复杂的内容。创建自定义的 `ViewHolder` 子类, 然后在 `Adapter` 中使用这个 `ViewHolder`, 在 `onCreateViewHolder` 和 `onBindViewHolder` 方法中绑定 `ViewHolder`.

### 基础组件

- AbsListView  
- AbsListView.LayoutParams  
- AbsoluteLayout  
- AbsoluteLayout.LayoutParams  
- AbsSeekBar  
- AbsSpinner  
- ActionMenuView  
    - ActionMenuView.LayoutParams  
- AdapterView  
- AdapterView.AdapterContextMenuInfo  
- AdapterViewAnimator  
- AdapterViewFlipper  
- AlphabetIndexer  
- AnalogClock  
- ArrayAdapter  
- AutoCompleteTextView  
- BaseAdapter  
- BaseExpandableListAdapter  
- Button  
- CalendarView  
- CheckBox  
- CheckedTextView  
- Chronometer  
- CompoundButton  
- CursorAdapter  
- CursorTreeAdapter  
- DatePicker  
- DialerFilter  
- DigitalClock  
- EdgeEffect  
- EditText  
- ExpandableListView  
    - ExpandableListView.ExpandableListContextMenuInfo  
- Filter  
    - Filter.FilterResults  
- FrameLayout  
    - FrameLayout.LayoutParams  
- Gallery  
    - Gallery.LayoutParams  
- GridLayout  
    - GridLayout.Alignment  
    - GridLayout.LayoutParams  
    - GridLayout.Spec  
- GridView  
- HeaderViewListAdapter  
- HorizontalScrollView  
- ImageButton  
- ImageSwitcher  
- ImageView  
- LinearLayout  
    - LinearLayout.LayoutParams  
- ListPopupWindow  
- ListView  
    - ListView.FixedViewInfo  
- Magnifier  
    - Magnifier.Builder  
- MediaController  
- MultiAutoCompleteTextView  
    - MultiAutoCompleteTextView.CommaTokenizer  
- NumberPicker  
- OverScroller  
- PopupMenu  
- PopupWindow  
- ProgressBar  
- QuickContactBadge  
- RadioButton  
- RadioGroup  
    - RadioGroup.LayoutParams  
- RatingBar  
- RelativeLayout  
    - RelativeLayout.LayoutParams  
- RemoteViews  
    - RemoteViews.DrawInstructions  
    - RemoteViews.DrawInstructions.Builder  
    - RemoteViews.RemoteCollectionItems  
    - RemoteViews.RemoteCollectionItems.Builder  
    - RemoteViews.RemoteResponse  
    - RemoteViews.RemoteViewOutlineProvider  
- RemoteViewsService  
- ResourceCursorAdapter  
- ResourceCursorTreeAdapter  
- Scroller  
- ScrollView  
- SearchView  
- SeekBar  
- ShareActionProvider  
- SimpleAdapter  
- SimpleCursorAdapter  
- SimpleCursorTreeAdapter  
- SimpleExpandableListAdapter  
- SlidingDrawer  
- Space  
- Spinner  
- StackView  
- Switch  
- TabHost  
    - TabHost.TabSpec  
- TableLayout  
    - TableLayout.LayoutParams  
- TableRow  
    - TableRow.LayoutParams  
- TabWidget  
- TextClock  
- TextSwitcher  
- TextView  
    - TextView.SavedState  
- TimePicker  
- Toast  
    - Toast.Callback  
- ToggleButton  
- Toolbar  
    - Toolbar.LayoutParams  
- TwoLineListItem  
- VideoView  
- ViewAnimator  
- ViewFlipper  
- ViewSwitcher  
- ZoomButton  
- ZoomButtonsController  
- ZoomControls

- InlineContentView
- InlinePresentationSpec
    - InlinePresentationSpec.Builder

### androidx 扩展组件

- ActionBar
    - ActionBar.LayoutParams
    - ActionBar.Tab
- ActionBarDrawerToggle
- AlertDialog
    - AlertDialog.Builder
- AppCompatActivity
- AppCompatDelegate
- AppCompatDialog
- AppCompatDialogFragment
- AppCompatViewInflater
- AppLocalesMetadataHolderService

- ActionMenuView
    - ActionMenuView.LayoutParams
- AppCompatAutoCompleteTextView
- AppCompatButton
- AppCompatCheckBox
- AppCompatCheckedTextView
- AppCompatEditText
- AppCompatImageButton
- AppCompatImageView
- AppCompatMultiAutoCompleteTextView
- AppCompatRadioButton
- AppCompatRatingBar
- AppCompatSeekBar
- AppCompatSpinner
- AppCompatTextView
- AppCompatToggleButton
- LinearLayoutCompat
    - LinearLayoutCompat.LayoutParams
- ListPopupWindow
- PopupMenu
- SearchView
- ShareActionProvider
- SwitchCompat
- ThemedSpinnerAdapter.Helper
- Toolbar
    - Toolbar.LayoutParams
    - Toolbar.SavedState
- TooltipCompat

### androidx 碎片组件(Fragment)

 `Fragment`是 `Activity` 中使用的一种可重用 UI 组件，可以在 `Activity` 中被添加、替换、移除，也可以在 `Fragment` 中嵌套其他 `Fragment`, 有自己的生命周期，可以与 `Activity` 共享生命周期。
 - `Fragment` 生命周期回调方法: `onCreate()` , `onCreateView()` , `onViewCreated()` , `onViewStateRestored()` , `onStart()` , `onResume()` , `onPause()` , `onStop()` , `onSaveInstanceState()` , `onDestroyView()` , `onDestroy()` 
 - `Fragment` 生命周期状态: `CREATED`, `STARTED`, `RESUMED`, `DESTROYED`. 可以由 `getLifecycle().getCurrentState()` 获取当前状态
 - `Fragment` 视图状态: `INITIALIZED` , `CREATED` , `STARTED` , `RESUMED` , `DESTROYED`. 可以由 `getViewLifecycleOwner().getLifecycle().getCurrentState()` 获取当前状态

实际开发中, `Fragment` 需要一个托管它的视图容器, 通常是一个 `FrameLayout` 等布局容器. 新的 API 提供了 `FragmentContainerView` 来代替 `FrameLayout`, 支持更好的视觉效果设置, 和额外的编辑器功能.

可以根据不同的场景获取不同的 `FragmentManager` 管理实例, 来管理场景内 `Fragment` 的添加、替换、移除等操作。`FragmentManager` 通过事务(`FragmentTransaction`) 和回退栈(`BackStack`) 来管理 `Fragment` 的状态和生命周期。

回退栈是一个后进先出的栈，用于存储 `Fragment` 的状. 在应用的任意时刻，只能有一个 `FragmentManager` 可以控制 `Fragment` 的回退栈, 所以在多 `Fragment` 的情况下，需要使用 `setPrimaryNavigationFragment()` 方法在不同的导航片段之间切换主要导航控制权, 以便正确管理回退栈. 吃外如果需要支持多个回退栈，可以使用 `saveBackStack()` 和 `restoreBackStack()` 方法来保存和恢复回退栈, 比如在导航栏切换时.

事务是一组针对`Fragment`的操作集合, 通过 `beginTransaction()` 或 kotlin 扩展方法 `commit` 来创建和提交事务，可以包括任意数量的操作. 事务执行时可以通过 `addToBackStack()` 方法在回退栈中保存事务，这样可以通过 `popBackStack()` 方法来回退到上一个状态. 没添加到回退栈的事务会被立即执行，但不会保存状态, 比如删除任务会立即删除和销毁, 无法回撤.

如果设备发生了配置变化（如屏幕旋转）, Activity 及其所有 Fragment 都会被销毁并重新创建, 此时需要注意 `Fragment` 的实例初始化问题.

- Fragment
    - DialogFragment
    - PreferenceFragmentCompat
    - ListFragment

```kotlin
class MyFragment : Fragment() {
    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        return inflater.inflate(R.layout.fragment_my, container, false)
    }
}

class MyActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        if (savedInstanceState == null) {
            supportFragmentManager.beginTransaction()
                .add(R.id.fragment_container, MyFragment())
                .commit()
            // 或者
            supportFragmentManager.commit {
                add<MyFragment>(R.id.fragment_container)
            }
        }
    }
}
```

- FragmentContainer: 一个抽象类, 用于管理 Fragment 的容器, 通常是一个 ViewGroup
- FragmentContainerView: 一个 ViewGroup, 用于管理 Fragment 的容器

- FragmentManager: 
    - 在 Activity 中通过 `getSupportFragmentManager()` 获取管理实例
    - 在 Fragment 中通过 `getChildFragmentManager()` 获取管理实例
    - 在 Child Fragment 中通过 `getParentFragmentManager()` 获取管理实例
    - 通过 `beginTransaction()` 创建事务, 类型为 `FragmentTransaction`
    - 通过 `commit()` 提交事务
    - 通过 `popBackStack()` 弹出回退栈
    - 通过 `addToBackStack()` 添加到回退栈
    - 通过 `add`, `replace`, `remove`, `hide`, `show` 等方法操作 Fragment
    - 通过 `findFragmentById()` 和 `findFragmentByTag()` 查找 Fragment
    - 通过 `getFragments()` 获取当前所有 Fragment
    - 通过 `setReorderingAllowed()` 设置是否允许事务操作的重新排序
    - 通过 `setCustomAnimations` 设置自定义动画, 应用于调用位置后续的所有 `Fragment` 操作
        - `setCustomAnimations(enter: Int, exit: Int, popEnter: Int, popExit: Int)`
- Fragment.SavedState
- FragmentActivity
- FragmentController
- FragmentFactory: 用于创建 Fragment 实例的工厂, 可以通过自定义工厂来控制 Fragment 的实例创建过程. 默认情况下, Fragment 会通过反射机制创建实例, 通过 `FragmentFactory` 可以自定义创建逻辑.
- FragmentHostCallback
- FragmentKt
- FragmentManager.FragmentLifecycleCallbacks
- FragmentManagerKt
- FragmentManagerNonConfig
- FragmentPagerAdapter
- FragmentStatePagerAdapter
- FragmentTabHost
- FragmentTransaction
- FragmentTransactionKt
- FragmentViewModelLazyKt
- ViewKt


```kotlin
class MainActivity : AppCompatActivity() {
    // 创建 Fragment 实例
    val fragment = MyFragment()
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        if (savedInstanceState == null) {

            supportFragmentManager.commit {
                setReorderingAllowed(true)
                add<MyFragment>(R.id.fragment_container_view)
            }
        }
    }
}
```

### androidx 导航组件(Navigation)

`NavHostFragment` 是一个特殊的 Fragment，用于承载导航图中的目的地，通常作为 Activity 布局的一部分，用于显示不同的目的地。
`NavController` 是一个用于管理导航图和页面之间的导航的类，可以通过 `NavHostFragment` 来获取 `NavController` 实例。
`NavGraph` 是一个用于定义导航图的类，包含多个目的地和动作，可以通过 XML 或代码来定义。
`NavDestination` 是一个用于定义导航目的地的类，包含页面的 ID 和参数，可以通过 XML 或代码来定义。
目的地类型有三种: `Hosted` , `Dialog` , `Activity`
- `Hosted` 会使得目的内容占满整个导航内容区域
- `Dialog` 会使得目的内容展示在之前的内容上方
- `Activity` 会退出导航图所在的 Activity, 启动一个与导航组件分开管理的新 Android 活动




  

### 动画和过渡

> [!cite]
> https://developer.android.com/guide/fragments/animate

## 网络库(HttpURLConnection, OkHttp, Retrofit, 内部库)

网络请求库 = 网络请求 + 数据解析 + 线程切换(异步) + 异常处理

### HttpURLConnection

> [!TODO]

### OkHttp

> [!cite]
> [【OkHttp】OkHttp Get 和 Post 请求 ( 同步 Get 请求 | 异步 Get 请求 | 同步 Post 请求 | 异步 Post 请求 )-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/2249988)
> [网络请求框架OkHttp3全解系列（一）：OkHttp的基本使用-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/1667338)
> [由浅入深，聊聊OkHttp的那些事(易懂，不繁琐) - 掘金](https://juejin.cn/post/7199431845367922745?searchId=20240806152219108948FAF7C05048547D)
> [ \[Android\] 主流网络请求框架 OkHttp 全方位详析 - 掘金](https://juejin.cn/post/7345756317557817354?searchId=20240806152219108948FAF7C05048547D)
> [从OKHttp框架看代码设计](https://juejin.cn/post/6844903449469943821?searchId=2024080615223180876F5097A608E5EACE)
> [HTTP客户端连接，选择HttpClient还是OkHttp？](https://juejin.cn/post/6844904040644476941?searchId=2024080615223180876F5097A608E5EACE)
> [OkHttp的完整指南](https://juejin.cn/post/7068162792154464264?searchId=2024080615223180876F5097A608E5EACE)
> [雨露均沾的OkHttp—WebSocket长连接（使用篇） - 掘金](https://juejin.cn/post/6847009772198166536?searchId=2024080615223180876F5097A608E5EACE)
> [官方推荐使用的OkHttp4网络请求库全面解析！](https://juejin.cn/post/7212536164057776184?searchId=2024080615223180876F5097A608E5EACE)
> [OkHttp 拦截器的一些骚操作 - 掘金](https://juejin.cn/post/6844903606718562317?searchId=2024080615223180876F5097A608E5EACE)
> [一篇文章带你走通 OkHttp+Retrofit+Rxjava - 掘金](https://juejin.cn/post/6844903464082866190?searchId=2024080615223180876F5097A608E5EACE)
> [使用 Retrofit 2.0 + OkHttp 3.0 实现缓存处理 - 掘金](https://juejin.cn/post/6844903444285751309?searchId=2024080615223180876F5097A608E5EACE)
> [OKHttp源码解析(一)--初阶-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/1199021)

- 简洁易用的 API：通过构建 Request 对象和使用 Call 对象来发起同步或异步的网络请求。
- 支持现代的 HTTP 协议，包括 HTTP/2 和 SPDY
- 连接池和缓存：OkHttp 内置了连接池和响应缓存，可以有效地管理和复用网络连接，并提供可配置的缓存机制，减少重复的网络请求。
- 自动重试 ：在请求失败时自动重试请求，从而提高请求可靠性。
- 拦截器：提供拦截器机制，允许在发送请求和接收响应的过程中进行自定义处理，例如添加公共参数、日志记录等。
- 支持gzip压缩 ：支持接受和解压 GZIP 压缩的响应数据，减小网络传输的数据量，提升网络性能。

#### 使用

![](安卓开发.assets/file-20240806154800379.png)

```kotlin
val client = OkHttpClient.Builder() // 1. 创建 OkHttpClient 实例
    .connectTimeout(5000L, java.util.concurrent.TimeUnit.MILLISECONDS)
    .readTimeout(5000L, java.util.concurrent.TimeUnit.MILLISECONDS)
    .writeTimeout(5000L, java.util.concurrent.TimeUnit.MILLISECONDS)
    .retryOnConnectionFailure(true)
    .followRedirects(true)
    .followSslRedirects(true)
    .cache(null) // 设置缓存
    .authenticator(null) // 设置身份验证器
    .certificatePinner(null) // 设置证书锁定器
    .connectionPool(null) // 设置连接池
    .connectionSpecs(listOf()) // 设置连接规范
    .cookieJar(null) // 设置 Cookie 管理器
    .dispatcher(null) // 设置分发器
    .dns(null) // 设置 DNS 解析器
    .eventListenerFactory(null) // 设置事件监听器工厂
    .proxy(null) // 设置代理
    .protocols(listOf()) // 设置支持的协议
    .proxyAuthenticator(null) // 设置代理身份验证器
    .proxySelector(null) // 设置代理选择器
    .socketFactory(null) // 设置 Socket 工厂
    .hostnameVerifier(null) // 设置主机名验证器
    .build()

val getRequest = Request.Builder() // 2. 创建 Request 对象
    .url("https://reqres.in/api/users?page=2")
    .header("name", "value")
    .addHeader("name", "value")
    .cacheControl(null) // 设置缓存控制
    .build()

// 3. 同步请求
val response1 = client.newCall(getRequest).execute().use { response ->
    response.body?.string() ?: ""
}

// 3. 异步请求, 如果当前 request 已执行, 抛出错误
val response2 = client.newCall(get).enqueue(object : Callback {
    override fun onFailure(call: Call?, e: IOException) {
        //
    }

    override fun onResponse(call: Call?, response: Response) {
        val content = response.body?.string() ?: ""
    }
})
```

#### 原理

> [!cite]
> [由浅入深，聊聊OkHttp的那些事(易懂，不繁琐) - 掘金](https://juejin.cn/post/7199431845367922745?searchId=20240806152219108948FAF7C05048547D)
> [面试官：听说你熟悉OkHttp原理？ - 掘金](https://juejin.cn/post/6844904087788453896?searchId=20240806152219108948FAF7C05048547D)

![](安卓开发.assets/file-20240806152547281.png)

> [!TODO]

### Retrofit

> [!TODO]

### 内部库
