[Back in 2017, I wrote about the concept of â€œState Containersâ€](https://medium.com/jobandtalenteng/ios-architecture-an-state-container-based-approach-4f1a9b00b82e). Six years later, I still like to build most of my apps around them, using the very same concept for the two main layers inside my apps:

- **The view layer**: a view model is a â€œview state containerâ€ modeling view-specific state and business logic.
- **The domain layer**: usually aggregate root models (or data repositories/services), representing the business rules and keeping the integrity and consistency around a specific bounded context (or entity) in the application.

A lot has changed since 2017, though. In 2019, Apple introduced SwiftUI. Two years later, async/await came along. While we always like to think of good architectures as those not coupled to the specifics of the framework, good architectures are also good citizens of those same frameworks and the general ecosystem. Soâ€¦Â **How have SwiftUI and async/await changed the concept of state containers in these last six years?**Â Letâ€™s see.

# The Case Against MVVM in SwiftUI

But first, let's talk about some recent conversations in the iOS community regarding MVVM and whether it is a good fit for SwiftUI.Â **The premise is that â€œthe View is the view modelâ€ already, so MVVM is unnecessary.**

I disagree with that premise. While itâ€™s true that SwiftUI already has built-in primitives (in the form of property wrappers) to simplify a lot of the glue code around state observation and re-rendering,Â **the view is just a declarative description of how the view layer looks like**. A view model is so much more than that. Itâ€™s the place where the view-related business logic lives.

But letâ€™s start with the right question. Why would we want to move code out of the view layer? Without entering in (sometimes subjective) debates about responsibilities and how software should be split, thereâ€™s something clear:Â **unless we move the code out of the view layer, it will be complicated to unit test**. But where should we put that code?

My answer to this, as most times, is â€œit dependsâ€. Sometimes, we can have that logic inside a domain state container observed from different views that need the same information. Sometimes, itâ€™s just view-specific business logic. In that case, I like to put that logic inside a view model (a view state container). Other times, itâ€™s a matter of processing different information from different data sources and validating it to produce a view state. In all these scenarios, a view model makes a lot of sense. It makes sense because it bundles essential business logic, which is only important for that view. Moving this view-specific business logic to a domain model will likely make it less cohesive and, eventually,Â [the wrong abstraction](https://sandimetz.com/blog/2016/1/20/the-wrong-abstraction).

Ultimately,Â **itâ€™s just a matter of moving business logic out of the view in a place where it makes sense, guided by cohesion and coupling principles**Â (or SOLID principles in general), so it can be easily testable.

Finally, I wonder why the best iOS course in the world,Â [Standfordâ€™s CS193P](https://cs193p.sites.stanford.edu/), stillÂ [teaches MVVM as the main presentation pattern for SwiftUI apps](https://www.youtube.com/watch?v=--qKOhdgJAs).

Also, Apple seems to feel the same way about not using View as the view model ğŸ¤”.

![](https://miro.medium.com/v2/resize:fit:1050/1*NhdY5C-g91lq4Mx6cj_tyA.png)

Now, get back to state containers.

# The Shape of a State Container

I like to think of state containers (also "Stores" from now on) as just â€œblack boxesâ€ with some inputs and outputs. Specifically, a black box with some observable state that can also emit outputs.

@MainActor  
protocol StoreType<State, Output>: ObservableObject where State: Equatable {  
    associatedtype State  
    associatedtype Output  
    associatedtype StateStream: AsyncSequence where StateStream.Element == State  
    associatedtype OutputStream: AsyncSequence where OutputStream.Element == Output  
  
    var stateStream: StateStream { get }  
    var outputStream: OutputStream { get }  
  
    var state: State { get set }  
}

Some important decisions in that code are worth mentioning.

- I have decided to useÂ `ObservableObject`Â andÂ `@MainActor`, so we can be sure that it can be used correctly from a SwiftUI view layer,Â **regardless of the specific type of state: view state or domain state**. We should allow enough flexibility to decide whether a view or domain layer makes sense.
- While Combineâ€™s future is still unclear, I feel itâ€™s safer and more future-proof to provide an API based onÂ `AsyncSequence`Â and not couple the store with Combine in this case.

One interesting nitpick detail about choosingÂ `AsyncSequence`Â instead of Combine is that the API is incorrect. BothÂ `StateStream`Â andÂ `OutputStream`Â should be streams that never fail, but thereâ€™s no way to constrain that with theÂ `AsyncSequence`Â type. In Combine, and thanks to the recent primary associated types in protocols, it would be as easy and succinct as this:

associatedtype StateStream: Publisher<State, Never>  
associatedtype OutputStream: Publisher<Output, Never>

Unlike Combine,Â `AsyncSequence`Â works by using async throwing functions, whose errors are always untyped by design.

mutating func next() async throws -> Self.Element?

Interestingly, Swift allows conforming to a protocol that declares a throwing function by omitting theÂ `throw`Â keyword in the implementation. That means that the equivalent of theÂ `Never`Â type in the Combine world would be to use a concrete implementation ofÂ `AsyncSequence`Â with a non-throwingÂ `next`Â function:

mutating func next() async -> Self.Element?

Fortunately, we will end up using the concreteÂ `StateStream`Â andÂ `OutputStream`Â types, so all this wonâ€™t be a problem.

Now, itâ€™s time to create the different flavors of thatÂ `StoreType`.

# Different Flavors of State Size

This section brings us to the first two main flavors there are, depending on how we decide to organize our state:

- One single piece of state for the whole application (_the Redux way_).
- Different distributed pieces of state across the app (_the Flux way_).

Each one has its pros and cons. The distributed approach's main "con" is keeping data consistent across those different state containers, which can be a hard problem to solve. This problem disappears altogether by just having a single state value. That is a huge advantage. But as you might expect, there are also some big cons with the single-state value approach: performance and coupling.

## The performance problem

The performance problem comes in two ways. The mutation can be expensive due to the big state value and the lack of persistent structures in Swift. But, more importantly,Â **any change of that value will retrigger view re-renders across the app**Â (or lots of recomputations of functions andÂ `Equatable`Â checks). Even if SwiftUI can be smart enough not to render some view nodes, your view bodies will still be called, and you could reach performance bottlenecks. For simple apps, this might not be a problem. I know many apps using TCA, the well-known iOS architecture using the Redux approach, which are working great. But for more complex apps, you might likely run into performance issues, although you can always use a multi-store approach. For more info, take a look at Krzysztof ZabÅ‚ockiâ€™s blog postÂ [TCA Performance and Multi-Store](https://www.merowing.info/multi-store-tca/).

## The coupling problem

The coupling problem is something that a lot of libraries using the Redux pattern have. You are just coupled to the whole â€œAppStateâ€ value. Some libraries like TCA solve that by adding quite a lot of complexity to the architecture. Propagating state changes and messages from children states to eventually the root state comes with many â€œTCA DSLâ€ and helpers that you have to learn: like using their prisms library ([CasePaths](https://github.com/pointfreeco/swift-case-paths)) to work correctly with enums. Depending on your team and their knowledge about functional programming paradigms, the price to couple your whole app to TCA might be fine or simply too much. I still think TCA might be one of the best state management libraries available for iOS nowadays.

As for my personal preference,Â **I prefer to use distributed state containers and bind the state as low as possible in the view hierarchy to avoid many view re-renders and body recomputations**. Also, having the correct bounded contexts and modules that donâ€™t need complex synchronization greatly helps. If you want to read more,Â [_Redux is half of a pattern_](https://dev.to/davidkpiano/redux-is-half-of-a-pattern-1-2-1hd7)Â is a great article.

# Different Flavors of Separating Logic and Effects

## Mixing everything

Letâ€™s start with the simplest flavor, which I already talked about inÂ [this blog post](https://medium.com/jobandtalenteng/ios-architecture-an-state-container-based-approach-4f1a9b00b82e), and the one most people should be used to. Having state and effects mixed together by using aÂ `Store`Â base class that weâ€™ll subclass (if needed).

@dynamicMemberLookup  
class Store<State, Output>: StoreType where State: Equatable {  
    private let stateSubject: CurrentValueSubject<State, Never>  
    lazy var stateStream = stateSubject.removeDuplicates().values  
  
    private let outputSubject: PassthroughSubject<Output, Never> = .init()  
    lazy var outputStream = outputSubject.values  
  
    init(state: State) {  
        self.state = state  
        stateSubject = .init(state)  
    }  
  
    @Published  
    var state: State {  
        didSet {  
            if !Thread.isMainThread {  
                // While `Store` is a main actor, we could have some non-isolated contexts where the state  
                // is not changed on the main thread. This problem can be minimized by setting "Strict Concurrency Checking"  
                // to "complete".  
                assertionFailure("Not on main thread")  
            }  
  
            // We have traceability of the state here, being able to log it if needed.  
            stateSubject.send(state)  
        }  
    }  
  
    func send(output: Output) {  
        outputSubject.send(output)  
    }  
  
    subscript<Value>(dynamicMember keypath: KeyPath<State, Value>) -> Value {  
        state[keyPath: keypath]  
    }  
}

We can use it in its simplest form, just wrapping some values that we can change and observe:

enum Output { case somethingHappened }  
let store = Store<Int, Output>(state: 0)  
  
Task {  
    for await state in store.stateStream {  
        print("New state", state)  
    }  
}  
  
Task {  
    for await output in store.outputStream {  
        print("New output", output)  
    }  
}  
  
store.state = 1  
store.send(output: .somethingHappened)

Usually, weâ€™ll subclass thatÂ `Store`Â type, where weâ€™ll have those state changes and outputs with the appropriate business logic.

enum NumbersViewState: Equatable {  
    case idle  
    case loading  
    case loaded([Int])  
    case error  
}  
  
enum NumbersViewOutput {  
    case numbersDownloaded  
}  
  
final class NumbersViewModel: Store<NumbersViewState, NumbersViewOutput> {  
    init() {  
        super.init(state: .idle)  
    }  
  
    func load() async {  
        state = .loading  
  
        do {  
            let numbers = try await apiClient.numbers()  
            state = .loaded(numbers)  
  
            // In this case, the output message is not adding anything meaningful, but it's just  
            // an example of some "fire and forget" event that can be useful for things that, unlike state, are not persistent.  
            send(output: .numbersDownloaded)  
        } catch {  
            state = .error  
        }          
    }  
}

Simple enough. We subclass theÂ `Store`Â type and provide methods (inputs) to bundle the business logic, execute side effects, change state, and trigger output messages.

Then, we can very easily subscribe to thatÂ `NumbersViewModel`Â , both from SwiftUI (by usingÂ `@StateObject`Â orÂ `@ObservedObject`), or from UIKit, by listening toÂ `StateStream`Â and rendering the state to UIKit views correctly.

Task {  
    for await state in numbersViewModel.stateStream {  
        switch state {  
        case .idle, .loading:  
            loadingView.isHidden = false  
            numbersView.isHidden = true  
            errorView.isHidden = true  
  
        case .loaded(let numbers):  
            loadingView.isHidden = true  
            errorView.isHidden = true  
            numbersView.isHidden = false  
            numbersView.render(with: numbers)  
  
        case .error:  
            loadingView.isHidden = true  
            numbersView.isHidden = true  
            errorView.isHidden = false  
        }  
    }  
}

Iâ€™ve personally had great success with this first kind of flavor. While it lacks some proper encapsulation of the state (as it can be mutated from outside the concrete store subclass due to the lack ofÂ `protected`Â semantics in Swift), itâ€™s familiar, simple, flexible, gives us accurate traceability of the state changes, and keeps them on the main thread due toÂ `@MainActor`Â semantics. I donâ€™t know of any concrete well-known iOS libraries using this pattern, but I know some of them in the Android world.Â [Airbnbâ€™s Mavericks](https://github.com/airbnb/mavericks)Â could be the most important one.Â [Orbit](https://github.com/orbit-mvi/orbit-mvi)Â is another nice one.

But sometimes, having traceability of the state is just not enough.Â **We want to know why that state changed and have a more constrained way of managing effects**. And for that, weâ€™ll need to complicate things a little bit.

## Separating logic from effects

As I said, this is where things get much more complex (but also fun). I also talked about this flavor in the pastÂ [here](https://medium.com/jobandtalenteng/ios-architecture-separating-logic-from-effects-7629cb763352).

While appealing, the simplicity and flexibility of the previous approach have their drawbacks.Â **The main one is that theÂ _freedom_Â to manage logic, state changes, and effects however we want comes at a price**. In straightforward examples like the previous one, itâ€™s hard to see the advantage of complicating that. ButÂ **with more complex business logic, teams, and requirements, having a more constrained and formal approach to dealing with state and effects is extremely useful and tends to scale better in my experience**.

Letâ€™s have some preconditions first.

- We need a way to establish the relationship between the messages, the state changes, and the effects triggered by them.
- We need to have proper encapsulation of the different message types. Wrong message encapsulation is, unfortunately, very common amongst these types of architectures. Itâ€™s not the same a publicÂ `onAppear`Â message than a privateÂ `didReceiveData`Â message.
- We need a way to model our effects correctly, leveraging async/await.

During these last few years, there have been many (too many, Iâ€™d say) flavors of these unidirectional architectures, each with its own â€œopinionsâ€ and â€œtrade-offsâ€ in the way they manage state and effects.

- Some of those are â€œtoo Combine heavyâ€, forcing you to couple your app to those Combine combinators.
- Some others bring the concept of â€œmutationâ€ on top of the concept of â€œmessageâ€ (or event/action) so they can differentiate between the actual â€œstate changeâ€ and the â€œintention of changeâ€. The main inspiration is Vueâ€™s architecture,Â [Vuex](https://vuex.vuejs.org/).Â [ReactorKit](https://github.com/ReactorKit/ReactorKit)Â is an excellent iOS library using that concept.
- Some other flavors model effects as â€œfeedbacksâ€: a simpleÂ `(Publisher<State>) -> Publisher<Event>`Â function.Â [ReactiveFeedback](https://github.com/babylonhealth/ReactiveFeedback)Â is another great library following this pattern.

In my experience, those flavors complicate things unnecessarily and make the code harder to understand. Especially the concept of modeling effects as â€œfeedback packagesâ€, as it worsens readability and obfuscates control flow. Letâ€™s imagine that we want to understand what happens in the system whenever an action happens:

- First, weâ€™d go to the function that processes the message and changes the state. That function is usually called a reducer.
- Then, to know what effects are triggered by the previous message, weâ€™d have to check all the different â€œfeedbacksâ€ to see if that new state will trigger any of those.

That makes the code hard to understand and to build the appropriate mental model needed to change that code.Â [Hereâ€™s a nice article](https://dev.to/feresr/a-case-against-the-mvi-architecture-pattern-1add)Â explaining some of these problems in an MVI architecture.

The solution?Â **Instead of â€œmagically runningâ€ the effects based on the state change, let the reducer decide the effects to run**.

That way, we can follow precisely the code execution from the point where a message is sent into the system to the point where all the effects have finished running.

_Input message -> State changed -> Effect -> Feedback messageâ€¦_

## The different ways of commanding effects

There are different ways that a reducer can decide the effect to run:

- We can wrap the effectful computation inside a data structure with the correct async context. Something like this

func handle(event: Event, state: inout State) -> Effect<Event> {  
    switch event {  
    case .onAppear:  
        state = .loading  
        return .task { send in  
            let numbers = await apiClient.numbers()  
            send(.didFinishFetching(numbers))  
        }  
  
    case .didFinishFetching(let numbers):  
        state = .loaded(numbers)  
        return .none  
    }  
}

This is howÂ [Pointfreeâ€™s TCA library](https://github.com/pointfreeco/swift-composable-architecture)Â works.

- Another option is to return a value representing the effect that will be interpreted later (by an effects handler).

func handle(event: Event, state: inout State) -> [Effect] {  
    switch event {  
    case .onAppear:  
        state = .loading  
        return [.downloadNumbers]  
  
    case .didFinishFetching(let numbers):  
        state = .loaded(numbers)  
        return .none  
    }  
}  
  
class EffectHandler {  
    func handle(effect: Effect) async {  
        switch effect {  
        case .downloadNumbers:  
            let numbers = await apiClient.numbers()  
            send(.didFinishFetching(numbers))  
        }  
    }  
}

This is howÂ [Spotifyâ€™s Mobius library](https://github.com/spotify/Mobius.swift)Â works, which, IIRC, itâ€™s based onÂ [Andy Matuschak's writing:Â _A composable pattern for pure state machines with effects_](https://gist.github.com/andymatuschak/d5f0a8730ad601bcccae97e8398e25b2).

- The last option is to return a type conforming to a protocol that bundles the asynchronous work.

func handle(event: Event, state: inout State) -> [Effect] {  
    switch event {  
    case .onAppear:  
        state = .loading  
        return [DownloadNumbers()]  
  
    case .didFinishFetching(let numbers):  
        state = .loaded(numbers)  
        return .none  
    }  
}  
  
  
class DownloadNumbers: Effect {  
    func run() async {  
        let numbers = await apiClient.numbers()  
        send(.didFinishFetching(numbers))  
    }  
}

This is howÂ [Squareâ€™s Workflow architecture](https://square.github.io/workflow/)Â works.

Each of these flavors has its pros and cons.

- The first approach has fewer â€œjumpsâ€ and itâ€™s very easy to see the result of the effect and go to the feedback messageÂ `.didFinishFetching`. The downside is that, for complex effects, the reducer can end up big and complicated. But we can always extract that code into separate functions as needed.
- The second approach has the advantage of being able to test the reducer very easily. We can exercise the function without needing to create dependencies or mock anything. The reducer becomes the â€œpure layerâ€, which is easy to test, while the â€œeffects handlerâ€ becomes the â€œimpure layerâ€, which we may not need to test, as it should be aÂ [humble object](https://martinfowler.com/bliki/HumbleObject.html).
- The third approach might have a more self-contained, cohesive package for a specific effect, bundling the dependencies needed without polluting the reducer with all the different effects dependencies.

I donâ€™t have strong opinions about the best option here, to be completely honest. The second approach is the one Iâ€™ve used the most, and it has worked well for me. But sometimes, those â€œjumpsâ€ between the reducer function and the effect handling could be inconvenient. I recommend putting both in the same file to jump between both parts easily.

And about testing with the second approachâ€¦ while we can test the reducer to see the actual effects values returned by a particular message,Â **that test might not be the best test considering that effects are implementation details**Â (at least from the storeâ€™s public API point of view). The actual state container â€œobservable APIâ€ we should assert against is the tupleÂ `(state, output)`. Changing how we handle our effects without modifying our observable API and behavior shouldnâ€™t break our tests.

For those reasons, I guess the first option might be my preferred option and the one I will implement in the next section.

## Final implementation

Letâ€™s now build the complete implementation of the aforementioned architecture. Feel free to copy everything into a playground and play with the result.

As I mentioned, having a correct encapsulation of the messages is important and leads to a safer and cleaner API. Thatâ€™s why we have three types of messages:

- **Input**:Â `.onAppear`Â events for view stores orÂ `.downloadData`Â commands for domain stores.
- **Feedback**:Â `.didDownloadData`Â event. These are private, sent from the effects, and cannot be sent directly from a store instance.
- **Output**: Fire and forget events when we need to signal information that should not persist, unlike the state.

TheÂ `Effect`Â type has two responsibilities:

- Wrapping the asynchronous work, the effect itself.
- Notifying of any output message.

struct Effect<Feedback, Output> {  
    typealias Operation = (@Sendable @escaping (Feedback) async -> Void) async -> Void  
      
    fileprivate let output: Output?  
    fileprivate let operation: Operation  
  
    init(  
        output: Output?,  
        operation: @escaping Operation  
    ) {  
        self.output = output  
        self.operation = operation  
    }  
}  
  
extension Effect {  
    static var none: Self {  
        return .init(output: nil) { _ in }  
    }  
  
    static func output(_ output: Output) -> Self {  
        return .init(output: output) { _ in }  
    }  
  
    static func run(operation: @escaping Operation) -> Self {  
        self.init(output: nil, operation: operation)  
    }  
}

The reducer will be the one modifying the state given a specific message and returning the correctÂ `Effect`Â type.

@MainActor  
protocol Reducer<State, Input, Feedback, Output>: AnyObject where State: Equatable {  
    associatedtype State  
    associatedtype Input  
    associatedtype Feedback = Never  
    associatedtype Output = Never  
  
    func reduce(  
        message: Message<Input, Feedback>,  
        into state: inout State  
    ) -> Effect<Feedback, Output>  
}

WithÂ `Message`Â being just the sum type of theÂ `Input`Â andÂ `Feedback`Â messages.

enum Message<Input, Feedback>: Sendable where Input: Sendable, Feedback: Sendable {  
    case input(Input)  
    case feedback(Feedback)  
}

And finally, the Store.

import Combine  
  
@MainActor  
@dynamicMemberLookup  
class Store<State, Input, Feedback, Output>: ObservableObject where State: Equatable, Input: Sendable, Feedback: Sendable {  
    @Published  
    private(set) var state: State  
  
    private let reducer: any Reducer<State, Input, Feedback, Output>  
  
    private let stateSubject: CurrentValueSubject<State, Never>  
    lazy var stateStream = stateSubject.removeDuplicates().values  
  
    private let outputSubject: PassthroughSubject<Output, Never> = .init()  
    lazy var outputStream = outputSubject.values  
  
    private var tasks: [Task<Void, Never>] = []  
  
    deinit {  
        for task in tasks {  
            task.cancel()  
        }  
    }  
  
    init(  
        state: State,  
        reducer: some Reducer<State, Input, Feedback, Output>  
    ) {  
        self.state = state  
        self.reducer = reducer  
        stateSubject = .init(state)  
    }  
  
    @discardableResult  
    func send(_ message: Input) -> Task<Void, Never> {  
        let task = Task { await send(.input(message)) }  
        tasks.append(task)  
        return task  
    }  
  
    func send(_ message: Input) async {  
        await send(.input(message))  
    }  
  
    private func send(_ message: Message<Input, Feedback>) async {  
        guard !Task.isCancelled else { return }  
  
        let effect = reducer.reduce(message: message, into: &state)  
        stateSubject.send(state)  
  
        if let output = effect.output {  
            outputSubject.send(output)  
        }  
  
        await effect.operation { [weak self] feedback in  
            guard !Task.isCancelled else { return }  
  
            await self?.send(.feedback(feedback))  
        }  
    }  
  
    subscript<Value>(dynamicMember keypath: KeyPath<State, Value>) -> Value {  
        state[keyPath: keypath]  
    }  
}

Letâ€™s now build the previousÂ `NumbersViewModel`Â example by using the new architecture.

import Foundation  
  
final class APIClient {  
    func numbers() async throws -> [Int] {  
        try await Task.sleep(nanoseconds: 1 * NSEC_PER_SEC)  
        return [1, 2, 3]  
    }  
}  
  
final class NumbersViewReducer: Reducer {  
    enum State: Equatable {  
        case idle  
        case loading  
        case loaded([Int])  
        case error  
    }  
  
    enum Input {  
        case onAppear  
    }  
  
    enum Feedback {  
        case numbersDownloaded(Result<[Int], Error>)  
    }  
  
    enum Output {  
        case numbersDownloaded  
    }  
  
    private let apiClient = APIClient()  
  
    func reduce(message: Message<Input, Feedback>, into state: inout State) -> Effect<Feedback, Output> {  
        switch message {  
        case .input(.onAppear):  
            state = .loading  
            return .run { [weak self] send in  
                guard let self else { return }  
  
                do {  
                    let numbers = try await apiClient.numbers()  
                    await send(.numbersDownloaded(.success(numbers)))  
                } catch {  
                    await send(.numbersDownloaded(.failure(error)))  
                }  
            }  
  
        case .feedback(.numbersDownloaded(.success(let values))):  
            state = .loaded(values)  
            return .output(.numbersDownloaded)  
  
        case .feedback(.numbersDownloaded(.failure)):  
            state = .error  
            return .none  
        }  
    }  
}  
  
import SwiftUI  
  
struct NumbersListView: View {  
    @StateObject private var viewModel = Store(  
        state: NumbersViewReducer.State.idle,  
        reducer: NumbersViewReducer()  
    )  
  
    var body: some View {  
        Group {  
            switch viewModel.state {  
            case .idle, .loading:  
                Text("â€¦")  
  
            case .loaded(let values):  
                List(values, id: \.self) { value in  
                    Text("\(value)")  
                }  
  
            case .error:  
                Text("Some error happened")  
            }  
        }.onAppear {  
            viewModel.send(.onAppear)  
        }  
    }  
}

# Conclusion

Thanks a lot for reaching the end of the article. It was a long (and hopefully interesting) read.

During these last years, weâ€™ve had an explosion of state management libraries. Weâ€™ve seen how unidirectional architectures have taken over the Mobile space, especially alongside new UI declarative frameworks like SwiftUI (and Jetpack Compose on Android), where they perfectly fit.

But not only SwiftUIâ€¦ async/await has also made a big impact on how we develop our apps and handle concurrency and side effects, which has impacted many of the new architectures that have emerged during these last years.

All the separation of state management and effects has emerged a lot of new functional paradigms within the iOS community, with many people already using TCA as their default architecture for any new iOS project with SwiftUI. This is great news and shows the maturity of the iOS ecosystem at this point.

While Swift will keep evolving, I donâ€™t particularly foresee any major changes in the coming years that will dramatically change how we develop applications, or at least in a way that can impact state management libraries so drastically, as has happened recently.

Wellâ€¦ Maybe â€œSwift Dataâ€ to replace Core Dataâ€¦ weâ€™ll see in a few months atÂ [WWDC23](https://developer.apple.com/wwdc23/).

[  
](https://medium.com/tag/ios?source=post_page-----781a01380ef6---------------ios-----------------)